[{"title":"promise实现","date":"2018-09-28T22:25:15.000Z","path":"2018/09/29/promise实现/","text":"实现一个简单的promise 首先实现这种形式 12345678910111213new Promise((resolve, reject)=&gt;&#123; console.log(111) resolve(222)&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const pedding = 'pedding';const fulfilled = 'fulfilled';const rejected = 'rejected';const isFunction = (val) =&gt; typeof val === 'function'class MyPromise &#123; constructor(handler) &#123; if(!isFunction(handler)) &#123; throw new Error('promise必须传入函数！') &#125; // 值传递 this._value; // 内部状态 this._status = pedding; try &#123; // 保证异步调用时this指向 handler(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (error) &#123; &#125; &#125; _resolve(val) &#123; this._value = val; // resolve之后更改状态 this._status = fulfilled; &#125; _reject(val) &#123; &#125; then(resolve, reject) &#123; const &#123; _value, _status &#125; = this switch(_status) &#123; case pedding: break; case fulfilled: resolve(_value); break; case rejected: reject(_value) break; &#125; &#125;&#125; 对异步的处理 上面那种形式如果碰见异步就会出现问题，如何实现异步的情况？类似订阅发布形式。 123456789101112131415new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(111) resolve(222) &#125;, 100)&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class MyPromise &#123; constructor(handler) &#123; if(!isFunction(handler)) &#123; throw new Error('promise必须传入函数！') &#125; // 值传递 this._value; // 内部状态 this._status = pedding; this._fulfilledList = []; this._rejectedList = []; try &#123; // 保证异步调用时this指向 handler(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (error) &#123; &#125; &#125; _resolve(val) &#123; // 避免resolve多次执行 if(this._status !== pedding) return // resolve之后更改状态，如果用解构赋值，这里就不执行？ this._status = fulfilled; this._value = val; this._fulfilledList.forEach((item)=&gt;&#123; item(val) &#125;) &#125; _reject(val) &#123; if(this._status !== pedding) return this._status = rejected; this._value = val; this._rejectedList.forEach((item)=&gt;&#123; item(val) &#125;) &#125; then(onFulfilled, onRejected) &#123; const &#123; _value, _status, _fulfilledList, _rejectedList &#125; = this switch(_status) &#123; case pedding: _fulfilledList.push(onFulfilled); _rejectedList.push(onRejected); break; case fulfilled: onFulfilled(_value); break; case rejected: onRejected(_value) break; &#125; &#125;&#125; then之间的值传递 链式调用中，上一个then的返回值，下一个then如何接收？这里要用到闭包。 1234567891011121314151617181920new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(111) resolve(222) &#125;, 100)&#125;).then((data)=&gt;&#123; console.log(data) return 333&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222333 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.......then(onFulfilled, onRejected) &#123; const &#123; _value, _status, _fulfilledList, _rejectedList &#125; = this return new MyPromise((nextFulfiled, nextRejected)=&gt;&#123; const _onFulfilled = (val) =&gt; &#123; let res = onFulfilled(val); nextFulfiled(res) &#125; const _onRejected = (val) =&gt; &#123; let res = onRejected(val); nextRejected(res) &#125; switch(_status) &#123; case pedding: _fulfilledList.push(_onFulfilled); _rejectedList.push(_onRejected); break; case fulfilled: onFulfilled(_value); break; case rejected: onRejected(_value) break; &#125; &#125;) &#125;new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(1111) resolve(2222) &#125;, 500)&#125;).then((data)=&gt;&#123; console.log(data) return 333&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：11112222333 大体上就完成了Promise的基本功能，具体可以看下Promise源码","comments":true,"tags":[]},{"title":"数据可视化","date":"2018-08-13T23:58:25.000Z","path":"2018/08/14/数据可视化/","text":"如何提高可视化技术先掌握工具 信息图表 D3图形知识 ECharts和G2 地理空间 Leaflet OpenLayer Mapbox 三维空间 three.js最全的webgl库 spritejs好用的canvas动画库","comments":true,"tags":[]},{"title":"数据结构","date":"2018-08-12T22:59:54.000Z","path":"2018/08/13/数据结构/","text":"","comments":true,"tags":[]},{"title":"算法","date":"2018-08-12T22:59:40.000Z","path":"2018/08/13/排序算法/","text":"排序算法 稳定性：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。 冒泡排序从小到大排序，比较相邻元素，如果前一个比后一个大，则调换位置。如果有n个数据，那么就要进行n-1趟排序，每趟排序比较次数根据趟数决定。 12345678910111213141516171819202122232425262728293031/*数据结构 ---------- 数组最差时间复杂度 ---- O(n^2)最优时间复杂度 ----O(n)平均时间复杂度 ---- O(n^2)所需辅助空间 ------ O(1)稳定性 ------------ 稳定*/var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort1() &#123; let len = arr.length; for (let i = 0; i &lt; len-1; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // es5版 let temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; // es6版 //[arr[j], arr[j+1]] = [arr[j+1], arr[j]]; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort1(arr)) n个数据最后一趟，也就是 n-1 趟的时候，不用循环，因为前面都已经比较过了。它的时间复杂度n^2-n，所有它的时间复杂度还是O(n^2)，只要保证第一趟把最大的放在顶端就行。 如果数组内层循环只需一次就排好序，然后就调出循环，那么他的时间复杂度 O(n)。 平均时间复杂度是一种数学期望值，需要对输入的分布情况进行假设，一般都是通过运行一定数量的实验数据后估算出来的。设每种情况的出现的概率为pi,则为sum(pi*f(n)) 冒泡排序改进 1鸡尾酒排序，算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。保证每一趟把最大的放在顶端，最小的放在底端就行。 1234567891011121314151617181920212223242526var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort2() &#123; let len = arr.length, left = 0, right = len-1; for (; left &lt; right; ) &#123; for (let i = left; i &lt; right; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; [arr[i], arr[i+1]] = [arr[i+1], arr[i]]; &#125; &#125; right--; for (let j = right; j &gt; left; j--) &#123; if (arr[j] &lt; arr[j-1]) &#123; [arr[j], arr[j-1]] = [arr[j-1], arr[j]]; &#125; &#125; left++; &#125; return arr;&#125;console.log(bubbleSort2(arr)) 冒泡排序改进 2每进行一趟比较记录最后交换的位置flag。由于flag之后的位置已经交换完成，所以下一趟只需扫描到flag位置即可。 123456789101112131415161718192021var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort3() &#123; let len = arr.length; for (let i = len-1; i &gt; 0; ) &#123; // 必须初始化，否则可能死循环 flag = 0 for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; flag = j; &#125; &#125; i = flag; &#125; return arr;&#125;console.log(BubbleSort3(arr)) 冒泡排序改进 3如果每一趟能够决定最小的flag和最大的flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort4() &#123; let len = arr.length, left = 0, right = len-1, right_pointer = 0, left_pointer = 0; for (; left &lt; right ; ) &#123; for (let i = left; i &lt; right; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; [arr[i], arr[i+1]] = [arr[i+1], arr[i]]; right_pointer = i; &#125; &#125; right = right_pointer; for (let j = right; j &gt; left; j--) &#123; if (arr[j] &lt; arr[j-1]) &#123; [arr[j], arr[j-1]] = [arr[j-1], arr[j]]; left_pointer = j; &#125; &#125; left = left_pointer; // 临界值判断 if (left === right-1 &amp;&amp; arr[left] &lt; arr[right]) break; &#125; return arr;&#125;console.log(BubbleSort4(arr))``` #### 可以用下面的方法简单测一下计算时间：``` bash// 新建4个相同的数组，分别测试console.time('BubbleSort');console.timeEnd('BubbleSort');``` 大致结果如下，每次运行都不一样，结果还是蛮`尴尬`的，BubbleSort1第一名的几率比较大，也排除了新建空间问题，是不是数据量太少的原因。![algorithm](/assets/blogImg/algorithm/s1.png \"sort\")### 选择排序 选择排序：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后类似这样往下排序。``` bash// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- O(n^2)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定var arr = [6, 5, 3, 3, 3, 3, 1, 8, 7, 2, 4]function SelectionSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; let min = i; for (var j = i+1; j &lt; arr.length; j++) &#123; if(arr[min]&gt;arr[j]) &#123; min = j; &#125; &#125; [arr[min], arr[i]] = [arr[i], arr[min]] &#125; return arr;&#125;console.log(SelectionSort(arr))``` ### 选择排序 2每趟排序决定1个最大值和一个最小值``` bashfunction SelectionSort(arr) &#123; var len = arr.length for (let i = 0; i &lt; len; i++,len--) &#123; let min = i, max = len-1; for (var j = i+1; j &lt; len; j++) &#123; if(arr[min]&gt;arr[j]) &#123; min = j; &#125; if(arr[max]&lt;arr[j]) &#123; max = j &#125; &#125; // swap(min, i) // swap(max, len-1) // 如果前面没有if判断，连续2个ES6解构交换会出错，出现好多最大数。 if(min !== i) [arr[min], arr[i]] = [arr[i], arr[min]] if(max !== len-1) [arr[max], arr[len-1]] = [arr[len-1], arr[max]] // [arr[min], arr[i]] = [arr[i], arr[min]] // [arr[max], arr[len-1]] = [arr[len-1], arr[max]] &#125; return arr;&#125;function swap(m, n) &#123; // if(m!==n) &#123; var temp = arr[m]; arr[m] = arr[n]; arr[n] = temp; // &#125;&#125;``` ### 插入排序插入排序：默认把左边第一个元素已经排好序，取下一个元素，从后向前扫描反复把已排序元素逐步向后挪位，为最新元素提供插入空间。``` bash// 分类 ------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定function InsertionSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; const get = arr[i]; var j = i-1; // 控制j是最后一个小于get的索引 for (; j &gt;= 0 &amp;&amp; arr[j] &gt; get; j--) &#123; // if(arr[j] &gt; get) &#123; arr[j+1] = arr[j]; // &#125; &#125; arr[j+1] = get &#125; return arr;&#125;``` ### 插入排序 2二分插入排序： 因为左边的数列已经排好序，那么可以采用二分法来减少比较次数。#### 二分查找的时间复杂度。时间频度为T(n)，n为问题规模。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。 `尴尬```` bash// 最差时间复杂度// 假设数据规模是n，则T(n)为除以2再加上一次比较的过程为O(1) T(n) = T(n/2) + O(1)以此类推： T(n) = T(n/2^1) + O(1) = (T(n/2^2)+O(1)) + O(1) = (T(n/2^3)+O(1)+O(1)) + O(1) .....辅助函数f(n)=n/2^k , 比较次数是k;其中f(n)=n/2^k&lt;=1 =&gt; n&lt;=2^k =&gt;logn&lt;=k // 大O表示法中的对数表示T(n) = [logn]O(1) =&gt; T(n)/f(n)=O(1) =&gt; O(logn)因此二分查找的时间复杂度是logN。``` #### 二分插入排序``` bashfunction InsertionSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; const get = arr[i]; var right = i-1, left = 0; for (;left &lt;= right;) &#123; let mid = Math.ceil((left+right)/2) if (arr[mid] &gt; get) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; for (var j = i-1; j &gt;= left; j--) &#123; arr[j+1] = arr[j]; &#125; arr[j+1] = get &#125; return arr;&#125; ``` ### 快速排序算法描述：从序列中挑出一个元素，作为\"基准\"，把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边）。快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。``` bash// 分类 ------------ 内部比较排序// 数据结构 --------- 数组// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n) // 稳定性 ---------- 不稳定function quickSort(arr, left, right) &#123; if (left &gt;= right) &#123; return; &#125; var pivotIndex = partition(arr, left, right); quickSort(arr, left, pivotIndex-1); quickSort(arr, pivotIndex+1, right); return arr;&#125;// 将数组分区，分成以pivot为基准，左边是小于它的，右边是大于它的。function partition(arr, left, right) &#123; let pivot = arr[right], pointer = left; for(let i = left; i &lt; right; i++) &#123; if(arr[i] &lt; pivot) &#123; // 用es6特性会出现undefined和多出数字，所以说这个特性内部怎么实习的 // [arr[i], arr[pointer++]] = [arr[pointer++], arr[i]] swap(arr, pointer++, i) &#125; &#125; // [arr[pointer], arr[right]] = [arr[right], arr[pointer]] swap(arr, pointer, right) return pointer;&#125;function swap(arr, m, n) &#123; var temp = arr[m]; arr[m] = arr[n]; arr[n] = temp;&#125;``` ### 快速排序2关于阮的快排``` bashvar quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;;// v8中splice是时间复杂度为O(n)。// 每次递归都需要开了2个临时数组，空间复杂度和当前数组的时间复杂度有关。``` ### 希尔排序希尔排序: 又叫递减增量排序，是插入排序的一种更高效的改进版本。将全部数据分成几个区域来进行插入排序，然后取越来越小的步数分别进行插入排序，最后是普通的插入排序。``` bash// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)// 最优时间复杂度 ---- O(n)// 平均时间复杂度 ---- 根据步长序列的不同而不同。// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定function shellSort(arr) &#123; var h = 0, n = arr.length; // 比 h&lt;=n 少比较几次 while (h &lt;= n/3) &#123; // 生成初始增量 h = 3 * h + 1; &#125; // 第一趟增量最大 while (h&gt;=1) &#123; // 每次+1，比较还是距离增量的2个数 for(let i=h; i&lt;n; i++) &#123; let j = i-h, get = arr[i]; // get分别和i-h，i-2h...进行比较 for(;j&gt;=0 &amp;&amp; arr[j]&gt;get;)&#123; arr[j+h] = arr[j]; j=j-h; &#125; arr[j+h] = get; &#125; h = (h-1)/3 &#125; return arr;&#125;``` ### 归并排序归并排序：指的是将两个已经排序的序列合并成一个序列的排序操作。1945年由冯·诺伊曼由首次提出。``` bash// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(n)// 稳定性 ------------ 稳定// 递归实现的归并排序(自顶向下)function MergeSortRecursion (A, left, right) &#123; // 当待排序的序列长度为1时，递归开始回溯，进行merge操作 if (left == right) return; var mid = Math.floor((left + right) / 2); MergeSortRecursion(A, left, mid); MergeSortRecursion(A, mid + 1, right); Merge(A, left, mid, right); return A&#125;// 把2数组变成有序的一个数组function Merge(A, left, mid, right)&#123; var len = right - left + 1; var temp = new Array(len); // 辅助空间O(n) var index = 0; var i = left; // 前一数组的起始元素 var j = mid + 1; // 后一数组的起始元素 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; // 带等号保证归并排序的稳定性 &#125; while (i &lt;= mid) &#123; temp[index++] = A[i++]; &#125; while (j &lt;= right) &#123; temp[index++] = A[j++]; &#125; for (var k = 0; k &lt; len; k++) &#123; A[left++] = temp[k]; &#125;&#125;// 非递归(迭代)实现的归并排序(自底向上)function MergeSortIteration (A, len) &#123; var left, mid, right; // 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right] for (var i = 1; i &lt; len; i *= 2) // 子数组的大小i初始为1，每轮翻倍 // 左边数组初始是1，右边初始也是1，总长队为2，依次往后整个数组比较完毕后，初始是2.... &#123; left = 0; while (left + i &lt; len) // 后一个子数组存在(需要归并) &#123; mid = left + i - 1; right = mid + i &lt; len ? mid + i : len - 1;// 后一个子数组大小可能不够 Merge(A, left, mid, right); left = right + 1; // 前一个子数组索引向后移动 &#125; &#125; return A &#125; 堆排序堆排序是指利用堆这种数据结构所设计的一种选择排序算法，堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的）。将初始待排序关键字序列构建成大顶堆（小），将堆顶元素R[1]与最后一个元素R[n]交换，交换后，再次将无序区变为大顶堆（小），以此类推。 树满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上的二叉树。 完全二叉树：对于一颗具有n个结点的二叉树按层序编号，如果编号为i(1&lt;=i&amp;&amp;i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同的二叉树。 大多数情况下用数组表示数不是很有效率,除非是完全二叉树.但是普通的二叉树,特别是有很多空节点的.会有很多空洞,浪费存储空间.用数组表示树,删除节点是很费时费力的. 所以用数组表示树适合用于 完全二叉树查找,和插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function HeapSort (A, n) &#123; var heap_size = BuildHeap(A, n); // 建立一个最大堆 while (heap_size &gt; 1) &#123; // 堆（无序区）元素个数大于1，未完成排序 // 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素 // 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法 Swap(A, 0, --heap_size); Heapify(A, 0, heap_size); // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn) &#125; return A&#125;function BuildHeap(A, n) &#123; // 建堆，时间复杂度O(n) var heap_size = n; // Math.floor或Math.ceil并不影响 for (var i = Math.floor(heap_size / 2) - 1; i &gt;= 0; i--) // 从每一个非叶结点开始向下进行堆调整 Heapify(A, i, heap_size); return heap_size; &#125;function Heapify(A, i, size)&#123; // 从A[i]向下进行堆调整 var left_child = 2 * i + 1; // 左孩子索引 var right_child = 2 * i + 2; // 右孩子索引 var max = i; // 选出当前结点与其左右孩子三者之中的最大值 if (left_child &lt; size &amp;&amp; A[left_child] &gt; A[max]) max = left_child; if (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) max = right_child; if (max != i) &#123; Swap(A, i, max); // 把当前结点和它的最大(直接)子节点进行交换 Heapify(A, max, size); // 递归调用，继续从当前结点向下进行堆调整 &#125;&#125;function Swap(A, i, j)&#123; var temp = A[i]; A[i] = A[j]; A[j] = temp;&#125; 练习有两个数组，元素个数可能相差很多，但也可能几乎相同，求它们交集的最优算法。 123456789101112131415161718191、2个for循环，时间复杂度为O(n2),空间复杂度O(1)；2、先将2个数组排好序，2个指针分别指向2个数组的，从到到尾扫描。时间复杂度为O(nlogn),空间复杂度O(1)。3、建立hash表，时间复杂度为O(1),空间复杂度O(min(N,M))。var arr1 = [2,31,4,3,2,1,6,7,33,34,32,31,39], arr2 = [3,4,8,6,7,9,10], obj = &#123;&#125;;// Map结构访问key不需要扫描所有的属性，访问的时间复杂度为O(1)，达到空间换时间的目的。for (let index = 0; index &lt; arr2.length; index++) &#123; const element = arr2[index]; obj[element]=1&#125; var arr1 = arr1.filter((ele)=&gt;&#123; return obj[ele]&#125;)console.log(arr1)","comments":true,"tags":[]},{"title":"工程化","date":"2018-07-28T23:07:33.000Z","path":"2018/07/29/工程化/","text":"所谓工程化就是方法论，将软件研发的各个链路规范化，系统化，流程化 单元测试 网页性能分析 代码托管 bug日志 模块加载器 脚手架CLI搭建 数据分析（可视化） 接口测试（压力测试）","comments":true,"tags":[]},{"title":"架构设计","date":"2018-07-28T23:04:57.000Z","path":"2018/07/29/架构设计/","text":"Underscore Jquery Lodash Underscore首先，underscore的基本语法如下 123456789var a = _.indexOf([1, 1, 2, 1, 2], 2);console.log('a: ',a)var b = _([1, 1, 2, 1, 2]).indexOf(2)console.log('b: ',b)a: 2b: 2 也就是说既支持实例化对象形式的调用，又支持工具方法的形式的调用。 假如这样设计 12345678910111213141516171819202122232425262728(function(root)&#123; // 这样做的目的_可以当做对象，方法，构造函数 var _ = function() &#123; // (this instanceof _)这个括号必须加 if(!(this instanceof _)) &#123; return new _(); &#125; &#125; _.indexOf = _.prototype.indexOf = function() &#123; console.log(1111) return '' &#125; ...... return root._ = _&#125;)(this)console.log(_.indexOf())console.log(_().indexOf())结果：11111111 那么将如何实现这种形式的语法？ _([1, 1, 2, 1, 2]).indexOf(2)，用ES6的默认值不能实现吗？ 123456789var _ = function(obj) &#123;if(!(this instanceof _)) &#123; return new _(obj)&#125;this.wrapped = obj&#125;？？？？？？？ 类似这种： 12345_.indexOf = _.prototype.indexOf = function(args=this.wraped) &#123; console.log(args) return &apos;&apos;&#125; 如果我把对象上的方法都写在一个对象上，然后扩展到原型上 12// 个人感觉这种思路也可以_.prototype = Object.assign(_.prototype, _) 把obj 用call 或 apply 的形式传到要调用的函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243core.js _.each = function(arr, cb) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; cb.call(arr, arr[i], i) &#125;;&#125; _.functions = function(obj) &#123; var result = []; for (var key in obj) &#123; // 忽略掉那些从原型链上继承到的属性。 if (obj.hasOwnProperty(key)) &#123; result.push(key) &#125; &#125;; return result;&#125;// 将对象上的方法添加到原型链上_.mixin = function(obj) &#123; _.each(_.functions(obj), function(value, index) &#123; var fun = obj[value] obj.prototype[value] = function() &#123; console.log('arguments: ',arguments) console.log('this.wrapped: ',this.wrapped) fun.apply(this,...) fun.call(this,...) &#125;; &#125;)&#125;_.mixin(_)root._ = _;当执行 _([1, 1, 2, 1, 2]).indexOf(2)结果：this.wrapped: (5) [1, 1, 2, 1, 2]arguments: Arguments [2, callee: ƒ, Symbol(Symbol.iterator): ƒ] 原型共享之Jquery12345// jQuery.fn和jQuery.prototype指向相同引用。jQuery.fn = jQuery.prototype = &#123;&#125;jQuery.fn.init.prototype = jQuery.fn 它们之间共享原型。那么无论是通过jQuery的实例对象，还是init的实例对象，只要在jQuery原型上的方法，它们都可以调 用。所有只需在jQuery的原型上扩展方法就可以，然后通过下面返回init实例。 12345678910111213(function (root, factory) &#123; root.$=factory()&#125;)(this,function()&#123; jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context ); &#125;, return jQuery;&#125; 就可以随意的访问jQuery原型的方法。 那为什么不直接返回jQuery的实例呢？如下： 12345678(function (root, factory) &#123; root.$=factory()&#125;)(this,function()&#123; return new jQuery()&#125; 因为会栈溢出死循环！ 这样的话，我们就能够 1$()通过实例调用方法，不需要通过 instanceof 来判断。 当然可以选用UMD规范同时兼容了浏览器、Node环境及AMD规范。 123456789101112131415161718192021// if the module has no dependencies, the above pattern can be simplified to(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], factory); &#125; else if (typeof module === 'object' &amp;&amp; module.exports) &#123; // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); &#125; else &#123; // Browser globals (root is window) root.returnExports = factory(); &#125;&#125;(typeof self !== 'undefined' ? self : this, function () &#123; // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;)); 剩下的就是扩展api 123456789101112131415161718192021222324252627282930313233343536(function (root, factory) &#123; root.$=factory()&#125;)(this,function()&#123; var jQuery = function() &#123; return new jQuery.fn.init() &#125; jQuery.fn = jQuery.prototype = &#123; init:function() &#123; &#125;, css: function() &#123; ..... &#125; ...... &#125; jQuery.fn.init.prototype = jQuery.fn // 扩展工具方法，任意对象、jQuery本身、实例对象 jQuery.extend = jQuery.fn.extend = function() &#123; ..... &#125; return jQuery;&#125;// 通常覆盖默认配置$.extend(xxx, xxxx); 函数式编程实现jq调用方法的形式123456789101112131415161718192021222324function batch(fn)&#123; return function(target, ...args)&#123; if(target.length &gt;= 0)&#123; return Array.from(target).map(item =&gt; fn.apply(this, [item, ...args])); &#125;else&#123; return fn.apply(this, [target, ...args]); &#125; &#125;&#125;function setColor(el, color)&#123; el.style.color = color;&#125;setColor = batch(setColor);let items1 = document.querySelectorAll('ul &gt; li:nth-child(2n + 1)');setColor(items1, 'red');// 类似这种对过程的抽象，最终实现下面这种形式的编码$('ul &gt; li:nth-child(2n + 1)').css(&#123;color: 'red'&#125;).text('abc'); // 没及时的写，结果返回去找资料写。","comments":true,"tags":[]},{"title":"mobx文档翻译","date":"2018-07-08T22:54:59.000Z","path":"2018/07/09/mobx文档翻译/","text":"十分钟交互式的 MobX + React 教程外文链接 关于MobX and React十分钟的介绍mobx是一个简单，可控，经过战火洗礼的状态管理解决方案。这个 教材将用10分钟教你 MobX 的所有重要概念。MobX 是一个单独的库，但是大多数人结合react使用它并且这 篇教材主要讲述的就是那个组合。 核心思想状态是每个应用的核心并且没有更快的方式去创建这种机制，没有状态管理的应用产生了不协调的状态或者用未约束的本地变量控制状态。因此，很多很多状态管理解决方案尽力去限制你修改状态的方式。例如说，通过制作状态的immutable去限制你修改状态。但是，这种方式有新的问题。数据必须被标准化，引用完整性不再是有保证的并且它将几乎不可能去使用像prototypes一样有力的概念。 MobX 通过解决根本问题确保状态管理的简单。它确保不可能去生产一个未限制的状态。实现这种方式的策略是简单的：确保所有变量和函数能够从应用状态衍生，自动得去衍生。 从概念上讲MobX 就像电子表格的公式一样处理你的应用。 1.首先有一个应用状态。对象图像，数组，事物，应用模型表单，这些值都是你的应用数据源。 2.第二，有一些派生值。基本上，在你的应用状态任何值都能够自动得被计算。这些派生值或计算值能够从简单的值，比如 未完成todos的编号，到复杂的东西，比如你的todos一个可视化HTML表现，变化得到。类比于电子表格中：这些是你应用的公式和图表。 3.Reactions 是和派生非常相似的。主要的不同是这些函数不能产生一个值。而是，它们会自动执行去完成一些任务。通常这是和 I/O 相关的操作。它们确保 DOM 被更新或者网络请求在正确的时间被自动执行。 4.最后是一些 actions 。Actions 是改变状态的所有操作。MobX 将确保所有由于 actions 造成的应用状态的改变，都是由派生和 reactions 同步地间断性地自动处理。 一个简单的 todo store…足够的理论，用行动去熟悉这些理论可能会比仔细得阅读上面文档更深入。为了创意起见，我们开始一个简单的 ToDo store。 所有在下面的代码块的笔记是可编辑的。所以可以使用运行代码按钮去执行它们。下面是一个非常简单的 维护一个todos 集合的 TodoStore 。目前仍没涉及 MobX 。 123456789101112131415161718192021222324252627class TodoStore &#123; todos = []; get completedTodosCount() &#123; return this.todos.filter( todo =&gt; todo.completed === true ).length; &#125; report() &#123; if (this.todos.length === 0) return \"&lt;none&gt;\"; return `Next todo: \"$&#123;this.todos[0].task&#125;\". ` + `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`; &#125; addTodo(task) &#123; this.todos.push(&#123; task: task, completed: false, assignee: null &#125;); &#125;&#125;const todoStore = new TodoStore(); 我们仅仅用一个todos 集合创建了一个todoStore 实例。用一些对象去填充todoStore 。为了确保我们能看见改变的效果，我们在每个 改变之后调用todoStore.report记录它。报告的笔记总是有意的打印仅仅第一个任务。这样做使这个例子有点人为干预，但是就像你 下面看到的很好的示范了 MobX 的依赖和追踪是动态的。 123456789101112131415todoStore.addTodo(\"read MobX tutorial\");console.log(todoStore.report());todoStore.addTodo(\"try MobX\");console.log(todoStore.report());todoStore.todos[0].completed = true;console.log(todoStore.report());todoStore.todos[1].task = \"try MobX in own project\";console.log(todoStore.report());todoStore.todos[0].task = \"grok MobX tutorial\";console.log(todoStore.report()); 变成响应式到目前为止这些代码没有什么特别之处。但是，如果我们不需要去显式的调用report ，仅仅需要在每个想要去被改变状态上声明。 它将免去我们从可能影响报告的代码任何地方调用report 的责任。我们想要去确保打印的是最新的报告，但是又不想被约束所困扰。 幸运地是MobX 确切地能为我们做那些事情。自动地执行代码仅仅依赖于state。所以我们的report 函数自动执行，就像电子表格中的 图表。为了实现这样的需求，TodoStore 变成了可观察的，所以MobX 能够跟踪所有所有正在进行的改变。让我们修改类去就足以实现它。 并且，completedTodosCount 能够从todo 列表自动的得到。通过使用@observable 和 @computed 装饰器我们能 够引进观察属性在一个对象。 123456789101112131415161718192021222324252627282930313233class ObservableTodoStore &#123; @observable todos = []; @observable pendingRequests = 0; constructor() &#123; mobx.autorun(() =&gt; console.log(this.report)); &#125; @computed get completedTodosCount() &#123; return this.todos.filter( todo =&gt; todo.completed === true ).length; &#125; @computed get report() &#123; if (this.todos.length === 0) return \"&lt;none&gt;\"; return `Next todo: \"$&#123;this.todos[0].task&#125;\". ` + `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`; &#125; addTodo(task) &#123; this.todos.push(&#123; task: task, completed: false, assignee: null &#125;); &#125;&#125;const observableTodoStore = new ObservableTodoStore(); 就像上面那样！我们标记了一些属性@observable 做为对MobX 的信号，意味着这些值能够随时被改变。用装饰器 @computed 声明的计算值，能够确定地从state中推断出来。 上面的pendingRequests 和assignee 属性到目前为止还没被使用。但是将在这篇教材后面使用。为了简洁，这个页面的所有例子 使用ES6，JSX和装饰器。但是不要担心，所有在MobX 的装饰器有相应的ES5 匹配。 在构造函数中，我们创建了小的函数，能够去打印report 并且被包装在了autorun 中。 Autorun 创建了一个运行一次的响应式。 并且之后无论什么时候我们内部使用函数变化它都会自动运行。因为report 使用可观察的todos 属性，它将打印报告在适当的时候。 在下面的列表中是一个演示。按运行按钮就可以。 123456observableTodoStore.addTodo(\"read MobX tutorial\");observableTodoStore.addTodo(\"try MobX\");observableTodoStore.todos[0].completed = true;observableTodoStore.todos[1].task = \"try MobX in own project\";observableTodoStore.todos[0].task = \"grok MobX tutorial\"; 纯属搞笑？上面的report 自动地，同步地，并且中间值没有遗漏。如果你小心的调查日志，你将看见在新的日志行中第四行 没有结果。因为上面的report 做为重命名的结果确实没有改变，尽管后面的数据改变了。另一方面第一个todo 名字的改变 确实更新了report ,因为那个名字活跃地使用在报告中。这个很好的示范不仅仅是todos 里面通过autorun 被观察的数组，还有 在todo 里面独立的属性被观察。 使react变成响应式好的，到目前为止我们做了一个简单的响应式report。是时候用一个相同的store 去构建一个响应式用户接口。React 组件在盒子外面 不是响应式的。来自mobx-react 包的 @observer 装饰器通过在 autorun 方法中包装React 组建的render 方法。自动地使你的组件和 状态同步。那在概念上不同于我们之前做的report 。 下面的列表定义了一些React 组件。MobX 仅仅用的就是@observer 装饰器。那足够去确保每个组件单独得去重新渲染， 当相关数据改变的时候。 你不在需要去调用setState 。你也不再需要去计算怎样用选择器或可配置的高阶组建去适当地订阅应用状态。 基本上，所有组件变成了容器组建。但是，它们是用陈述式的方式定义在纯组件中。 按运行代码的按钮去看下面代码的运行。列表是可编辑的，所以可以随意修改。为了测试可以尝试删除所有@observer 的调用， 或者仅仅保留TodoView 的一个装饰器。每次组建重新渲染的时候，在右边的数字就会高亮显示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@observerclass TodoList extends React.Component &#123; render() &#123; const store = this.props.store; return ( &lt;div&gt; &#123; store.report &#125; &lt;ul&gt; &#123; store.todos.map( (todo, idx) =&gt; &lt;TodoView todo=&#123; todo &#125; key=&#123; idx &#125; /&gt; ) &#125; &lt;/ul&gt; &#123; store.pendingRequests &gt; 0 ? &lt;marquee&gt;Loading...&lt;/marquee&gt; : null &#125; &lt;button onClick=&#123; this.onNewTodo &#125;&gt;New Todo&lt;/button&gt; &lt;small&gt; (double-click a todo to edit)&lt;/small&gt; &lt;RenderCounter /&gt; &lt;/div&gt; ); &#125; onNewTodo = () =&gt; &#123; this.props.store.addTodo(prompt('Enter a new todo:','coffee plz')); &#125;&#125;@observerclass TodoView extends React.Component &#123; render() &#123; const todo = this.props.todo; return ( &lt;li onDoubleClick=&#123; this.onRename &#125;&gt; &lt;input type='checkbox' checked=&#123; todo.completed &#125; onChange=&#123; this.onToggleCompleted &#125; /&gt; &#123; todo.task &#125; &#123; todo.assignee ? &lt;small&gt;&#123; todo.assignee.name &#125;&lt;/small&gt; : null &#125; &lt;RenderCounter /&gt; &lt;/li&gt; ); &#125; onToggleCompleted = () =&gt; &#123; const todo = this.props.todo; todo.completed = !todo.completed; &#125; onRename = () =&gt; &#123; const todo = this.props.todo; todo.task = prompt('Task name', todo.task) || todo.task; &#125;&#125;ReactDOM.render( &lt;TodoList store=&#123; observableTodoStore &#125; /&gt;, document.getElementById('reactjs-app')); 下一个列表很好的展示了我们不需要做其它任何事情就可以修改我们的数据。MobX 将自动派生和更新在store 中的state 用户接口相关 的部分。 123456const store = observableTodoStore;store.todos[0].completed = !store.todos[0].completed;store.todos[1].task = \"Random todo \" + Math.random();store.todos.push(&#123; task: \"Find a fine cheese\", completed: true &#125;);// etc etc.. add your own statements here... 通过引用运行到目前为止，我们在数组和数据源上增加了观察对象。你可能担心MobX 如何处理这些引用。在我的state 允许形成图表？ 在前面的列表中你可能注意到在todos 中有一个assignee 属性。让我们引入另一个 “store” 去给它们一些值。 包括人和给他们分配任务。 12345678var peopleStore = mobx.observable([ &#123; name: \"Michel\" &#125;, &#123; name: \"Me\" &#125;]);observableTodoStore.todos[0].assignee = peopleStore[0];observableTodoStore.todos[1].assignee = peopleStore[1];peopleStore[0].name = \"Michel Weststrate\"; 我们现在有两个独立的 stores 。一个是 people 并且另一个是 todos。为了从people store 中分配一个assignee 给一个人。 我们仅仅指定一个引用。这些改变将被TodoView 自动地执行。使用MobX 没有必要首先去标准化数据并且去写选择器确保我们组件将 被更新。事实上，数据存储到哪里不重要。只要数据被 observable，MobX 将能够追踪它们。真正的JavaScript 引用将产生作用。MobX 将自动追踪它们如果它们是一个派生的引用。为了去测试它们，在下面的输入框中，尽力去改变你的名字。 12Your name: 随便说一下，上面输入框的HTML是简单的： 12&lt;input onkeyup=\"peopleStore[1].name = event.target.value\" /&gt; 异步actions因为在我们小的Todo 应用中每个属性都是从state 中派生出来的，当状态改变时它确实无关紧要。创建一个异步的actions 确实很简单。 仅仅按下面的按钮去模仿异步加载新的todo 选项。 12按钮 &lt;-_&lt;- 后面的代码相当简单。我们以更新store 属性pendingRequests 开始，去有一个当前当前加载状态UI 的反应。一旦加载完成我们就 更新store 的todos 并且再次减少pendingRequests 的计数。仅仅用更早的TodoList 定义比较这段代码，去了解pendingRequests 熟悉 如何被使用。 123456observableTodoStore.pendingRequests++;setTimeout(function() &#123; observableTodoStore.addTodo('Random Todo ' + Math.random()); observableTodoStore.pendingRequests--;&#125;, 2000);","comments":true,"tags":[]},{"title":"网页分析","date":"2018-06-18T08:08:18.000Z","path":"2018/06/18/网页分析/","text":"CSR和SSR项目对比首先我们带有一个项目分别用SSR的方式和CSR的方式实现，这里选用vue项目。关于vue服务端渲染的知识可以参考官网和作者的demo。找了个项目，chrome开发工具中将网络调整为fast 3G的Performance图分别如下： 客户端渲染 服务端渲染 关于vue的SSR解释SSR 有两个入口文件，client.js 和 server.js， 都包含了应用代码，webpack 通过两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 当服务器接收到了来自客户端的请求之后，会创建一个渲染器 bundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件，并且执行它的代码， 然后发送一个生成好的 html 到浏览器，等到客户端加载了 client bundle 之后，会和服务端生成的DOM 进行 Hydration (判断这个 DOM 和自己即将生成的 DOM 是否相同，如果相同就将客户端的Vue实例挂载到这个 DOM 上， 否则会提示警告)。 有火焰图的那个窗口细心的小盆友会发现有3根线： 绿线代表首次绘制的时间。 蓝线代表 DOMContentLoaded 事件。 红线代表 load 事件 从分析图中我们可以看到：CSR的首次绘制时间大约是550ms, 而SSR的首次绘制时间大约是1070ms,这应该是单页面应用初始仅有一个父标签的原因。这个待完善。CSR肯定是存在阻塞行为的。至于这个TTFB(多长时间才能收到第一个响应的字节) 我们是在本地服务启动，相当于开发环境，也没什么意义。 RAIL模型 Response立即响应用户；在 100 毫秒以内确认用户输入。 Animation设置动画或滚动时，在 10 毫秒以内生成帧。 Idle最大程度增加主线程的空闲时间。 Load持续吸引用户；在 1000 毫秒以内呈现交互内容。 关键渲染路径 分析网站 识别网站的关键资源，画出它的关键渲染路径图。 算出关键渲染路径的三个指标。 关键资源个数 关键资源大小。 关键网络来回数目。 是否可优化？优化后的指标?","comments":true,"tags":[]},{"title":"编码测试","date":"2018-06-05T00:07:02.000Z","path":"2018/06/05/编码测试/","text":"乱码乱码乱码编码测试编码测试编码测试","comments":true,"tags":[]},{"title":"深复制和浅复制","date":"2018-04-15T01:00:31.000Z","path":"2018/04/15/深复制和浅复制/","text":"关于复制也是很常见的问题 关于我们经常写的=赋值，就不把它归为复制，它只是赋值 还有就是常见的数组的方法比如concat、slice都是浅复制 还有ES6里面的Object.assign或…(扩展运算符)实现方式也是浅复制 第二点中举个例子1234567891011// 说明它是浅复制var arr5 = [1, 2, 3, [100, 200, 300]]var arr6 = arr5.slice(0);arr5[3][0]=555console.log(&apos;arr5: &apos;,arr5)console.log(&apos;arr6: &apos;,arr6)结果：arr5: (4) [1, 2, 3, [555, 200, 300]]arr6: (4) [1, 2, 3, [555, 200, 300]] 知乎上有张关于浅复制shallow图还是不错的，就是基本数据变量占存储值，对象类型的存引用 关于第三点展开运算符babel解析的时候，可能是数组的形式也可能是对象的Object.assign1234567891011121314let obj = [1, 2, &#123;a: 1&#125;]let obj2 = [...obj]// babel解析后var obj = [1, 2, &#123; a: 1 &#125;];var obj2 = [].concat(obj);------------let obj3 = &#123;a:1,b:3,d:&#123;d:4&#125;&#125;let obj4 = &#123;c:1, ...obj3&#125;// babel解析后var obj3 = &#123; a: 1, b: 3 &#125;;var obj4 = _extends(&#123; c: 1 &#125;, obj3);var _extends = Object.assign || function (target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target; &#125;; 可以看出当展开对象的时候可以是Object.assign或是循环第二个参数和第二个后面的参数给第一个参数(对象)上扩展属性。上例中对于obj4中通过扩展运算符添加的属性d只是单纯的引用关系。下面手动实现一个浅复制123456789101112var obj = &#123; a: 1, arr:[2, 3]&#125;var shallowObj = shallowObj(obj)function shallowObj (obj) &#123; var res = &#123;&#125;; for (prop in obj) &#123; if(obj.hasOwnProperty(prop)) &#123; res[prop] = obj[prop] &#125; &#125; return res;&#125; 但是这个只能浅复制对象，其实数组类似只是循环方法不同罢了，还有其它数据类型，下面讨论。深复制实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 一个比较简单的深复制实现// 单层嵌套的深复制JSON.stringify()但是，1、它无法实现函数、正则、类的实例、稀疏数组(长度可能大于值得个数)、循环引用等特殊对象的深度克隆2、它会抛弃构造函数constructor，所有构造函数会指向Object3、对象的循环引用会报错// 函数function a() &#123; console.log(111)&#125;// 正则new RegExp(&apos;a&apos;)// 构造函数function animal(color) &#123; this.color = color&#125;var ani = new animal(&apos;red&apos;)var oldObj = &#123; a: a, b: new RegExp(&apos;a&apos;), c: ani, d: new Array(1)&#125;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newObj.a, oldObj.a); // undefined// 无法复制正则对象console.log(newObj.b, oldObj.b); // 构造函数指向错误console.log(newObj.c.constructor, oldObj.c.constructor);// 稀疏数组复制错误console.log(newObj.d, oldObj.d);// 循环引用复制错误const oldObj = &#123;&#125;;oldObj.a = oldObj;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.a, oldObj.a); 实现深复制数组1234567891011121314function deepcopy(arr)&#123; let _deepcopy = [] for (var i = 0, len=arr.length; i &lt; len; i++) &#123; // 不能让它总是执行下面这段话啊，即使是深复制了，一执行有浅复制了 _deepcopy[i] = arr[i] if(arr[i] instanceof Array) &#123; // 直接赋值引用 VS 循环一下返回个新数组,i是索引。 _deepcopy[i] = deepcopy(arr[i]) &#125; &#125;; return _deepcopy&#125; 但是这个只能深复制数组，原理就是对象类型就用新的对象。还有其它数据类型，下面讨论。类型比较全的深复制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const getRegExp = re =&gt; &#123; var flags = &apos;&apos;; if (re.global) flags += &apos;g&apos;; if (re.ignoreCase) flags += &apos;i&apos;; if (re.multiline) flags += &apos;m&apos;; return flags; &#125;;function deepcopy(obj) &#123; let typeString, newobj; if(typeof obj !== &quot;object&quot; &amp;&amp; typeof obj !== &apos;function&apos;) &#123; // 基本数据类型才返回 return obj; &#125; typeString = Object.prototype.toString.call(obj); switch(typeString) &#123; case &apos;[object Array]&apos;: newobj = []; break; case &apos;[object RegExp]&apos;: newobj = new RegExp(obj.source, getRegExp(obj)); break; case &apos;[object Date]&apos;: newobj = new Date(obj); break; default: newobj = &#123;&#125;; // 处理对象原型，这样也行 // proto = Object.getPrototypeOf(parent); // 利用Object.create切断原型链 // child = Object.create(proto); &#125; for (let i in obj) &#123; // 递归 newobj[i] = deepcopy(obj[i]); &#125; return newobj&#125;var arr = [1, &#123;a:1&#125;,2]var copyArr = deepcopy(arr);arr[1][&apos;a&apos;] = 2console.log(&apos;arr: &apos;,arr)console.log(&apos;copyArr: &apos;, copyArr)var reg = new RegExp(/\\w/,&apos;ig&apos;);var copyReg = deepcopy(reg)console.log(&apos;reg: &apos;,reg)console.log(&apos;copyReg: &apos;, copyReg)var d1 = new Date()var copyD1 = deepcopy(d1)console.log(&apos;d1: &apos;,d1)console.log(&apos;copyD1: &apos;, copyD1)var obj = &#123;a:&#123;a1:&#123;a2:1&#125;&#125;,b:1&#125;var copyObj = deepcopy(obj)obj[&apos;a&apos;][&apos;a1&apos;][&apos;a2&apos;]=2console.log(&apos;obj: &apos;,obj)console.log(&apos;copyObj: &apos;, copyObj) 其它数据类型参考loadsh 和 知乎一篇文章 123456789101112131415161718192021222324var argsTag = &apos;[object Arguments]&apos;, arrayTag = &apos;[object Array]&apos;, boolTag = &apos;[object Boolean]&apos;, dateTag = &apos;[object Date]&apos;, errorTag = &apos;[object Error]&apos;, funcTag = &apos;[object Function]&apos;, mapTag = &apos;[object Map]&apos;, numberTag = &apos;[object Number]&apos;, objectTag = &apos;[object Object]&apos;, regexpTag = &apos;[object RegExp]&apos;, setTag = &apos;[object Set]&apos;, stringTag = &apos;[object String]&apos;, weakMapTag = &apos;[object WeakMap]&apos;;var arrayBufferTag = &apos;[object ArrayBuffer]&apos;, float32Tag = &apos;[object Float32Array]&apos;, float64Tag = &apos;[object Float64Array]&apos;, int8Tag = &apos;[object Int8Array]&apos;, int16Tag = &apos;[object Int16Array]&apos;, int32Tag = &apos;[object Int32Array]&apos;, uint8Tag = &apos;[object Uint8Array]&apos;, uint8ClampedTag = &apos;[object Uint8ClampedArray]&apos;, uint16Tag = &apos;[object Uint16Array]&apos;, uint32Tag = &apos;[object Uint32Array]&apos;;","comments":true,"tags":[]},{"title":"常见面试题","date":"2018-04-15T00:20:18.000Z","path":"2018/04/15/常见面试题/","text":"","comments":true,"tags":[]},{"title":"分页","date":"2018-04-15T00:19:52.000Z","path":"2018/04/15/分页/","text":"反正就是想写个分页呢 1.先整个假数据 123let _data = &#123; &quot;images&quot;: [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]&#125; 2.把基本结构和样式写好 1234567891011121314&lt;style type=&quot;text/css&quot;&gt; body&#123; margin:0 auto;&#125; #container&#123; width:1000px; height:200px; overflow:hidden; margin:0 auto;&#125; #container span&#123; display:block; width:172px; height:172px; padding:3px; border:solid 1px #ccc; float:left; margin:10px; display:inline;&#125; #container span img&#123; width:172px; height:172px; border:none; float:left;&#125; #button&#123; width:1000px; height:40px; margin:0 auto; overflow:hidden;&#125; #button span.root&#123; display:block; width:180px; height:40px; overflow:hidden; margin:0 auto;&#125; #button span span&#123; display:block; width:28px; height:28px; overflow:hidden; border:solid 1px #ccc; float:left; margin-left:5px; display:inline; line-height:30px; font-size:13px; color:#555; text-align:center; cursor:pointer;&#125;&lt;/style&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;div id=&quot;button&quot;&gt;&lt;/div&gt; 3.创建分页类，并构思好架构 1234567891011121314151617181920// 分页类function PageContent() &#123; ..... this.bindEvent = function()&#123; ....用于绑定事件 &#125; this.initButton = function()&#123; .... 用于初始化分页按钮 &#125; this.getImg = function() &#123; ...用于获取图片,并对图片做样式包装 &#125; this.initData = function() &#123; ...用于初始化数据 &#125;&#125; 4.实现初始化数据 123456789// 也就是展示第一页的内容this.initData = function() &#123; // 加载图片并包装 this.getImg(_data, 0, this.pagesize) // 获取总页数 this.totalPages = Math.ceil(_data[&apos;images&apos;].length/this.pagesize) // 初始化分页按钮数 this.initButton()&#125; 5.实现获取图片 1234567this.getImg=function(data,_s,_o)&#123; var _html=&quot;&quot;; for(var i=_s;i&lt;_o;i++)&#123; _html+=&quot;&lt;span&gt;&lt;img alt=\\&quot;\\&quot; src=\\&quot;waterfall/&quot;+data[&quot;images&quot;][i]+&quot;.jpg&quot;+&quot;\\&quot;/&gt;&lt;/span&gt;&quot;; &#125; $(&quot;#container&quot;).html(_html);&#125; 6.初始化分页按钮 12345678910// 把一页展示的几个按钮显示出来,为了简单可以一页把所有的按钮都展示-_-!!!this.initButton=function()&#123; var _btn=&quot;&lt;span class=\\&quot;root\\&quot;&gt;&quot;; for(var i=this.s;i&lt;=this.o &amp;&amp; i&lt;this.total;i++)&#123; _btn+=&quot;&lt;span&gt;&quot;+i+&quot;&lt;/span&gt;&quot;; &#125; _btn+=&quot;&lt;/span&gt;&quot;; $(&quot;#button&quot;).html(_btn); this.bindEvent();&#125; 7.绑定事件 1234567891011this.bindEvent=function()&#123; var _self=this; $(&quot;.root span&quot;).click(function()&#123; // 为每个按钮添加点击事件，并且还要刷新按钮样式 _self.s=(parseInt($(this).html())-1)*_self.size; _self.o=_self.s+_self.size; // reloadData加载数据 _self.getImg(data,_self.s,_self.o); &#125;);&#125; 太草率了，以后附上github链接上面写法有问题，就是每次new对象的时候方法之类的重新创建，没做到原型共享12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 无聊花半小时写了个简单版，亲测有效const LoadData = &#123; &quot;images&quot;: [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]&#125;class PageContent &#123; constructor() &#123; this.pageSize = 5; this.totalBtns = 0; this.btnWrapper = document.getElementById(&apos;button&apos;); &#125; bindEvent() &#123; let btns = this.btnWrapper.querySelectorAll(&apos;button&apos;) for (var i = 0; i &lt; btns.length; i++) &#123; (function(i)&#123; btns[i].addEventListener(&apos;click&apos;,function () &#123; this.getImgs(LoadData, i*this.pageSize, (i+1)*this.pageSize) &#125;.bind(this)) &#125;.bind(this))(i) &#125;; &#125; getImgs(data, s, e) &#123; console.log(data, s, e) let wrapper = document.getElementById(&apos;container&apos;); let container = &apos;&apos;; for (var i = s; i &lt; e; i++) &#123; container+=` &lt;span&gt; &lt;img src=&quot;waterfall/$&#123;LoadData[&quot;images&quot;][i]&#125;.jpg&quot;/&gt; &lt;/span&gt; ` &#125;; wrapper.innerHTML = container; &#125; initButtons() &#123; this.totalBtns = Math.ceil(LoadData[&quot;images&quot;].length/this.pageSize); let container = &apos;&apos;; for (var i = 0; i &lt; this.totalBtns; i++) &#123; container+=` &lt;button&gt; $&#123;i+1&#125; &lt;/button&gt; ` &#125;; this.btnWrapper.innerHTML = container; this.bindEvent() &#125; initData () &#123; this.getImgs(LoadData, 0, this.pageSize) this.initButtons() &#125; &#125;var _pc=new PageContent(); _pc.initData();","comments":true,"tags":[]},{"title":"debounce和throttle","date":"2018-04-15T00:15:40.000Z","path":"2018/04/15/debounce和throttle/","text":"这个问题也经常会碰到，于是手动实现试试 debounce(防抖)间隔时间内只能执行一次 把该封装的封装，抽离的抽离123456789101112btn.addEventListener(&apos;click&apos;,debounce())function debounce() &#123; return function() &#123; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; todo() &#125;,500) &#125;&#125;function todo() &#123; console.log(11111)&#125; 再优化一下，回调，传参，绑定作用域123456789101112131415// 这个还是蛮标准的。btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; return function() &#123; let context = this; // btn let args = arguments; // 事件e clearTimeout(this.timer) this.timer = setTimeout(function()&#123; fn.apply(context, args) &#125;,delay) &#125;&#125;function todo(param) &#123; console.log(11111, param)&#125; 目前的情况是间隔时间后才触发，如果我想开始就触发，间隔时间后才能再次触发123456789101112131415161718192021btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; let flag = true; return function() &#123; let context = this; let args = arguments; flag &amp;&amp; fn.apply(context, args) flag = false; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; // 想再间隔时间后再执行，就加上它；感觉也行吧 // fn.apply(context, args) flag = true; &#125;,delay) &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 那如果我有时想立即触发，有时想最后一次点击delay后触发，加个参数呗1234btn.addEventListener(&apos;click&apos;,debounce(todo, 500, [true/false]))function debounce(fn, delay, immediate) &#123; ...&#125; throttle(节流) 在规定时间内，不断触发，就行水龙头的水一样 下面呢就实现间隔时间delay内不断触发，并且在最后一次触发的时候，delay秒后将再次自动触发1234567891011121314151617btn.addEventListener(&apos;click&apos;,throttle(todo, 500))function throttle(fn, delay) &#123; return function() &#123; let context = this; let args = arguments; if (!this.timer) &#123; // 没报错说明没语法错误，不执行说明逻辑没走掉这 this.timer = setTimeout(function()&#123; fn.apply(context, args) this.timer = null; &#125;.bind(this), delay) &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 但是呢，上面那个总是在delay后执行，不能立即执行；下面就用时间戳的形式实现立即执行,前提是初始点击的时候已经是delay后了12345678910111213141516btn.addEventListener(&apos;click&apos;,throttle(todo, 500)) function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; &#125; &#125; function todo(params) &#123; console.log(11111, params) &#125; 假如我想开始立即触发，最后那一次delay后也要执行一次呢12345678910111213141516171819202122btn.addEventListener(&apos;click&apos;,throttle(todo, 1000))function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; else &#123; // 一直清除定时器 clearTimeout(this.timer); this.timer = setTimeout(fn.bind(this, args),delay); &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 适用场景 防抖放在购物车结算时，它只能点击一次； 节流放在购物车加减商品时，还有类似淘宝的搜索框，还有类似的resize,之类的不断触发AjAx的场景 有时防抖和节流会混合试用 看下lodash 关于防抖和节流的实现源码，反正是饶了一大圈，就不详细看了1234567891011121314151617181920212223242526272829303132333435363738394041424344function shouldInvoke(time) &#123; var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we&apos;re at the // trailing edge, the system time has gone backwards and we&apos;re treating // it as the trailing edge, or we&apos;ve hit the ```maxWait``` limit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));&#125;// 这个是判断是否解析时间的函数，应该是：1、初始点击要解析；2、大于间隔时间要解析。。。/** * A simple wrapper around the global [```setTimeout```](https://mdn.io/setTimeout). * * @private * @param &#123;Function&#125; func The function to delay. * @param &#123;number&#125; wait The number of milliseconds to delay invocation. * @returns &#123;number|Object&#125; Returns the timer id or timeout object. */ var setTimeout = ctxSetTimeout || function(func, wait) &#123; return root.setTimeout(func, wait); &#125;; // 对setTimeout进行封装，不知其意 function leadingEdge(time) &#123; // Reset any ```maxWait``` timer. lastInvokeTime = time; // Start the timer for the trailing edge. timerId = setTimeout(timerExpired, wait); // Invoke the leading edge. return leading ? invokeFunc(time) : result; &#125;// 中途调用了leadingEdge这个应该是加载方法，并且第一次调用时调用了invokeFunc(time)function invokeFunc(time) &#123; var args = lastArgs, thisArg = lastThis; lastArgs = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; &#125;// 而这个invokeFunc里面就调用了result = func.apply(thisArg, args);// func就是要执行的回调。","comments":true,"tags":[]},{"title":"��дvue��vuex","date":"2018-04-15T00:14:38.000Z","path":"2018/04/15/手写vue和vuex/","text":"�ο�����","comments":true,"tags":[]},{"title":"手写react和redux","date":"2018-04-15T00:14:38.000Z","path":"2018/04/15/手写react和redux/","text":"简单实现一个react，点赞组件。具体参考react小书，或my github 1.为了结构复用先构建类 123456class LikeButton &#123; render() &#123; .... &#125;&#125;// 最终的目的是new LikeButton()就可以在dom上创建实例 2.如何实现创建的实例上有绑定的事件 1234567891011121314class LikeButton &#123; constructor () &#123; .....this.state &#125; changeLikeText () &#123; ....操作state和dom &#125; render () &#123; ...字符串转换成dom,给dom绑定事件，最后实例化时通过dom方法渲染到页面 return this.el &#125;&#125; 3.添加setState方法，每次调用setState就调用render方法 12345setState (state) &#123; this.state = state this.el = this.render()&#125;// 这里面有坑 4.抽离公共组件 12345678910111213141516171819202122232425262728class Component &#123; setState (state) &#123; &#125; _renderDOM () &#123; &#125; &#125; class LikeButton extends Component &#123; constructor (props) &#123; super(props) &#125; onClick () &#123; &#125; render () &#123; return ` ... ` &#125; &#125; // 把组件的 DOM 元素插入页面，并且在 setState 的时候更新页面 mount(new LikeButton(), wrapper) 上面还涉及到柯里化但是看过很多博客都对柯里化做了解释总感觉有种牵强附会的感觉，强扭的瓜不甜。其实说白了，柯里化不过就是“用空间换时间”三个优点 参数复用 提前执行 延迟执行 具体代码详见github参考链接","comments":true,"tags":[]},{"title":"jQuery源码分析","date":"2018-04-15T00:14:00.000Z","path":"2018/04/15/jQuery源码分析/","text":"","comments":true,"tags":[]},{"title":"diary18-2-13","date":"2018-02-13T13:53:46.000Z","path":"2018/02/13/diary18-2-13/","text":"快过年了今年弟弟妹妹不知为什么会想出这样的花招-卖波波球。 往年最多集体出去买一大包辣条，然后躲着小妹妹一起把辣条吃掉。今天(2018/2/18)卖了将近30个，城东最高卖25元/个，城西人民公园卖10元/个。成本价就不说了。确实是一段很棒的经历，杨丹表现得特别棒！ 我觉得要是在我的高中或大学，甚至更小点初中时刻等，去”卖气球”会有更好的体会。 自己去带动一个活动才是最好的体验，就是当带头第一人。","comments":true,"tags":[]},{"title":"vue动画","date":"2017-06-19T14:03:32.000Z","path":"2017/06/19/vue动画/","text":"","comments":true,"tags":[]},{"title":"Node.js","date":"2017-03-18T14:56:18.000Z","path":"2017/03/18/Node-js/","text":"第一步先把下面这个用5分钟看完-_-!! 12http://es6.ruanyifeng.com/ 第二步写demodemo1 实现登录注册demo2 读取歌词 1234567891011121314151617181920212223242526272829303132333435//读取歌词文件//使用cmd进入node脚本模式const fs=require(\"fs\");const path = require(\"path\");let _path=path.join(__dirname,'./xxx.lrc')fs.stat(_path,(err,stats)=&gt;&#123; if(err) throw err; //console.log(stats) fs.readFile(_path,(err,content)=&gt;&#123; if(err) throw err; //默认的就是utf-8,所以不用写。 //console.log(content.toString('utf-8')) let lines = content.toString('utf-8').split('\\n'); //console.log(lines); let rg=/\\[(\\d&#123;2&#125;)\\:(\\d&#123;2&#125;)\\.(\\d&#123;2&#125;)\\](.+)/; lines.forEach((line,index)=&gt;&#123; //console.log(rg.test(line)) let matchs =rg.exec(line); if(matchs)&#123; //console.log(matchs) let h = matchs[1]; let m = matchs[2]; let _s = matchs[3]; let w = matchs[4]; setTimeout(()=&gt;&#123; console.log(w); //定时器的参数是毫秒 &#125;,h*60*1000+m*1000+_s*10) &#125; &#125;) &#125;)&#125;);","comments":true,"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"xmapp","slug":"xmapp","permalink":"http://yoursite.com/tags/xmapp/"}]},{"title":"canvas","date":"2017-03-16T09:32:58.000Z","path":"2017/03/16/canvas/","text":"这篇主要是canvas最终要达到的效果是下面这个样子： demo1 弹弹球，碰撞就变色 这个解决最长时间的问题是： 1234ctx.beginPath();drawBall(ballX,ballY);ctx.closePath(); 缺了2行代码，导致运动完的路径一直都在。 demo2 时钟 demo3 画板 demo4 运动 这个的主要问题是： canvas的旋转是从上一次旋转开始计算的和css3不一样，除非加上save()和restore()方法； clearRect的时候还待translate(0,0)，这个问题。。反正我的浏览器待这样弄。 一个画板要画多个连续运动图像怎么办？ demo5 canvas拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;canvas id=\"can\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var can=document.getElementById(\"can\"); var ctx=can.getContext(\"2d\"); //移动时要覆盖以前的坐标，所以先配置 var points = [ &#123;x:100,y:100,r:50,startA:0,endA:2*Math.PI&#125;, &#123;x:200,y:200,r:50,startA:0,endA:2*Math.PI&#125; ] function drawArc()&#123; for (var i = 0; i &lt; points.length; i++) &#123; ctx.beginPath(); ctx.arc(points[i].x,points[i].y,points[i].r,points[i].startA,points[i].endA); ctx.fill(); &#125; &#125; drawArc(); //移动图形 can.onmousedown = function(e)&#123; var e = e || window.event; document.onmousemove=function(e)&#123; var e = e || window.event; ctx.clearRect(0,0,500,500); var x = e.layerX; var y = e.layerY; //重新绘制 for (var i = points.length - 1; i &gt;= 0; i--) &#123; var event = new addEvent(ctx,\"arc\",points[i].x+\",\"+points[i].y+\",\"+points[i].r+\",\"+points[i].startA+\",\"+points[i].endA,function()&#123; ctx.beginPath(); console.log(points[i].r+\"我是第53行\") var [callbackR,callbackX,callbackY] = [points[i].r,points[i].x,points[i].y] ctx.arc(x,y,callbackR,callbackX,callbackY); ctx.fill(); points[i].x = x; points[i].y = y; &#125;) event.isPointInPathCallback(x,y); &#125; event.isPointInPathCallback(x,y); &#125; document.onmouseup=function()&#123; document.onmousemove = null; document.onmouseup = null; &#125; &#125; /* //未点击之前先绘制，点击后再绘制；确保点击后是最新绘制的 ctx.beginPath(); ctx.arc(100,100,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(200,200,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.rect(400,200,50,50); ctx.fill(); //点击对应的图片，弹出对应的值 // can.onclick = function (e)&#123; // var e = e || window.event; // var x = e.layerX; // var y = e.layerY; // //和上面一个意思 // // var xx = e.offsetX; // // var yy = e.offsetY; // //如果把2*Math.PI当成字符串传进去是不行的。 // var event1 = new addEvent(ctx,\"arc\",\"100,100,50,0,\"+2*Math.PI,function()&#123; // alert(1); // &#125;) // event1.isPointInPathCallback(x,y); // var event2 = new addEvent(ctx,\"arc\",\"200,200,50,0,\"+2*Math.PI,function()&#123; // alert(2); // &#125;) // event2.isPointInPathCallback(x,y); // var event3 = new addEvent(ctx,\"rect\",\"400,200,50,50\",function()&#123; // alert(3); // &#125;) // event3.isPointInPathCallback(x,y); // &#125; */ //封装成一个util function addEvent (obj,type,data,callback)&#123; this.obj = obj; this.type = type; this.data = data; this.callback = callback; this.reDraw(); &#125; addEvent.prototype = &#123; reDraw:function()&#123; if(this.type == \"arc\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.arc(arr[0],arr[1],arr[2],arr[3],arr[4]); this.obj.fill(); &#125;else if(this.type == \"rect\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.rect(arr[0],arr[1],arr[2],arr[3]); this.obj.fill(); &#125; &#125;, isPointInPathCallback:function(x,y)&#123; if(this.obj.isPointInPath(x,y))&#123; this.callback(); &#125; &#125; &#125;;&lt;/script&gt; 存在的问题： 53行能打印出来，但是也报错Uncaught TypeError: Cannot read property ‘r’ of undefined。 点击图形起始点和图形的圆心是有距离的，后期拖拽时直接将拖拽的相对距离赋值给了圆心，导致误差。 还是有点懵。每次new 相同的event? demo6 canvas实现3d效果 很棒的canvas3次贝塞尔曲线算法地图 canvas库 参考链接：https://www.evget.com/article/2014/4/9/20799.html 报表统计 项目实现一个绘图工具 git地址：","comments":true,"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"开源项目","date":"2017-03-16T02:11:23.000Z","path":"2017/03/16/开源项目/","text":"以下是开源项目，感兴趣的同学可以一块加入。 React12https://github.com/18706789739/cloudMusic.git Angular12http://eisneim.github.io/angular-ui-awesome/","comments":true,"tags":[{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"搭载git服务器","date":"2017-03-05T06:55:49.000Z","path":"2017/03/05/搭载git服务器/","text":"要是有人再问我会不会搭服务器，我就问是什么服务器？tomcat、weblogic、solr还是其它?下面介绍的是在ubuntu-16.04.2下搭载git服务器，之所以选择这个版本是因为要运行nodeJs。 Ubuntu下搭载git服务器先给几个参考链接，我也是参考这里的。 链接一 链接二 链接三 链接四 首先你待有个Ubuntu系统 这里推荐用u盘安装。开始没用u盘安装，好久都没有安装成功。最后用u盘也就半个小时解决。 调出终端输入命令123sudo apt-get install gitsudo apt-get install openssh-server 可以通过下面的命令查看sshd相关的进程信息 12ps -ef|grep \"sshd\" 如果你能看到一些sshd相关的进程信息，则说明你已经有这个服务了。 然后，为自己配置身份信息，这样多个人提交代码的时候，就可以方便的查看是谁提交的。 123git config --global user.name \"yourname\" git config --global user.email \"your@email.com\" 再然后配置一个专门的git用户并设置密码，专门对代码进行管理。 123sudo useradd -m git(yours) sudo passwd git(change to yours) 然后，在新建的git用户主目录下创建一个文件夹作为git的仓库，并为这个仓库配备最基本的安防——权限控制 1234sudo mkdir /home/git/repositories # 最好使用repositories作为文件夹名称，这样可以简化后面的操作 sudo chown git:git /home/git/repositories sudo chmod 755 /home/git/repositories 输入一下命令基本就OK!!12345su git //切换到git用户,你可以发现路径前面变了mkdir helloworld //新建一个目录（仓库）cd helloworld git --bare init //初始化一个空的仓库 然后找一台机器测试一下 12git clone git@192.168.0.123:/home/git/repositories/helloworld 再加上下面这段命令，方便你可以push和pull 然后就成功了！ 再找第三台机器测试，还是成功的。 但是服务器里我什么也找不到，我开始以为失败了。 但是，还有 不足之处，比如别的文章提到的: 解决每个步骤都需要输入git用户的密码。 出于安全考虑，创建的git用户不允许登录shell。 下一步可以试试集群。","comments":true,"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"Flux架构","date":"2017-03-04T14:19:53.000Z","path":"2017/03/04/Flux架构/","text":"最近公司做的项目据我观察就是flux架构，即使不是也是Flux存在多种实现之一，比如Redux之类的。 Flux架构先来个阮老师(好多人喜欢这么称呼)链接， 参考链接 Browse blog 基本概念 View：视图层； Action：动作层，视图层发出的消息(比如click)； Dispather: 派发器，用来接收action，执行回调函数； Store: 数据层，用来存放用用状态，一旦发生变动，就提醒View要更新页面； Flux特点 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 上面过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。 然后就是看阮老师的demo,我是看的差不多了。 想用调试工具调一下，先是用chrome react 插件,搞了好久，插件闪来闪去，没法弄。git上的源码又不知怎么变成crc文件。然后只能用react-hot-loader链接也可以试试react-transform 在webpack配置完react-hot-loader后又调不好程序了-_-!!!。不知道了，应该可以找到。 Redux2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 参考链接 整个过程是： 用户发出 Action，store.dispatch(action); Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State。 State 一旦有变化，Store 就会调用监听函数。 listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 然后，看demo。 还有异步操作：Action 发出以后，过一段时间再执行 Reducer，这就是异步。这个没细看，感觉像面向切面的编程(AOP)。 公司项目分析项目src的目录介绍 其实还是不大懂！！ 关于bind找了些资料总结一下：当需要传参，为了确保处理函数中的this时刻指向这个组件，就需要bind。bind会可以复制出一个函数，改变函数指针，给函数传参。 比如下面这个demo1234567891011121314151617181920212223242526272829var Hello=React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'', sex:'', age:'', tel:'', address:'' &#125; &#125;, changeValue:function(type,e)&#123; var that=this; var obj=&#123;&#125; obj[type]=e.target.value; that.setState(obj) &#125;, render:function()&#123; return ( &lt;div&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'name')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.name&#125;&lt;br/&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'sex')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.sex&#125;&lt;br/&gt; &lt;input onChange=&#123;this.ageChange&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.age&#125;&lt;br/&gt; &lt;/div&gt; ) &#125;&#125;) ReactDOM.render(&lt;Hello/&gt;,document.getElementById(\"app\")); 项目中初始化时bind 123456789101112131415161718192021class InvitationJoin extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; this.join = this.join.bind(this); &#125; join() &#123;&#125; render() &#123; return &lt;div className=&#123;style.box&#125;&gt; ....... &lt;div className=&#123;style.btnBox&#125;&gt; &lt;div className=&#123;button.normal&#125; onClick=&#123;this.join&#125;&gt;&#123;'加入'&#125;&lt;/div&gt; &lt;/div&gt; ........ &lt;/div&gt; &#125;&#125;export default InvitationJoin; 使用箭头函数从而避免bind,剑锋说效率低。 12暂时没找到，有时间再从项目中找。 webpack打包，不用考虑js的兼容。组件定义对象。123456xxxx(()=&gt;&#123;&#125;)&#123; return&#123; &#125;&#125; 实在没时间写了，改天再写！！！！！！","comments":true,"tags":[{"name":"前端架构","slug":"前端架构","permalink":"http://yoursite.com/tags/前端架构/"}]},{"title":"框架对比","date":"2017-03-04T10:59:30.000Z","path":"2017/03/04/框架对比/","text":"关于框架的对比网上资料很多，这里仅供参考 React的特点和优势 虚拟dom，减少不必要的更新，render Virtual DOM + diff + 必要的 DOM 更新。 jsx语法，结构清晰易于编写，必须是闭合标签。 单向数据流，只要服务端数据发生变动，前端数据也变动，开发者只关注实现业务就行了。 组件化开发，可组合、可重用、可维护、可测试。 vue没用过，听说vue是结合angular和react国产框架，是最简单的框架，这话不是我说的。还有人说，微信小程序内部是react native开发的，这话也不是我说的。 React和Vue对比 React和Vue的适用范围无疑是很相似的：同样是基于组件的轻量级框架，同样专注于用户界面的视图层。同样可以用在简单的项目中，也同样可以使用全家桶扩展为复杂的应用程序。 React是一个轻量级的框架，专注试图层，适用于简单个大型项目，并且可以从webApp像原生过度，reactNative。 如果喜欢使用模版用vue,因为react是借助jsx在js中创建DOM. 如果你喜欢简单，用vue,因为不需要转译，react重度依赖jsx和es6新特性，比如class。 竟可能小和快使用vue,渲染快，引入的文件小。 大型应用程序选择react,js模版可测试性和维护性很高。vue模版很难测试，维护，分解。 适用于Web端，和原生App的框架，用react。React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 如果你学过React.js，很快就能上手React Native。 更大的生态系统选择react。 如果你已经用其中一个用得很爽了，那就不用变了。 参考链接 Browse blog 附录：曾经问剑锋为什么选择react时，我做了点总结： react是偏向功能性的，轻量级的，单页面应用，组件开发，并且易于向原生开发过度(react native)。 他给我的印象就是，老是问我能用图画出来吗？然后还有以前的话，“尝试是错误的，想好再做”、“把快捷键都记住”、“要动脑，总结”，还有以前的话“把业务编号都记住”，连环踢T_T； Angular1 适用于SPA–路由机制;CRUD应用,如后台管理界面。 不适用,游戏、图形界面编辑器，这种频繁DOM操作也很复杂的应用。 Angular1的特性 MVC（模型 - 视图 - 控制器）或MVVM （模型 - 视图 - 视图模型）模式来组织源代码。 模块系统,依赖注入,可嵌入、注入和测试。 指令系统,可以创建可重用的自定义组件与指令的API。 HTML 模板,允许设计人员和开发人员同时工作。 数据双向绑定,当模型发生变化时，视图会自动更新，反之亦然。 以前公司的框架 以前公司的前台框架是使用jQuery UI部件库（Widget Factory）来创建插件，并且这也是最常见的一种方式，说来自己也研究好几年了,然并卵。 1234567891011121314$.widget( \"custom.progressbar\", &#123; // Default options. options: &#123; value: 0 &#125;, _create: function() &#123; var progress = this.options.value + \"%\"; this.element .addClass( \"progressbar\" ) .text( progress ); &#125;&#125;); 上面这段代码是从菜鸟学院粘贴过来的。 最后呢，曾经有人问我用angular1做项目，以后会不会出现什么问题？我说:”如果只是一个花瓶的话，用什么都没问题。”，最后再套用一下别人的话如果你已经用其中一个用得很爽了，那就不用变了。","comments":true,"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"}]},{"title":"React开发","date":"2017-03-04T04:20:08.000Z","path":"2017/03/04/React开发/","text":"最近公司用react开发项目，所以学习一下。 react组件react组件的生命周期关于react生命周期，不同的地方写得不一样但是，意思一样，我就挑一个写吧。 react设计组件的时候，把组件看成是有生命的物体，让它具有生命周期，共有三大周期。 创建期 存在期 销毁期 1、创建期创建期分为5个阶段： getDefaultProps :获取默认属性，还没创建出来，看不见内部的对象属性，只运行一次。 getInitialState :获取默认状态,数据已创建，可以访问实例化对象。 componentWillMount :组件将要被创建,组件的虚拟dom，将要渲染输出虚拟dom。 render :组件渲染输出虚拟dom,一定要通过return返回虚拟dom树。 componentDidMount :组件已经构建完成,组件已创建完成虚拟dom,可以操作真实的dom。 -_-! 以后就直接用画图工具画了，太丑陋，还待上传。 2、存在期存在期分为5个阶段： componentWillReceiveProps :组件将要接受新的属性。 shouldComponentUpdate :组件是否应该更新，必须返回true或false。 componentWillUpdate :组件将要更新。 render :组件更新，输出虚拟dom。 componentDidUpdate :组件已经更新完成。 3、销毁期销毁期就1个阶段： componentWillUnmount :组件即将被销毁。 下面是一个demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;React 实例&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var MessageBox = React.createClass(&#123; getInitialState:function()&#123; console.log('getInitialState'); return&#123; count:0, &#125; &#125;, getDefaultProps:function()&#123; console.log(\"getDefaultProps\"); &#125;, componentWillMount:function()&#123; console.log(\"componentWillMount\"); var self = this; this.timer = setInterval(function()&#123; self.setState(&#123; count:self.state.count + 1, &#125;) &#125;,1000); &#125;, componentDidMount:function()&#123; console.log(\"componentDidMount\"); &#125;, componentWillReceiveProps:function(nextProps)&#123; console.log(\"component will receive props\"); &#125;, shouldComponentUpdate:function(newProps,nextState)&#123; console.log(\"shouldComponentUpdate\"); if(nextState.count&gt;10)&#123; console.log(\"不要老是更新我！--优化作用\"); return false; &#125; return true; &#125;, componentWillUpdate:function(nextProps,nextState)&#123; console.log(\"component will update\"); &#125;, componentDidUpdate:function(prepProps,prepState)&#123; console.log(\"component did update\"); if(this.state.count&gt;3)&#123; clearInterval(this.timer); &#125; &#125;, componentWillUnmount:function()&#123; console.log(\"componet will unmount\"); alert(\"啊不要啊！！！\"); clearInterval(this.timer); &#125;, kill:function()&#123; ReactDOM.unmountComponentAtNode(document.getElementById('app')); &#125;, doUpdate:function()&#123; this.setState(&#123; count:this.state.count +1, &#125;); &#125;, render:function()&#123; console.log(\"渲染\"); return( &lt;div&gt; &lt;h1&gt;计数:&#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.kill&#125;&gt;卸载这个组件&lt;/button&gt; &lt;button onClick=&#123;this.doUpdate&#125;&gt;手动更新&lt;/button&gt; &lt;Submessage count=&#123;this.state.count&#125;/&gt; &lt;/div&gt; ) &#125; &#125;); var Submessage = React.createClass(&#123; componentWillReceiveProps:function(nextProp)&#123; console.log(\"子组件将要获取prop\"); &#125;, shouldComponentUpdate:function(nextProp,nextState)&#123; if(nextProp.count&gt;6) return false; return true; &#125;, render:function()&#123; return( &lt;h3&gt;当前计数是:&#123;this.props.count&#125;&lt;/h3&gt; ) &#125; &#125;); var messageBox = ReactDOM.render(&lt;MessageBox/&gt;,document.getElementById('app')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：","comments":true,"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"js理解","date":"2017-03-03T10:08:31.000Z","path":"2017/03/03/js理解/","text":"js中的面向对象面向对象的三大特性：封装、继承、多态。这里只说封装和继承。js面向对象的几种方式这个不同的人有不同的总结，仅供参考！ 1、工厂模式123456789101112131415function Person(name)&#123; // 原料 var obj=new Object(); // 加工 obj.name=name; obj.getName=function() &#123; console.log(this.name) &#125; //出厂 return obj;&#125;var person = Person(\"zhang\")person.getName(); 结果为1zhang 这种方式的缺点是：每一个实例都创建一个新的对象,浪费空间，并且创建实例时没有用关键字new； 2、构造函数模式123456789101112131415function Person(opt)&#123; this.config=&#123; name:\"zhang\" &#125; for(var i in opt)&#123; this.config[i]=opt[i] &#125; this.getName=function()&#123; console.log(this.config.name) &#125;&#125;var person = new Person(&#123;name:\"lisi\"&#125;)person.getName(); 结果为1lisi 这种方式的优势是：对象指向性强，new出的就是一个person示例； 3、混合模式123456789101112function Person(name)&#123; this.name = name;&#125;Person.prototype=&#123; getName:function()&#123; console.log(this.name) &#125;&#125;var person = new Person(\"lisi\")person.getName(); 结果为1lisi 这种方式的优势是：属性独立，并且可以根据原型链实现方法共享； js的继承首先介绍js中的原型链首先来一段代码 12345function funcA() &#123; this.show = function() &#123;&#125;&#125;console.log(funcA.prototype); 通过观察可以画出这样的图形 注：此图是盗用别人的图片，具体参考下面链接，此博客已被吾收录。 参考链接 Browse blog 总之，最后形成一张这样的图： 是不是感觉惊呆了！！！！！！如果让我画的话，比如一个b继承a的图，是这样：b是函数funcB()的实例，a是函数funA()的实例对象。 下面是js继承参考链接 Browse blog 1、使用原型链实现继承1234567891011121314151617function SuperClass()&#123; this.name = \"zhang\";&#125;SuperClass.prototype.say=function()&#123; console.log(this.name);&#125;function SubClass()&#123; this.name = \"haha\";&#125;SubClass.prototype.say=function()&#123; console.log(this.name);&#125;SubClass.prototype=new SuperClass();var sub = new SubClass();sub.say(); 结果是： 12haha 但是： 1234567891011121314151617function SuperClass()&#123; this.name = \"women\"; this.bra = [\"a\",\"b\"];&#125;function SubClass()&#123; this.subname = \"your sister\";&#125;SubClass.prototype = new SuperClass();var sub1 = new SubClass();sub1.name = \"man\";sub1.bra.push(\"c\");console.log(sub1.name);//manconsole.log(sub1.bra);//[\"a\",\"b\",\"c\"]var sub2 = new SubClass();console.log(sub1.name);//womanconsole.log(sub2.bra);//[\"a\",\"b\",\"c\"] 缺点显而易见：所有继承自SuperClass的实例都会受到影响，引用类型共享。 2、经典继承1234567891011121314function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this);&#125; var sub1 = new SubClass();console.log(sub1.sayWhat());//TypeError: undefined is not a function 但是： 1、如果在构造函数中有方法的定义，那么对于每一个实例都存在一份单独的Function引用，我们的目的其实是想共用这个方法。（其实不太懂）2、超类型原型中定义的方法，在子类型实例中是无法调用到。 3、组合式继承123456789101112131415function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this); //第二次调用SuperClass&#125;SubClass.prototype = new SuperClass(); //第一次调用SuperClassvar sub1 = new SubClass();console.log(sub1.sayWhat());//hello 这个常用，寄生组合式继承就不写了，想了解的看原文。据说有寄生组合式继承的插件。 但是：这个模式调用了两次超类型的构造函数。 下面是我自己项目中的一段代码：MstBall继承了Missile 1234567891011121314151617181920212223/**组合式继承实现MasterBall这个类*/function MstBall(option)&#123; //经典继承 Missile.call(this,option);&#125;//原型继承MstBall.prototype = new Missile();//重写create方法MstBall.prototype._create = function() &#123; var mstBall = $(\"&lt;div class='missile \"+this.config.className+\"'&gt;\"); mstBall.css(&#123; width:this.config.width, height:this.config.height, transform:\"translate(\"+this.config.pos.x+\"px,\"+this.config.pos.y+\"px)\" &#125;); this.missile=mstBall; //console.log(this.missile) GameConfig.gameBox.append(this.missile); return this;&#125;; ES6中类和类的继承的写法123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 等同于parent.constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 等同于parent.toString() &#125;&#125; 参考链接 Browse blog参考链接 Browse blog ES6继承感觉像java中的的继承，规范了继承的操作。 最后，写点剑锋的东西，虽然最后被拉黑T_T 原型链作用域链demo1123456789//对name的访问, 哪种效率更高var name = '张三';function hello() &#123; console.log(name); console.log(window.name); console.log(this.name);&#125;hello(); 分析：1234567891011121314var name = '张三'; var start = new Date().getTime(); for(var i=0;i&lt;100000;i++)&#123; hello() &#125; var end = new Date().getTime(); alert(end-start); function hello()&#123; //console.log(name)//2234,2240,2372,2272---2279.5 //console.log(window.name);//2292,2439,2299,2437---2366.75 //console.log(this.name);//2302,2324,2272,2363--2315.25 &#125; 我就这么测了一下效率从高到低是name,this.name,window.name。。。和我分析的不一样啊！！不过测也不准，优势时间多有时时间低。 原型链特点 支持了面向对象开发模式 显示原型指针prototype, 任何函数都有(除了特殊Empty函数) 隐式原型指针__proto__, 任何对象都有(除了null, undefined, NaN) 特殊空函数只有__proto__ Object的原型对象的__proto__指向null 12345678Function instanceof Object //任何对象都是Object的实例Object instanceof Function //任何函数都是Function的实例Date.__proto__ === Function.prototypeFunction.__proto__ === Function.prototype","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"学习md语法 ---爱不释手","date":"2017-03-03T08:51:40.000Z","path":"2017/03/03/md语法/","text":"这篇文章就测试下md的语法把！ 这是大标题这是小标题1$ 这里面放代码 这里放超链接: Writing 下面是插入图片 这里也是图片 1![不支持](/assets/blogImg/touxiang.png&#123;100x100&#125; \"测试图片并且定义宽高\") 1![不支持](/assets/blogImg/touxiang.png =100x100 \"测试图片并且定义宽高\") 1$ http://wowubuntu.com/markdown/basic.html 什么也不说了，爽爆了，感觉比博客园之类的写博客好多了在博客园写博客想要好的样式，还必须用第三方工具，我记得是writerlive之类的；现在感觉太棒了！！下面这幅图是用截图工具处理的。。。。 这里是列表 这里是列表 1基本可以应付了。 步骤123hexo new title //默认问post布局，title改为你的文章名似乎还待加一句 $ hexo generate //生成静态文件hexo deploy 列表： 。。。。 。。。","comments":true,"tags":[]},{"title":"用hexo制作博客","date":"2017-03-02T14:32:55.508Z","path":"2017/03/02/hexo博客/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]