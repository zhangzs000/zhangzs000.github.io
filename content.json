[{"title":"框架对比","date":"2017-03-04T10:59:30.000Z","path":"2017/03/04/框架对比/","text":"关于框架的对比网上资料很多，这里仅供参考 React的特点和优势 虚拟dom，减少不必要的更新，render Virtual DOM + diff + 必要的 DOM 更新。 jsx语法，结构清晰易于编写，必须是闭合标签。 单向数据流，只要服务端数据发生变动，前端数据也变动，开发者只关注实现业务就行了。 组件化开发，可组合、可重用、可维护、可测试。 vue没用过，听说vue是结合angular和react国产框架，是最简单的框架，这话不是我说的。还有人说，微信小程序内部是react native开发的，这话也不是我说的。 React和Vue对比 React和Vue的适用范围无疑是很相似的：同样是基于组件的轻量级框架，同样专注于用户界面的视图层。同样可以用在简单的项目中，也同样可以使用全家桶扩展为复杂的应用程序。 React是一个轻量级的框架，专注试图层，适用于简单个大型项目，并且可以从webApp像原生过度，reactNative。 如果喜欢使用模版用vue,因为react是借助jsx在js中创建DOM. 如果你喜欢简单，用vue,因为不需要转译，react重度依赖jsx和es6新特性，比如class。 竟可能小和快使用vue,渲染快，引入的文件小。 大型应用程序选择react,js模版可测试性和维护性很高。vue模版很难测试，维护，分解。 适用于Web端，和原生App的框架，用react。React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 如果你学过React.js，很快就能上手React Native。 更大的生态系统选择react。 如果你已经用其中一个用得很爽了，那就不用变了。 参考链接 Browse blog Angular1 适用于SPA–路由机制;CRUD应用,如后台管理界面。 不适用,游戏、图形界面编辑器，这种频繁DOM操作也很复杂的应用。 Angular1的特性 MVC（模型 - 视图 - 控制器）或MVVM （模型 - 视图 - 视图模型）模式来组织源代码。 模块系统,依赖注入,可嵌入、注入和测试。 指令系统,可以创建可重用的自定义组件与指令的API。 HTML 模板, 数据双向绑定,当模型发生变化时，视图会自动更新，反之亦然。","tags":[]},{"title":"React开发","date":"2017-03-04T04:20:08.000Z","path":"2017/03/04/React开发/","text":"最近公司用react开发项目，所以学习一下。 react组件react组件的生命周期关于react生命周期，不同的地方写得不一样但是，意思一样，我就挑一个写吧。 react设计组件的时候，把组件看成是有生命的物体，让它具有生命周期，共有三大周期。 创建期 存在期 销毁期 1、创建期创建期分为5个阶段： getDefaultProps :获取默认属性，还没创建出来，看不见内部的对象属性，只运行一次。 getInitialState :获取默认状态,数据已创建，可以访问实例化对象。 componentWillMount :组件将要被创建,组件的虚拟dom，将要渲染输出虚拟dom。 render :组件渲染输出虚拟dom,一定要通过return返回虚拟dom树。 componentDidMount :组件已经构建完成,组件已创建完成虚拟dom,可以操作真实的dom。 -_-! 以后就直接用画图工具画了，太丑陋，还待上传。 2、存在期存在期分为5个阶段： componentWillReceiveProps :组件将要接受新的属性。 shouldComponentUpdate :组件是否应该更新，必须返回true或false。 componentWillUpdate :组件将要更新。 render :组件更新，输出虚拟dom。 componentDidUpdate :组件已经更新完成。 3、销毁期销毁期就1个阶段： componentWillUnmount :组件即将被销毁。 下面是一个demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;React 实例&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var MessageBox = React.createClass(&#123; getInitialState:function()&#123; console.log('getInitialState'); return&#123; count:0, &#125; &#125;, getDefaultProps:function()&#123; console.log(\"getDefaultProps\"); &#125;, componentWillMount:function()&#123; console.log(\"componentWillMount\"); var self = this; this.timer = setInterval(function()&#123; self.setState(&#123; count:self.state.count + 1, &#125;) &#125;,1000); &#125;, componentDidMount:function()&#123; console.log(\"componentDidMount\"); &#125;, componentWillReceiveProps:function(nextProps)&#123; console.log(\"component will receive props\"); &#125;, shouldComponentUpdate:function(newProps,nextState)&#123; console.log(\"shouldComponentUpdate\"); if(nextState.count&gt;10)&#123; console.log(\"不要老是更新我！--优化作用\"); return false; &#125; return true; &#125;, componentWillUpdate:function(nextProps,nextState)&#123; console.log(\"component will update\"); &#125;, componentDidUpdate:function(prepProps,prepState)&#123; console.log(\"component did update\"); if(this.state.count&gt;3)&#123; clearInterval(this.timer); &#125; &#125;, componentWillUnmount:function()&#123; console.log(\"componet will unmount\"); alert(\"啊不要啊！！！\"); clearInterval(this.timer); &#125;, kill:function()&#123; ReactDOM.unmountComponentAtNode(document.getElementById('app')); &#125;, doUpdate:function()&#123; this.setState(&#123; count:this.state.count +1, &#125;); &#125;, render:function()&#123; console.log(\"渲染\"); return( &lt;div&gt; &lt;h1&gt;计数:&#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.kill&#125;&gt;卸载这个组件&lt;/button&gt; &lt;button onClick=&#123;this.doUpdate&#125;&gt;手动更新&lt;/button&gt; &lt;Submessage count=&#123;this.state.count&#125;/&gt; &lt;/div&gt; ) &#125; &#125;); var Submessage = React.createClass(&#123; componentWillReceiveProps:function(nextProp)&#123; console.log(\"子组件将要获取prop\"); &#125;, shouldComponentUpdate:function(nextProp,nextState)&#123; if(nextProp.count&gt;6) return false; return true; &#125;, render:function()&#123; return( &lt;h3&gt;当前计数是:&#123;this.props.count&#125;&lt;/h3&gt; ) &#125; &#125;); var messageBox = ReactDOM.render(&lt;MessageBox/&gt;,document.getElementById('app')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：","tags":[]},{"title":"js理解","date":"2017-03-03T10:08:31.000Z","path":"2017/03/03/js理解/","text":"js中的面向对象面向对象的三大特性：封装、继承、多态。这里只说封装和继承。js面向对象的几种方式这个不同的人有不同的总结，仅供参考！ 1、工厂模式123456789101112131415function Person(name)&#123; // 原料 var obj=new Object(); // 加工 obj.name=name; obj.getName=function() &#123; console.log(this.name) &#125; //出厂 return obj;&#125;var person = Person(\"zhang\")person.getName(); 结果为1zhang 这种方式的缺点是：每一个实例都创建一个新的对象,浪费空间，并且创建实例时没有用关键字new； 2、构造函数模式123456789101112131415function Person(opt)&#123; this.config=&#123; name:\"zhang\" &#125; for(var i in opt)&#123; this.config[i]=opt[i] &#125; this.getName=function()&#123; console.log(this.config.name) &#125;&#125;var person = new Person(&#123;name:\"lisi\"&#125;)person.getName(); 结果为1lisi 这种方式的优势是：对象指向性强，new出的就是一个person示例； 3、混合模式123456789101112function Person(name)&#123; this.name = name;&#125;Person.prototype=&#123; getName:function()&#123; console.log(this.name) &#125;&#125;var person = new Person(\"lisi\")person.getName(); 结果为1lisi 这种方式的优势是：属性独立，并且可以根据原型链实现方法共享； js的继承首先介绍js中的原型链首先来一段代码 12345function funcA() &#123; this.show = function() &#123;&#125;&#125;console.log(funcA.prototype); 通过观察可以画出这样的图形 注：此图是盗用别人的图片，具体参考下面链接，此博客已被吾收录。 参考链接 Browse blog 总之，最后形成一张这样的图： 是不是感觉惊呆了！！！！！！如果让我画的话，比如一个b继承a的图，是这样：b是函数funcB()的实例，a是函数funA()的实例对象。 下面是js继承参考链接 Browse blog 1、使用原型链实现继承1234567891011121314151617function SuperClass()&#123; this.name = \"zhang\";&#125;SuperClass.prototype.say=function()&#123; console.log(this.name);&#125;function SubClass()&#123; this.name = \"haha\";&#125;SubClass.prototype.say=function()&#123; console.log(this.name);&#125;SubClass.prototype=new SuperClass();var sub = new SubClass();sub.say(); 结果是： 12haha 但是： 1234567891011121314151617function SuperClass()&#123; this.name = \"women\"; this.bra = [\"a\",\"b\"];&#125;function SubClass()&#123; this.subname = \"your sister\";&#125;SubClass.prototype = new SuperClass();var sub1 = new SubClass();sub1.name = \"man\";sub1.bra.push(\"c\");console.log(sub1.name);//manconsole.log(sub1.bra);//[\"a\",\"b\",\"c\"]var sub2 = new SubClass();console.log(sub1.name);//womanconsole.log(sub2.bra);//[\"a\",\"b\",\"c\"] 缺点显而易见：所有继承自SuperClass的实例都会受到影响，引用类型共享。 2、经典继承1234567891011121314function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this);&#125; var sub1 = new SubClass();console.log(sub1.sayWhat());//TypeError: undefined is not a function 但是： 1、如果在构造函数中有方法的定义，那么对于每一个实例都存在一份单独的Function引用，我们的目的其实是想共用这个方法。（其实不太懂）2、超类型原型中定义的方法，在子类型实例中是无法调用到。 3、组合式继承123456789101112131415function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this); //第二次调用SuperClass&#125;SubClass.prototype = new SuperClass(); //第一次调用SuperClassvar sub1 = new SubClass();console.log(sub1.sayWhat());//hello 这个常用，寄生组合式继承就不写了，想了解的看原文。据说有寄生组合式继承的插件。 但是：这个模式调用了两次超类型的构造函数。 下面是我自己项目中的一段代码：MstBall继承了Missile 1234567891011121314151617181920212223/**组合式继承实现MasterBall这个类*/function MstBall(option)&#123; //经典继承 Missile.call(this,option);&#125;//原型继承MstBall.prototype = new Missile();//重写create方法MstBall.prototype._create = function() &#123; var mstBall = $(\"&lt;div class='missile \"+this.config.className+\"'&gt;\"); mstBall.css(&#123; width:this.config.width, height:this.config.height, transform:\"translate(\"+this.config.pos.x+\"px,\"+this.config.pos.y+\"px)\" &#125;); this.missile=mstBall; //console.log(this.missile) GameConfig.gameBox.append(this.missile); return this;&#125;; ES6中类和类的继承的写法123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 等同于parent.constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 等同于parent.toString() &#125;&#125; 参考链接 Browse blog参考链接 Browse blog ES6继承感觉像java中的的继承，规范了继承的操作。 最后，写点剑锋的东西，虽然最后被拉黑T_T 原型链作用域链demo1123456789//对name的访问, 哪种效率更高var name = '张三';function hello() &#123; console.log(name); console.log(window.name); console.log(this.name);&#125;hello(); 分析： 原型链特点 支持了面向对象开发模式 显示原型指针prototype, 任何函数都有(除了特殊Empty函数) 隐式原型指针__proto__, 任何对象都有(除了null, undefined, NaN) 特殊空函数只有__proto__ Object的原型对象的__proto__指向null 12345678Function instanceof Object //任何对象都是Object的实例Object instanceof Function //任何函数都是Function的实例Date.__proto__ === Function.prototypeFunction.__proto__ === Function.prototype","tags":[]},{"title":"学习md语法 ---爱不释手","date":"2017-03-03T08:51:40.000Z","path":"2017/03/03/secondArticle/","text":"这篇文章就测试下md的语法把！ 这是大标题这是小标题1$ 这里面放代码 这里放超链接: Writing 下面是插入图片 这里也是图片 1![不支持](/assets/blogImg/touxiang.png&#123;100x100&#125; \"测试图片并且定义宽高\") 1![不支持](/assets/blogImg/touxiang.png =100x100 \"测试图片并且定义宽高\") 1$ http://wowubuntu.com/markdown/basic.html 什么也不说了，爽爆了，感觉比博客园之类的写博客好多了在博客园写博客想要好的样式，还必须用第三方工具，我记得是writerlive之类的；现在感觉太棒了！！下面这幅图是用截图工具处理的。。。。 1基本可以应付了。 步骤123hexo new title //默认问post布局，title改为你的文章名似乎还待加一句 $ hexo generate //生成静态文件hexo deploy","tags":[]},{"title":"用hexo制作博客","date":"2017-03-02T14:32:55.508Z","path":"2017/03/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]