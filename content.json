[{"title":"深复制和浅复制","date":"2018-04-15T01:00:31.000Z","path":"2018/04/15/深复制和浅复制/","text":"关于复制也是很常见的问题 关于我们经常写的=赋值，就不把它归为复制，它只是赋值 还有就是常见的数组的方法比如concat、slice都是浅复制 还有ES6里面的Object.assign或…(扩展运算符)实现方式也是浅复制 第二点中举个例子123456// 说明它是浅复制var arr5 = [1, 2, 3, [100, 200, 300]]var arr6 = arr5.slice(0);arr5[3][0]=555console.log(&apos;arr5: &apos;,arr5)console.log(&apos;arr6: &apos;,arr6) 知乎上有张关于浅复制shallow图还是不错的，就是基本数据变量占存储值，对象类型的存引用 关于第三点展开运算符babel解析的时候，可能是数组的形式也可能是对象的Object.assign1234567891011121314let obj = [1, 2, &#123;a: 1&#125;]let obj2 = [...obj]// babel解析后var obj = [1, 2, &#123; a: 1 &#125;];var obj2 = [].concat(obj);------------let obj3 = &#123;a:1,b:3,d:&#123;d:4&#125;&#125;let obj4 = &#123;c:1, ...obj3&#125;// babel解析后var obj3 = &#123; a: 1, b: 3 &#125;;var obj4 = _extends(&#123; c: 1 &#125;, obj3);var _extends = Object.assign || function (target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target; &#125;; 可以看出当展开对象的时候可以是Object.assign或是循环第二个参数和第二个后面的参数给第一个参数(对象)上扩展属性。上例中对于obj4中通过扩展运算符添加的属性d只是单纯的引用关系。下面手动实现一个浅复制123456789101112var obj = &#123; a: 1, arr:[2, 3]&#125;var shallowObj = shallowObj(obj)function shallowObj (obj) &#123; var res = &#123;&#125;; for (prop in obj) &#123; if(obj.hasOwnProperty(prop)) &#123; res[prop] = obj[prop] &#125; &#125; return res;&#125; 但是这个只能浅复制对象，其实数组类似只是循环方法不同罢了，还有其它数据类型，下面讨论。实现深复制数组1234567891011121314function deepcopy(arr)&#123; let _deepcopy = [] for (var i = 0, len=arr.length; i &lt; len; i++) &#123; // 不能让它总是执行下面这段话啊，即使是深复制了，一执行有浅复制了 _deepcopy[i] = arr[i] if(arr[i] instanceof Array) &#123; // 直接赋值引用 VS 循环一下返回个新数组,i是索引。 _deepcopy[i] = deepcopy(arr[i]) &#125; &#125;; return _deepcopy&#125; 但是这个只能深复制数组，原理就是对象类型就用新的对象。还有其它数据类型，下面讨论。其它数据类型参考loadsh 和 知乎一篇文章123456789101112131415161718192021222324var argsTag = &apos;[object Arguments]&apos;, arrayTag = &apos;[object Array]&apos;, boolTag = &apos;[object Boolean]&apos;, dateTag = &apos;[object Date]&apos;, errorTag = &apos;[object Error]&apos;, funcTag = &apos;[object Function]&apos;, mapTag = &apos;[object Map]&apos;, numberTag = &apos;[object Number]&apos;, objectTag = &apos;[object Object]&apos;, regexpTag = &apos;[object RegExp]&apos;, setTag = &apos;[object Set]&apos;, stringTag = &apos;[object String]&apos;, weakMapTag = &apos;[object WeakMap]&apos;;var arrayBufferTag = &apos;[object ArrayBuffer]&apos;, float32Tag = &apos;[object Float32Array]&apos;, float64Tag = &apos;[object Float64Array]&apos;, int8Tag = &apos;[object Int8Array]&apos;, int16Tag = &apos;[object Int16Array]&apos;, int32Tag = &apos;[object Int32Array]&apos;, uint8Tag = &apos;[object Uint8Array]&apos;, uint8ClampedTag = &apos;[object Uint8ClampedArray]&apos;, uint16Tag = &apos;[object Uint16Array]&apos;, uint32Tag = &apos;[object Uint32Array]&apos;;","comments":true,"tags":[]},{"title":"常见面试题","date":"2018-04-15T00:20:18.000Z","path":"2018/04/15/常见面试题/","text":"","comments":true,"tags":[]},{"title":"分页","date":"2018-04-15T00:19:52.000Z","path":"2018/04/15/分页/","text":"","comments":true,"tags":[]},{"title":"debounce和throttle","date":"2018-04-15T00:15:40.000Z","path":"2018/04/15/debounce和throttle/","text":"这个问题也经常会碰到，于是手动实现试试 debounce(防抖)间隔时间内只能执行一次 把该封装的封装，抽离的抽离123456789101112btn.addEventListener(&apos;click&apos;,debounce())function debounce() &#123; return function() &#123; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; todo() &#125;,500) &#125;&#125;function todo() &#123; console.log(11111)&#125; 再优化一下，回调，传参，绑定作用域123456789101112131415// 这个还是蛮标准的。btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; return function() &#123; let context = this; // btn let args = arguments; // 事件e clearTimeout(this.timer) this.timer = setTimeout(function()&#123; fn.apply(context, args) &#125;,delay) &#125;&#125;function todo(param) &#123; console.log(11111, param)&#125; 目前的情况是间隔时间后才触发，如果我想开始就触发，间隔时间后才能再次触发123456789101112131415161718192021btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; let flag = true; return function() &#123; let context = this; let args = arguments; flag &amp;&amp; fn.apply(context, args) flag = false; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; // 想再间隔时间后再执行，就加上它；感觉也行吧 // fn.apply(context, args) flag = true; &#125;,delay) &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 那如果我有时想立即触发，有时想最后一次点击delay后触发，加个参数呗1234btn.addEventListener(&apos;click&apos;,debounce(todo, 500, [true/false]))function debounce(fn, delay, immediate) &#123; ...&#125; throttle(节流) 在规定时间内，不断触发，就行水龙头的水一样 下面呢就实现间隔时间delay内不断触发，并且在最后一次触发的时候，delay秒后将再次自动触发1234567891011121314151617btn.addEventListener(&apos;click&apos;,throttle(todo, 500))function throttle(fn, delay) &#123; return function() &#123; let context = this; let args = arguments; if (!this.timer) &#123; // 没报错说明没语法错误，不执行说明逻辑没走掉这 this.timer = setTimeout(function()&#123; fn.apply(context, args) this.timer = null; &#125;.bind(this), delay) &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 但是呢，上面那个总是在delay后执行，不能立即执行；下面就用时间戳的形式实现立即执行,前提是初始点击的时候已经是delay后了12345678910111213141516btn.addEventListener(&apos;click&apos;,throttle(todo, 500)) function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; &#125; &#125; function todo(params) &#123; console.log(11111, params) &#125; 假如我想开始立即触发，最后那一次delay后也要执行一次呢123456789101112131415161718192021btn.addEventListener(&apos;click&apos;,throttle(todo, 1000))function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; else &#123; clearTimeout(this.timer); this.timer = setTimeout(fn.bind(this, args),delay); &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 适用场景 防抖放在购物车结算时，它只能点击一次； 节流放在购物车加减商品时，还有类似淘宝的搜索框，还有类似的resize,之类的不断触发AjAx的场景 有时防抖和节流会混合试用 看下lodash 关于防抖和节流的实现源码，反正是饶了一大圈，就不详细看了1234567891011121314151617181920212223242526272829303132333435363738394041424344function shouldInvoke(time) &#123; var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we&apos;re at the // trailing edge, the system time has gone backwards and we&apos;re treating // it as the trailing edge, or we&apos;ve hit the ```maxWait``` limit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));&#125;// 这个是判断是否解析时间的函数，应该是：1、初始点击要解析；2、大于间隔时间要解析。。。/** * A simple wrapper around the global [```setTimeout```](https://mdn.io/setTimeout). * * @private * @param &#123;Function&#125; func The function to delay. * @param &#123;number&#125; wait The number of milliseconds to delay invocation. * @returns &#123;number|Object&#125; Returns the timer id or timeout object. */ var setTimeout = ctxSetTimeout || function(func, wait) &#123; return root.setTimeout(func, wait); &#125;; // 对setTimeout进行封装，不知其意 function leadingEdge(time) &#123; // Reset any ```maxWait``` timer. lastInvokeTime = time; // Start the timer for the trailing edge. timerId = setTimeout(timerExpired, wait); // Invoke the leading edge. return leading ? invokeFunc(time) : result; &#125;// 中途调用了leadingEdge这个应该是加载方法，并且第一次调用时调用了invokeFunc(time)function invokeFunc(time) &#123; var args = lastArgs, thisArg = lastThis; lastArgs = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; &#125;// 而这个invokeFunc里面就调用了result = func.apply(thisArg, args);// func就是要执行的回调。","comments":true,"tags":[]},{"title":"手写react和redux","date":"2018-04-15T00:14:38.000Z","path":"2018/04/15/手写react和redux/","text":"","comments":true,"tags":[]},{"title":"手写vue和vuex","date":"2018-04-15T00:14:22.000Z","path":"2018/04/15/手写vue和vuex/","text":"","comments":true,"tags":[]},{"title":"jQuery源码分析","date":"2018-04-15T00:14:00.000Z","path":"2018/04/15/jQuery源码分析/","text":"","comments":true,"tags":[]},{"title":"diary18-2-13","date":"2018-02-13T13:53:46.000Z","path":"2018/02/13/diary18-2-13/","text":"快过年了今年弟弟妹妹不知为什么会想出这样的花招-卖波波球。 往年最多集体出去买一大包辣条，然后躲着小妹妹一起把辣条吃掉。今天(2018/2/18)卖了将近30个，城东最高卖25元/个，城西人民公园卖10元/个。成本价就不说了。确实是一段很棒的经历，杨丹表现得特别棒！ 我觉得要是在我的高中或大学，甚至更小点初中时刻等，去”卖气球”会有更好的体会。","comments":true,"tags":[]},{"title":"vue动画","date":"2017-06-19T14:03:32.000Z","path":"2017/06/19/vue动画/","text":"","comments":true,"tags":[]},{"title":"Node.js","date":"2017-03-18T14:56:18.000Z","path":"2017/03/18/Node-js/","text":"第一步先把下面这个用5分钟看完-_-!! 12http://es6.ruanyifeng.com/ 第二步写demodemo1 实现登录注册demo2 读取歌词 1234567891011121314151617181920212223242526272829303132333435//读取歌词文件//使用cmd进入node脚本模式const fs=require(\"fs\");const path = require(\"path\");let _path=path.join(__dirname,'./xxx.lrc')fs.stat(_path,(err,stats)=&gt;&#123; if(err) throw err; //console.log(stats) fs.readFile(_path,(err,content)=&gt;&#123; if(err) throw err; //默认的就是utf-8,所以不用写。 //console.log(content.toString('utf-8')) let lines = content.toString('utf-8').split('\\n'); //console.log(lines); let rg=/\\[(\\d&#123;2&#125;)\\:(\\d&#123;2&#125;)\\.(\\d&#123;2&#125;)\\](.+)/; lines.forEach((line,index)=&gt;&#123; //console.log(rg.test(line)) let matchs =rg.exec(line); if(matchs)&#123; //console.log(matchs) let h = matchs[1]; let m = matchs[2]; let _s = matchs[3]; let w = matchs[4]; setTimeout(()=&gt;&#123; console.log(w); //定时器的参数是毫秒 &#125;,h*60*1000+m*1000+_s*10) &#125; &#125;) &#125;)&#125;);","comments":true,"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"xmapp","slug":"xmapp","permalink":"http://yoursite.com/tags/xmapp/"}]},{"title":"canvas","date":"2017-03-16T09:32:58.000Z","path":"2017/03/16/canvas/","text":"这篇主要是canvas最终要达到的效果是下面这个样子： demo1 弹弹球，碰撞就变色 这个解决最长时间的问题是： 1234ctx.beginPath();drawBall(ballX,ballY);ctx.closePath(); 缺了2行代码，导致运动完的路径一直都在。 demo2 时钟 demo3 画板 demo4 运动 这个的主要问题是： canvas的旋转是从上一次旋转开始计算的和css3不一样，除非加上save()和restore()方法； clearRect的时候还待translate(0,0)，这个问题。。反正我的浏览器待这样弄。 一个画板要画多个连续运动图像怎么办？ demo5 canvas拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;canvas id=\"can\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var can=document.getElementById(\"can\"); var ctx=can.getContext(\"2d\"); //移动时要覆盖以前的坐标，所以先配置 var points = [ &#123;x:100,y:100,r:50,startA:0,endA:2*Math.PI&#125;, &#123;x:200,y:200,r:50,startA:0,endA:2*Math.PI&#125; ] function drawArc()&#123; for (var i = 0; i &lt; points.length; i++) &#123; ctx.beginPath(); ctx.arc(points[i].x,points[i].y,points[i].r,points[i].startA,points[i].endA); ctx.fill(); &#125; &#125; drawArc(); //移动图形 can.onmousedown = function(e)&#123; var e = e || window.event; document.onmousemove=function(e)&#123; var e = e || window.event; ctx.clearRect(0,0,500,500); var x = e.layerX; var y = e.layerY; //重新绘制 for (var i = points.length - 1; i &gt;= 0; i--) &#123; var event = new addEvent(ctx,\"arc\",points[i].x+\",\"+points[i].y+\",\"+points[i].r+\",\"+points[i].startA+\",\"+points[i].endA,function()&#123; ctx.beginPath(); console.log(points[i].r+\"我是第53行\") var [callbackR,callbackX,callbackY] = [points[i].r,points[i].x,points[i].y] ctx.arc(x,y,callbackR,callbackX,callbackY); ctx.fill(); points[i].x = x; points[i].y = y; &#125;) event.isPointInPathCallback(x,y); &#125; event.isPointInPathCallback(x,y); &#125; document.onmouseup=function()&#123; document.onmousemove = null; document.onmouseup = null; &#125; &#125; /* //未点击之前先绘制，点击后再绘制；确保点击后是最新绘制的 ctx.beginPath(); ctx.arc(100,100,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(200,200,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.rect(400,200,50,50); ctx.fill(); //点击对应的图片，弹出对应的值 // can.onclick = function (e)&#123; // var e = e || window.event; // var x = e.layerX; // var y = e.layerY; // //和上面一个意思 // // var xx = e.offsetX; // // var yy = e.offsetY; // //如果把2*Math.PI当成字符串传进去是不行的。 // var event1 = new addEvent(ctx,\"arc\",\"100,100,50,0,\"+2*Math.PI,function()&#123; // alert(1); // &#125;) // event1.isPointInPathCallback(x,y); // var event2 = new addEvent(ctx,\"arc\",\"200,200,50,0,\"+2*Math.PI,function()&#123; // alert(2); // &#125;) // event2.isPointInPathCallback(x,y); // var event3 = new addEvent(ctx,\"rect\",\"400,200,50,50\",function()&#123; // alert(3); // &#125;) // event3.isPointInPathCallback(x,y); // &#125; */ //封装成一个util function addEvent (obj,type,data,callback)&#123; this.obj = obj; this.type = type; this.data = data; this.callback = callback; this.reDraw(); &#125; addEvent.prototype = &#123; reDraw:function()&#123; if(this.type == \"arc\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.arc(arr[0],arr[1],arr[2],arr[3],arr[4]); this.obj.fill(); &#125;else if(this.type == \"rect\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.rect(arr[0],arr[1],arr[2],arr[3]); this.obj.fill(); &#125; &#125;, isPointInPathCallback:function(x,y)&#123; if(this.obj.isPointInPath(x,y))&#123; this.callback(); &#125; &#125; &#125;;&lt;/script&gt; 存在的问题： 53行能打印出来，但是也报错Uncaught TypeError: Cannot read property ‘r’ of undefined。 点击图形起始点和图形的圆心是有距离的，后期拖拽时直接将拖拽的相对距离赋值给了圆心，导致误差。 还是有点懵。每次new 相同的event? demo6 canvas实现3d效果 很棒的canvas3次贝塞尔曲线算法地图 canvas库 参考链接：https://www.evget.com/article/2014/4/9/20799.html 报表统计 项目实现一个绘图工具 git地址：","comments":true,"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"开源项目","date":"2017-03-16T02:11:23.000Z","path":"2017/03/16/开源项目/","text":"以下是开源项目，感兴趣的同学可以一块加入。 React12https://github.com/18706789739/cloudMusic.git Angular12http://eisneim.github.io/angular-ui-awesome/","comments":true,"tags":[{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"搭载git服务器","date":"2017-03-05T06:55:49.000Z","path":"2017/03/05/搭载git服务器/","text":"要是有人再问我会不会搭服务器，我就问是什么服务器？tomcat、weblogic、solr还是其它?下面介绍的是在ubuntu-16.04.2下搭载git服务器，之所以选择这个版本是因为要运行nodeJs。 Ubuntu下搭载git服务器先给几个参考链接，我也是参考这里的。 链接一 链接二 链接三 链接四 首先你待有个Ubuntu系统 这里推荐用u盘安装。开始没用u盘安装，好久都没有安装成功。最后用u盘也就半个小时解决。 调出终端输入命令123sudo apt-get install gitsudo apt-get install openssh-server 可以通过下面的命令查看sshd相关的进程信息 12ps -ef|grep \"sshd\" 如果你能看到一些sshd相关的进程信息，则说明你已经有这个服务了。 然后，为自己配置身份信息，这样多个人提交代码的时候，就可以方便的查看是谁提交的。 123git config --global user.name \"yourname\" git config --global user.email \"your@email.com\" 再然后配置一个专门的git用户并设置密码，专门对代码进行管理。 123sudo useradd -m git(yours) sudo passwd git(change to yours) 然后，在新建的git用户主目录下创建一个文件夹作为git的仓库，并为这个仓库配备最基本的安防——权限控制 1234sudo mkdir /home/git/repositories # 最好使用repositories作为文件夹名称，这样可以简化后面的操作 sudo chown git:git /home/git/repositories sudo chmod 755 /home/git/repositories 输入一下命令基本就OK!!12345su git //切换到git用户,你可以发现路径前面变了mkdir helloworld //新建一个目录（仓库）cd helloworld git --bare init //初始化一个空的仓库 然后找一台机器测试一下 12git clone git@192.168.0.123:/home/git/repositories/helloworld 再加上下面这段命令，方便你可以push和pull 然后就成功了！ 再找第三台机器测试，还是成功的。 但是服务器里我什么也找不到，我开始以为失败了。 但是，还有 不足之处，比如别的文章提到的: 解决每个步骤都需要输入git用户的密码。 出于安全考虑，创建的git用户不允许登录shell。 下一步可以试试hadoop，不过待加内存条，那就快点发工资吧！","comments":true,"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"Flux架构","date":"2017-03-04T14:19:53.000Z","path":"2017/03/04/Flux架构/","text":"最近公司做的项目据我观察就是flux架构，即使不是也是Flux存在多种实现之一，比如Redux之类的。 Flux架构先来个阮老师(好多人喜欢这么称呼)链接， 参考链接 Browse blog 基本概念 View：视图层； Action：动作层，视图层发出的消息(比如click)； Dispather: 派发器，用来接收action，执行回调函数； Store: 数据层，用来存放用用状态，一旦发生变动，就提醒View要更新页面； Flux特点 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 上面过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。 然后就是看阮老师的demo,我是看的差不多了。 想用调试工具调一下，先是用chrome react 插件,搞了好久，插件闪来闪去，没法弄。git上的源码又不知怎么变成crc文件。然后只能用react-hot-loader链接也可以试试react-transform 在webpack配置完react-hot-loader后又调不好程序了-_-!!!。不知道了，应该可以找到。 Redux2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 参考链接 整个过程是： 用户发出 Action，store.dispatch(action); Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State。 State 一旦有变化，Store 就会调用监听函数。 listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 然后，看demo。 还有异步操作：Action 发出以后，过一段时间再执行 Reducer，这就是异步。这个没细看，感觉像面向切面的编程(AOP)。 公司项目分析项目src的目录介绍 其实还是不大懂！！ 关于bind找了些资料总结一下：当需要传参，为了确保处理函数中的this时刻指向这个组件，就需要bind。bind会可以复制出一个函数，改变函数指针，给函数传参。 比如下面这个demo1234567891011121314151617181920212223242526272829var Hello=React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'', sex:'', age:'', tel:'', address:'' &#125; &#125;, changeValue:function(type,e)&#123; var that=this; var obj=&#123;&#125; obj[type]=e.target.value; that.setState(obj) &#125;, render:function()&#123; return ( &lt;div&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'name')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.name&#125;&lt;br/&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'sex')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.sex&#125;&lt;br/&gt; &lt;input onChange=&#123;this.ageChange&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.age&#125;&lt;br/&gt; &lt;/div&gt; ) &#125;&#125;) ReactDOM.render(&lt;Hello/&gt;,document.getElementById(\"app\")); 项目中初始化时bind 123456789101112131415161718192021class InvitationJoin extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; this.join = this.join.bind(this); &#125; join() &#123;&#125; render() &#123; return &lt;div className=&#123;style.box&#125;&gt; ....... &lt;div className=&#123;style.btnBox&#125;&gt; &lt;div className=&#123;button.normal&#125; onClick=&#123;this.join&#125;&gt;&#123;'加入'&#125;&lt;/div&gt; &lt;/div&gt; ........ &lt;/div&gt; &#125;&#125;export default InvitationJoin; 使用箭头函数从而避免bind,剑锋说效率低。 12暂时没找到，有时间再从项目中找。 webpack打包，不用考虑js的兼容。组件定义对象。123456xxxx(()=&gt;&#123;&#125;)&#123; return&#123; &#125;&#125; 实在没时间写了，改天再写！！！！！！","comments":true,"tags":[{"name":"前端架构","slug":"前端架构","permalink":"http://yoursite.com/tags/前端架构/"}]},{"title":"框架对比","date":"2017-03-04T10:59:30.000Z","path":"2017/03/04/框架对比/","text":"关于框架的对比网上资料很多，这里仅供参考 React的特点和优势 虚拟dom，减少不必要的更新，render Virtual DOM + diff + 必要的 DOM 更新。 jsx语法，结构清晰易于编写，必须是闭合标签。 单向数据流，只要服务端数据发生变动，前端数据也变动，开发者只关注实现业务就行了。 组件化开发，可组合、可重用、可维护、可测试。 vue没用过，听说vue是结合angular和react国产框架，是最简单的框架，这话不是我说的。还有人说，微信小程序内部是react native开发的，这话也不是我说的。 React和Vue对比 React和Vue的适用范围无疑是很相似的：同样是基于组件的轻量级框架，同样专注于用户界面的视图层。同样可以用在简单的项目中，也同样可以使用全家桶扩展为复杂的应用程序。 React是一个轻量级的框架，专注试图层，适用于简单个大型项目，并且可以从webApp像原生过度，reactNative。 如果喜欢使用模版用vue,因为react是借助jsx在js中创建DOM. 如果你喜欢简单，用vue,因为不需要转译，react重度依赖jsx和es6新特性，比如class。 竟可能小和快使用vue,渲染快，引入的文件小。 大型应用程序选择react,js模版可测试性和维护性很高。vue模版很难测试，维护，分解。 适用于Web端，和原生App的框架，用react。React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 如果你学过React.js，很快就能上手React Native。 更大的生态系统选择react。 如果你已经用其中一个用得很爽了，那就不用变了。 参考链接 Browse blog 附录：曾经问剑锋为什么选择react时，我做了点总结： react是偏向功能性的，轻量级的，单页面应用，组件开发，并且易于向原生开发过度(react native)。 他给我的印象就是，老是问我能用图画出来吗？然后还有以前的话，“尝试是错误的，想好再做”、“把快捷键都记住”、“要动脑，总结”，还有以前的话“把业务编号都记住”，连环踢T_T； Angular1 适用于SPA–路由机制;CRUD应用,如后台管理界面。 不适用,游戏、图形界面编辑器，这种频繁DOM操作也很复杂的应用。 Angular1的特性 MVC（模型 - 视图 - 控制器）或MVVM （模型 - 视图 - 视图模型）模式来组织源代码。 模块系统,依赖注入,可嵌入、注入和测试。 指令系统,可以创建可重用的自定义组件与指令的API。 HTML 模板,允许设计人员和开发人员同时工作。 数据双向绑定,当模型发生变化时，视图会自动更新，反之亦然。 以前公司的框架 以前公司的前台框架是使用jQuery UI部件库（Widget Factory）来创建插件，并且这也是最常见的一种方式，说来自己也研究好几年了,然并卵。 1234567891011121314$.widget( \"custom.progressbar\", &#123; // Default options. options: &#123; value: 0 &#125;, _create: function() &#123; var progress = this.options.value + \"%\"; this.element .addClass( \"progressbar\" ) .text( progress ); &#125;&#125;); 上面这段代码是从菜鸟学院粘贴过来的。 最后呢，曾经有人问我用angular1做项目，以后会不会出现什么问题？我说:”如果只是一个花瓶的话，用什么都没问题。”，最后再套用一下别人的话如果你已经用其中一个用得很爽了，那就不用变了。","comments":true,"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"}]},{"title":"React开发","date":"2017-03-04T04:20:08.000Z","path":"2017/03/04/React开发/","text":"最近公司用react开发项目，所以学习一下。 react组件react组件的生命周期关于react生命周期，不同的地方写得不一样但是，意思一样，我就挑一个写吧。 react设计组件的时候，把组件看成是有生命的物体，让它具有生命周期，共有三大周期。 创建期 存在期 销毁期 1、创建期创建期分为5个阶段： getDefaultProps :获取默认属性，还没创建出来，看不见内部的对象属性，只运行一次。 getInitialState :获取默认状态,数据已创建，可以访问实例化对象。 componentWillMount :组件将要被创建,组件的虚拟dom，将要渲染输出虚拟dom。 render :组件渲染输出虚拟dom,一定要通过return返回虚拟dom树。 componentDidMount :组件已经构建完成,组件已创建完成虚拟dom,可以操作真实的dom。 -_-! 以后就直接用画图工具画了，太丑陋，还待上传。 2、存在期存在期分为5个阶段： componentWillReceiveProps :组件将要接受新的属性。 shouldComponentUpdate :组件是否应该更新，必须返回true或false。 componentWillUpdate :组件将要更新。 render :组件更新，输出虚拟dom。 componentDidUpdate :组件已经更新完成。 3、销毁期销毁期就1个阶段： componentWillUnmount :组件即将被销毁。 下面是一个demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;React 实例&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var MessageBox = React.createClass(&#123; getInitialState:function()&#123; console.log('getInitialState'); return&#123; count:0, &#125; &#125;, getDefaultProps:function()&#123; console.log(\"getDefaultProps\"); &#125;, componentWillMount:function()&#123; console.log(\"componentWillMount\"); var self = this; this.timer = setInterval(function()&#123; self.setState(&#123; count:self.state.count + 1, &#125;) &#125;,1000); &#125;, componentDidMount:function()&#123; console.log(\"componentDidMount\"); &#125;, componentWillReceiveProps:function(nextProps)&#123; console.log(\"component will receive props\"); &#125;, shouldComponentUpdate:function(newProps,nextState)&#123; console.log(\"shouldComponentUpdate\"); if(nextState.count&gt;10)&#123; console.log(\"不要老是更新我！--优化作用\"); return false; &#125; return true; &#125;, componentWillUpdate:function(nextProps,nextState)&#123; console.log(\"component will update\"); &#125;, componentDidUpdate:function(prepProps,prepState)&#123; console.log(\"component did update\"); if(this.state.count&gt;3)&#123; clearInterval(this.timer); &#125; &#125;, componentWillUnmount:function()&#123; console.log(\"componet will unmount\"); alert(\"啊不要啊！！！\"); clearInterval(this.timer); &#125;, kill:function()&#123; ReactDOM.unmountComponentAtNode(document.getElementById('app')); &#125;, doUpdate:function()&#123; this.setState(&#123; count:this.state.count +1, &#125;); &#125;, render:function()&#123; console.log(\"渲染\"); return( &lt;div&gt; &lt;h1&gt;计数:&#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.kill&#125;&gt;卸载这个组件&lt;/button&gt; &lt;button onClick=&#123;this.doUpdate&#125;&gt;手动更新&lt;/button&gt; &lt;Submessage count=&#123;this.state.count&#125;/&gt; &lt;/div&gt; ) &#125; &#125;); var Submessage = React.createClass(&#123; componentWillReceiveProps:function(nextProp)&#123; console.log(\"子组件将要获取prop\"); &#125;, shouldComponentUpdate:function(nextProp,nextState)&#123; if(nextProp.count&gt;6) return false; return true; &#125;, render:function()&#123; return( &lt;h3&gt;当前计数是:&#123;this.props.count&#125;&lt;/h3&gt; ) &#125; &#125;); var messageBox = ReactDOM.render(&lt;MessageBox/&gt;,document.getElementById('app')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：","comments":true,"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"js理解","date":"2017-03-03T10:08:31.000Z","path":"2017/03/03/js理解/","text":"js中的面向对象面向对象的三大特性：封装、继承、多态。这里只说封装和继承。js面向对象的几种方式这个不同的人有不同的总结，仅供参考！ 1、工厂模式123456789101112131415function Person(name)&#123; // 原料 var obj=new Object(); // 加工 obj.name=name; obj.getName=function() &#123; console.log(this.name) &#125; //出厂 return obj;&#125;var person = Person(\"zhang\")person.getName(); 结果为1zhang 这种方式的缺点是：每一个实例都创建一个新的对象,浪费空间，并且创建实例时没有用关键字new； 2、构造函数模式123456789101112131415function Person(opt)&#123; this.config=&#123; name:\"zhang\" &#125; for(var i in opt)&#123; this.config[i]=opt[i] &#125; this.getName=function()&#123; console.log(this.config.name) &#125;&#125;var person = new Person(&#123;name:\"lisi\"&#125;)person.getName(); 结果为1lisi 这种方式的优势是：对象指向性强，new出的就是一个person示例； 3、混合模式123456789101112function Person(name)&#123; this.name = name;&#125;Person.prototype=&#123; getName:function()&#123; console.log(this.name) &#125;&#125;var person = new Person(\"lisi\")person.getName(); 结果为1lisi 这种方式的优势是：属性独立，并且可以根据原型链实现方法共享； js的继承首先介绍js中的原型链首先来一段代码 12345function funcA() &#123; this.show = function() &#123;&#125;&#125;console.log(funcA.prototype); 通过观察可以画出这样的图形 注：此图是盗用别人的图片，具体参考下面链接，此博客已被吾收录。 参考链接 Browse blog 总之，最后形成一张这样的图： 是不是感觉惊呆了！！！！！！如果让我画的话，比如一个b继承a的图，是这样：b是函数funcB()的实例，a是函数funA()的实例对象。 下面是js继承参考链接 Browse blog 1、使用原型链实现继承1234567891011121314151617function SuperClass()&#123; this.name = \"zhang\";&#125;SuperClass.prototype.say=function()&#123; console.log(this.name);&#125;function SubClass()&#123; this.name = \"haha\";&#125;SubClass.prototype.say=function()&#123; console.log(this.name);&#125;SubClass.prototype=new SuperClass();var sub = new SubClass();sub.say(); 结果是： 12haha 但是： 1234567891011121314151617function SuperClass()&#123; this.name = \"women\"; this.bra = [\"a\",\"b\"];&#125;function SubClass()&#123; this.subname = \"your sister\";&#125;SubClass.prototype = new SuperClass();var sub1 = new SubClass();sub1.name = \"man\";sub1.bra.push(\"c\");console.log(sub1.name);//manconsole.log(sub1.bra);//[\"a\",\"b\",\"c\"]var sub2 = new SubClass();console.log(sub1.name);//womanconsole.log(sub2.bra);//[\"a\",\"b\",\"c\"] 缺点显而易见：所有继承自SuperClass的实例都会受到影响，引用类型共享。 2、经典继承1234567891011121314function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this);&#125; var sub1 = new SubClass();console.log(sub1.sayWhat());//TypeError: undefined is not a function 但是： 1、如果在构造函数中有方法的定义，那么对于每一个实例都存在一份单独的Function引用，我们的目的其实是想共用这个方法。（其实不太懂）2、超类型原型中定义的方法，在子类型实例中是无法调用到。 3、组合式继承123456789101112131415function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this); //第二次调用SuperClass&#125;SubClass.prototype = new SuperClass(); //第一次调用SuperClassvar sub1 = new SubClass();console.log(sub1.sayWhat());//hello 这个常用，寄生组合式继承就不写了，想了解的看原文。据说有寄生组合式继承的插件。 但是：这个模式调用了两次超类型的构造函数。 下面是我自己项目中的一段代码：MstBall继承了Missile 1234567891011121314151617181920212223/**组合式继承实现MasterBall这个类*/function MstBall(option)&#123; //经典继承 Missile.call(this,option);&#125;//原型继承MstBall.prototype = new Missile();//重写create方法MstBall.prototype._create = function() &#123; var mstBall = $(\"&lt;div class='missile \"+this.config.className+\"'&gt;\"); mstBall.css(&#123; width:this.config.width, height:this.config.height, transform:\"translate(\"+this.config.pos.x+\"px,\"+this.config.pos.y+\"px)\" &#125;); this.missile=mstBall; //console.log(this.missile) GameConfig.gameBox.append(this.missile); return this;&#125;; ES6中类和类的继承的写法123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 等同于parent.constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 等同于parent.toString() &#125;&#125; 参考链接 Browse blog参考链接 Browse blog ES6继承感觉像java中的的继承，规范了继承的操作。 最后，写点剑锋的东西，虽然最后被拉黑T_T 原型链作用域链demo1123456789//对name的访问, 哪种效率更高var name = '张三';function hello() &#123; console.log(name); console.log(window.name); console.log(this.name);&#125;hello(); 分析：1234567891011121314var name = '张三'; var start = new Date().getTime(); for(var i=0;i&lt;100000;i++)&#123; hello() &#125; var end = new Date().getTime(); alert(end-start); function hello()&#123; //console.log(name)//2234,2240,2372,2272---2279.5 //console.log(window.name);//2292,2439,2299,2437---2366.75 //console.log(this.name);//2302,2324,2272,2363--2315.25 &#125; 我就这么测了一下效率从高到低是name,this.name,window.name。。。和我分析的不一样啊！！不过测也不准，优势时间多有时时间低。 原型链特点 支持了面向对象开发模式 显示原型指针prototype, 任何函数都有(除了特殊Empty函数) 隐式原型指针__proto__, 任何对象都有(除了null, undefined, NaN) 特殊空函数只有__proto__ Object的原型对象的__proto__指向null 12345678Function instanceof Object //任何对象都是Object的实例Object instanceof Function //任何函数都是Function的实例Date.__proto__ === Function.prototypeFunction.__proto__ === Function.prototype","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"学习md语法 ---爱不释手","date":"2017-03-03T08:51:40.000Z","path":"2017/03/03/md语法/","text":"这篇文章就测试下md的语法把！ 这是大标题这是小标题1$ 这里面放代码 这里放超链接: Writing 下面是插入图片 这里也是图片 1![不支持](/assets/blogImg/touxiang.png&#123;100x100&#125; \"测试图片并且定义宽高\") 1![不支持](/assets/blogImg/touxiang.png =100x100 \"测试图片并且定义宽高\") 1$ http://wowubuntu.com/markdown/basic.html 什么也不说了，爽爆了，感觉比博客园之类的写博客好多了在博客园写博客想要好的样式，还必须用第三方工具，我记得是writerlive之类的；现在感觉太棒了！！下面这幅图是用截图工具处理的。。。。 这里是列表 这里是列表 1基本可以应付了。 步骤123hexo new title //默认问post布局，title改为你的文章名似乎还待加一句 $ hexo generate //生成静态文件hexo deploy 列表： 。。。。 。。。","comments":true,"tags":[]},{"title":"用hexo制作博客","date":"2017-03-02T14:32:55.508Z","path":"2017/03/02/hexo博客/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]