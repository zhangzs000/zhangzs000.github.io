[{"title":"搭载git服务器","date":"2017-03-05T06:55:49.000Z","path":"2017/03/05/搭载git服务器/","text":"","comments":true,"tags":[]},{"title":"Flux架构","date":"2017-03-04T14:19:53.000Z","path":"2017/03/04/Flux架构/","text":"最近公司做的项目据我观察就是flux架构，即使不是也是Flux存在多种实现之一，比如Redux之类的。 Flux架构先来个阮老师(好多人喜欢这么称呼)链接， 参考链接 Browse blog 基本概念 View：视图层； Action：动作层，视图层发出的消息(比如click)； Dispather: 派发器，用来接收action，执行回调函数； Store: 数据层，用来存放用用状态，一旦发生变动，就提醒View要更新页面； Flux特点 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 上面过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。 然后就是看阮老师的demo,我是看的差不多了。 想用调试工具调一下，先是用chrome react 插件,搞了好久，插件闪来闪去，没法弄。git上的源码又不知怎么变成crc文件。然后只能用react-hot-loader链接也可以试试react-transform 在webpack配置完react-hot-loader后又调不好程序了-_-!!!。不知道了，应该可以找到。 Redux2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 参考链接 整个过程是： 用户发出 Action，store.dispatch(action); Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State。 State 一旦有变化，Store 就会调用监听函数。 listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 然后，看demo。 还有异步操作：Action 发出以后，过一段时间再执行 Reducer，这就是异步。这个没细看，感觉像面向切面的编程(AOP)。 公司项目分析项目src的目录介绍 其实还是不大懂！！ 关于bind找了些资料总结一下：当需要传参，为了确保处理函数中的this时刻指向这个组件，就需要bind。bind会可以复制出一个函数，改变函数指针，给函数传参。 比如下面这个demo1234567891011121314151617181920212223242526272829var Hello=React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'', sex:'', age:'', tel:'', address:'' &#125; &#125;, changeValue:function(type,e)&#123; var that=this; var obj=&#123;&#125; obj[type]=e.target.value; that.setState(obj) &#125;, render:function()&#123; return ( &lt;div&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'name')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.name&#125;&lt;br/&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'sex')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.sex&#125;&lt;br/&gt; &lt;input onChange=&#123;this.ageChange&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.age&#125;&lt;br/&gt; &lt;/div&gt; ) &#125;&#125;) ReactDOM.render(&lt;Hello/&gt;,document.getElementById(\"app\")); 项目中初始化时bind 123456789101112131415161718192021class InvitationJoin extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; this.join = this.join.bind(this); &#125; join() &#123;&#125; render() &#123; return &lt;div className=&#123;style.box&#125;&gt; ....... &lt;div className=&#123;style.btnBox&#125;&gt; &lt;div className=&#123;button.normal&#125; onClick=&#123;this.join&#125;&gt;&#123;'加入'&#125;&lt;/div&gt; &lt;/div&gt; ........ &lt;/div&gt; &#125;&#125;export default InvitationJoin; 使用箭头函数从而避免bind,剑锋说效率低。 12暂时没找到，有时间再从项目中找。 webpack打包，不用考虑js的兼容。组件定义对象。123456xxxx(()=&gt;&#123;&#125;)&#123; return&#123; &#125;&#125; 实在没时间写了，改天再写！！！！！！","comments":true,"tags":[]},{"title":"框架对比","date":"2017-03-04T10:59:30.000Z","path":"2017/03/04/框架对比/","text":"关于框架的对比网上资料很多，这里仅供参考 React的特点和优势 虚拟dom，减少不必要的更新，render Virtual DOM + diff + 必要的 DOM 更新。 jsx语法，结构清晰易于编写，必须是闭合标签。 单向数据流，只要服务端数据发生变动，前端数据也变动，开发者只关注实现业务就行了。 组件化开发，可组合、可重用、可维护、可测试。 vue没用过，听说vue是结合angular和react国产框架，是最简单的框架，这话不是我说的。还有人说，微信小程序内部是react native开发的，这话也不是我说的。 React和Vue对比 React和Vue的适用范围无疑是很相似的：同样是基于组件的轻量级框架，同样专注于用户界面的视图层。同样可以用在简单的项目中，也同样可以使用全家桶扩展为复杂的应用程序。 React是一个轻量级的框架，专注试图层，适用于简单个大型项目，并且可以从webApp像原生过度，reactNative。 如果喜欢使用模版用vue,因为react是借助jsx在js中创建DOM. 如果你喜欢简单，用vue,因为不需要转译，react重度依赖jsx和es6新特性，比如class。 竟可能小和快使用vue,渲染快，引入的文件小。 大型应用程序选择react,js模版可测试性和维护性很高。vue模版很难测试，维护，分解。 适用于Web端，和原生App的框架，用react。React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 如果你学过React.js，很快就能上手React Native。 更大的生态系统选择react。 如果你已经用其中一个用得很爽了，那就不用变了。 参考链接 Browse blog 附录：曾经问剑锋为什么选择react时，我做了点总结： react是偏向功能性的，轻量级的，单页面应用，组件开发，并且易于向原生开发过度(react native)。 他给我的印象就是，老是问我能用图画出来吗？然后还有以前的话，“尝试是错误的，想好再做”、“把快捷键都记住”、“要动脑，总结”，还有以前的话“把业务编号都记住”，连环踢T_T； Angular1 适用于SPA–路由机制;CRUD应用,如后台管理界面。 不适用,游戏、图形界面编辑器，这种频繁DOM操作也很复杂的应用。 Angular1的特性 MVC（模型 - 视图 - 控制器）或MVVM （模型 - 视图 - 视图模型）模式来组织源代码。 模块系统,依赖注入,可嵌入、注入和测试。 指令系统,可以创建可重用的自定义组件与指令的API。 HTML 模板,允许设计人员和开发人员同时工作。 数据双向绑定,当模型发生变化时，视图会自动更新，反之亦然。 以前公司的框架 以前公司的前台框架是使用jQuery UI部件库（Widget Factory）来创建插件，并且这也是最常见的一种方式，说来自己也研究好几年了,然并卵。 1234567891011121314$.widget( \"custom.progressbar\", &#123; // Default options. options: &#123; value: 0 &#125;, _create: function() &#123; var progress = this.options.value + \"%\"; this.element .addClass( \"progressbar\" ) .text( progress ); &#125;&#125;); 上面这段代码是从菜鸟学院粘贴过来的。 最后呢，曾经有人问我用angular1做项目，以后会不会出现什么问题？我说:”如果只是一个花瓶的话，用什么都没问题。”，最后再套用一下别人的话如果你已经用其中一个用得很爽了，那就不用变了。","comments":true,"tags":[]},{"title":"React开发","date":"2017-03-04T04:20:08.000Z","path":"2017/03/04/React开发/","text":"最近公司用react开发项目，所以学习一下。 react组件react组件的生命周期关于react生命周期，不同的地方写得不一样但是，意思一样，我就挑一个写吧。 react设计组件的时候，把组件看成是有生命的物体，让它具有生命周期，共有三大周期。 创建期 存在期 销毁期 1、创建期创建期分为5个阶段： getDefaultProps :获取默认属性，还没创建出来，看不见内部的对象属性，只运行一次。 getInitialState :获取默认状态,数据已创建，可以访问实例化对象。 componentWillMount :组件将要被创建,组件的虚拟dom，将要渲染输出虚拟dom。 render :组件渲染输出虚拟dom,一定要通过return返回虚拟dom树。 componentDidMount :组件已经构建完成,组件已创建完成虚拟dom,可以操作真实的dom。 -_-! 以后就直接用画图工具画了，太丑陋，还待上传。 2、存在期存在期分为5个阶段： componentWillReceiveProps :组件将要接受新的属性。 shouldComponentUpdate :组件是否应该更新，必须返回true或false。 componentWillUpdate :组件将要更新。 render :组件更新，输出虚拟dom。 componentDidUpdate :组件已经更新完成。 3、销毁期销毁期就1个阶段： componentWillUnmount :组件即将被销毁。 下面是一个demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;React 实例&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var MessageBox = React.createClass(&#123; getInitialState:function()&#123; console.log('getInitialState'); return&#123; count:0, &#125; &#125;, getDefaultProps:function()&#123; console.log(\"getDefaultProps\"); &#125;, componentWillMount:function()&#123; console.log(\"componentWillMount\"); var self = this; this.timer = setInterval(function()&#123; self.setState(&#123; count:self.state.count + 1, &#125;) &#125;,1000); &#125;, componentDidMount:function()&#123; console.log(\"componentDidMount\"); &#125;, componentWillReceiveProps:function(nextProps)&#123; console.log(\"component will receive props\"); &#125;, shouldComponentUpdate:function(newProps,nextState)&#123; console.log(\"shouldComponentUpdate\"); if(nextState.count&gt;10)&#123; console.log(\"不要老是更新我！--优化作用\"); return false; &#125; return true; &#125;, componentWillUpdate:function(nextProps,nextState)&#123; console.log(\"component will update\"); &#125;, componentDidUpdate:function(prepProps,prepState)&#123; console.log(\"component did update\"); if(this.state.count&gt;3)&#123; clearInterval(this.timer); &#125; &#125;, componentWillUnmount:function()&#123; console.log(\"componet will unmount\"); alert(\"啊不要啊！！！\"); clearInterval(this.timer); &#125;, kill:function()&#123; ReactDOM.unmountComponentAtNode(document.getElementById('app')); &#125;, doUpdate:function()&#123; this.setState(&#123; count:this.state.count +1, &#125;); &#125;, render:function()&#123; console.log(\"渲染\"); return( &lt;div&gt; &lt;h1&gt;计数:&#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.kill&#125;&gt;卸载这个组件&lt;/button&gt; &lt;button onClick=&#123;this.doUpdate&#125;&gt;手动更新&lt;/button&gt; &lt;Submessage count=&#123;this.state.count&#125;/&gt; &lt;/div&gt; ) &#125; &#125;); var Submessage = React.createClass(&#123; componentWillReceiveProps:function(nextProp)&#123; console.log(\"子组件将要获取prop\"); &#125;, shouldComponentUpdate:function(nextProp,nextState)&#123; if(nextProp.count&gt;6) return false; return true; &#125;, render:function()&#123; return( &lt;h3&gt;当前计数是:&#123;this.props.count&#125;&lt;/h3&gt; ) &#125; &#125;); var messageBox = ReactDOM.render(&lt;MessageBox/&gt;,document.getElementById('app')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：","comments":true,"tags":[]},{"title":"js理解","date":"2017-03-03T10:08:31.000Z","path":"2017/03/03/js理解/","text":"js中的面向对象面向对象的三大特性：封装、继承、多态。这里只说封装和继承。js面向对象的几种方式这个不同的人有不同的总结，仅供参考！ 1、工厂模式123456789101112131415function Person(name)&#123; // 原料 var obj=new Object(); // 加工 obj.name=name; obj.getName=function() &#123; console.log(this.name) &#125; //出厂 return obj;&#125;var person = Person(\"zhang\")person.getName(); 结果为1zhang 这种方式的缺点是：每一个实例都创建一个新的对象,浪费空间，并且创建实例时没有用关键字new； 2、构造函数模式123456789101112131415function Person(opt)&#123; this.config=&#123; name:\"zhang\" &#125; for(var i in opt)&#123; this.config[i]=opt[i] &#125; this.getName=function()&#123; console.log(this.config.name) &#125;&#125;var person = new Person(&#123;name:\"lisi\"&#125;)person.getName(); 结果为1lisi 这种方式的优势是：对象指向性强，new出的就是一个person示例； 3、混合模式123456789101112function Person(name)&#123; this.name = name;&#125;Person.prototype=&#123; getName:function()&#123; console.log(this.name) &#125;&#125;var person = new Person(\"lisi\")person.getName(); 结果为1lisi 这种方式的优势是：属性独立，并且可以根据原型链实现方法共享； js的继承首先介绍js中的原型链首先来一段代码 12345function funcA() &#123; this.show = function() &#123;&#125;&#125;console.log(funcA.prototype); 通过观察可以画出这样的图形 注：此图是盗用别人的图片，具体参考下面链接，此博客已被吾收录。 参考链接 Browse blog 总之，最后形成一张这样的图： 是不是感觉惊呆了！！！！！！如果让我画的话，比如一个b继承a的图，是这样：b是函数funcB()的实例，a是函数funA()的实例对象。 下面是js继承参考链接 Browse blog 1、使用原型链实现继承1234567891011121314151617function SuperClass()&#123; this.name = \"zhang\";&#125;SuperClass.prototype.say=function()&#123; console.log(this.name);&#125;function SubClass()&#123; this.name = \"haha\";&#125;SubClass.prototype.say=function()&#123; console.log(this.name);&#125;SubClass.prototype=new SuperClass();var sub = new SubClass();sub.say(); 结果是： 12haha 但是： 1234567891011121314151617function SuperClass()&#123; this.name = \"women\"; this.bra = [\"a\",\"b\"];&#125;function SubClass()&#123; this.subname = \"your sister\";&#125;SubClass.prototype = new SuperClass();var sub1 = new SubClass();sub1.name = \"man\";sub1.bra.push(\"c\");console.log(sub1.name);//manconsole.log(sub1.bra);//[\"a\",\"b\",\"c\"]var sub2 = new SubClass();console.log(sub1.name);//womanconsole.log(sub2.bra);//[\"a\",\"b\",\"c\"] 缺点显而易见：所有继承自SuperClass的实例都会受到影响，引用类型共享。 2、经典继承1234567891011121314function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this);&#125; var sub1 = new SubClass();console.log(sub1.sayWhat());//TypeError: undefined is not a function 但是： 1、如果在构造函数中有方法的定义，那么对于每一个实例都存在一份单独的Function引用，我们的目的其实是想共用这个方法。（其实不太懂）2、超类型原型中定义的方法，在子类型实例中是无法调用到。 3、组合式继承123456789101112131415function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this); //第二次调用SuperClass&#125;SubClass.prototype = new SuperClass(); //第一次调用SuperClassvar sub1 = new SubClass();console.log(sub1.sayWhat());//hello 这个常用，寄生组合式继承就不写了，想了解的看原文。据说有寄生组合式继承的插件。 但是：这个模式调用了两次超类型的构造函数。 下面是我自己项目中的一段代码：MstBall继承了Missile 1234567891011121314151617181920212223/**组合式继承实现MasterBall这个类*/function MstBall(option)&#123; //经典继承 Missile.call(this,option);&#125;//原型继承MstBall.prototype = new Missile();//重写create方法MstBall.prototype._create = function() &#123; var mstBall = $(\"&lt;div class='missile \"+this.config.className+\"'&gt;\"); mstBall.css(&#123; width:this.config.width, height:this.config.height, transform:\"translate(\"+this.config.pos.x+\"px,\"+this.config.pos.y+\"px)\" &#125;); this.missile=mstBall; //console.log(this.missile) GameConfig.gameBox.append(this.missile); return this;&#125;; ES6中类和类的继承的写法123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 等同于parent.constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 等同于parent.toString() &#125;&#125; 参考链接 Browse blog参考链接 Browse blog ES6继承感觉像java中的的继承，规范了继承的操作。 最后，写点剑锋的东西，虽然最后被拉黑T_T 原型链作用域链demo1123456789//对name的访问, 哪种效率更高var name = '张三';function hello() &#123; console.log(name); console.log(window.name); console.log(this.name);&#125;hello(); 分析： 原型链特点 支持了面向对象开发模式 显示原型指针prototype, 任何函数都有(除了特殊Empty函数) 隐式原型指针__proto__, 任何对象都有(除了null, undefined, NaN) 特殊空函数只有__proto__ Object的原型对象的__proto__指向null 12345678Function instanceof Object //任何对象都是Object的实例Object instanceof Function //任何函数都是Function的实例Date.__proto__ === Function.prototypeFunction.__proto__ === Function.prototype","comments":true,"tags":[]},{"title":"学习md语法 ---爱不释手","date":"2017-03-03T08:51:40.000Z","path":"2017/03/03/secondArticle/","text":"这篇文章就测试下md的语法把！ 这是大标题这是小标题1$ 这里面放代码 这里放超链接: Writing 下面是插入图片 这里也是图片 1![不支持](/assets/blogImg/touxiang.png&#123;100x100&#125; \"测试图片并且定义宽高\") 1![不支持](/assets/blogImg/touxiang.png =100x100 \"测试图片并且定义宽高\") 1$ http://wowubuntu.com/markdown/basic.html 什么也不说了，爽爆了，感觉比博客园之类的写博客好多了在博客园写博客想要好的样式，还必须用第三方工具，我记得是writerlive之类的；现在感觉太棒了！！下面这幅图是用截图工具处理的。。。。 1基本可以应付了。 步骤123hexo new title //默认问post布局，title改为你的文章名似乎还待加一句 $ hexo generate //生成静态文件hexo deploy","comments":true,"tags":[]},{"title":"用hexo制作博客","date":"2017-03-02T14:32:55.508Z","path":"2017/03/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]