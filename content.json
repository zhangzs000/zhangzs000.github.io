[{"title":"集群","date":"2022-07-30T09:20:28.000Z","path":"2022/07/30/集群/","text":"nginx 配置集群123456789upstream servers &#123; server 127.0.0.1:3000; server 127.0.0.1:4000; server 127.0.0.1:5000;&#125;location /api &#123; proxy_pass http:servers;&#125; 减少服务器，提高并发量提高单机每秒并发访问 做好数据库优化，建索引；配主从读写分离和数据库集群；优化主外键字段；事物优化； 充分利用缓存，couchBase memcached redis mongodb 内存式数据库，或者 缓存服务； 优化TCP 参数，JVM 参数， 内存分配； k8s Kubermetes 可以看作是用来部署镜像的平台； 操作多台服务器，调度部署镜像； k8s 更容易部署集群。k8s 里面有个 proxy，就不用配置servers 了。","comments":true,"tags":[]},{"title":"渲染方式","date":"2021-11-21T23:14:38.000Z","path":"2021/11/22/渲染方式/","text":"","comments":true,"tags":[]},{"title":"虚拟列表","date":"2021-07-05T23:00:08.000Z","path":"2021/07/06/虚拟列表/","text":"","comments":true,"tags":[]},{"title":"信息安全","date":"2021-06-27T22:58:40.000Z","path":"2021/06/28/信息安全/","text":"","comments":true,"tags":[]},{"title":"前端监控","date":"2021-06-10T22:19:33.000Z","path":"2021/06/11/前端监控/","text":"","comments":true,"tags":[]},{"title":"微前端应用","date":"2021-05-28T23:23:00.000Z","path":"2021/05/29/微前端应用/","text":"","comments":true,"tags":[]},{"title":"有意思的问题","date":"2021-05-28T23:21:32.000Z","path":"2021/05/29/有意思的问题/","text":"生活中常见的问题 计算器 汉诺塔 24点 9连环 计算器平时支持 +-x/ 的简单计算器是如何计算的 粗糙的做法 eval() 栈 编译原理 逆波兰计算器 栈 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;string&#125; s * @return &#123;number&#125; */var calculate = function(s) &#123; let i=0; let len = s.length; let pre = &apos;+&apos;; let num = 0; let q =[]; while(i&lt;len)&#123; let c = s[i]; if(!isNaN(c) &amp;&amp; c!==&apos; &apos;)&#123; num = num*10 + Number(c) &#125; if(isNaN(c) || i=== len - 1) &#123; if(pre === &apos;+&apos;)&#123; q.push(num) pre = c; num = 0; &#125; else if(pre === &apos;-&apos;)&#123; q.push(-num ) pre = c; num = 0; &#125; else if(pre === &apos;*&apos;)&#123; q.push( q.pop() * num ) pre = c; num = 0; &#125; else if(pre === &apos;/&apos;)&#123; // 取整 q.push( q.pop() / num | 0 ) pre = c; num = 0; &#125; &#125; i++ &#125; return q.reduce((a,b)=&gt;a+b, 0)&#125;; 双栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131分析：使用栈完成表达式的计算思路1.通过一个index值(索引) ,来遍历我们的表达式2.如果我们发现是一个数字,就直接入数栈3.如果发现扫描到是一个符号,就分如下情况3.1如果发现当前的符号栈为空，就直接入栈3.2如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数在从符号栈中pop出-一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈4.当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行。5. 最后在数栈只有一个数字，就是表达式的结果const priority = (oper) =&gt; &#123; if (oper === &quot;*&quot; || oper == &quot;/&quot;) &#123; return 1; &#125; else if (oper === &quot;+&quot; || oper === &quot;-&quot;) &#123; return 0; &#125; else &#123; return -1; //假定目前的表达式只有+，-，*，/ &#125; &#125;; const isOper = (val) =&gt; &#123; return val === &quot;+&quot; || val === &quot;-&quot; || val === &quot;*&quot; || val === &quot;/&quot;; &#125;; const cal = (num1, num2, oper) =&gt; &#123; let res = 0; // res用于存放汁算的拮果 switch (oper) &#123; case &quot;+&quot;: res = num1 + num2; break; case &quot;-&quot;: res = num2 - num1; break; case &quot;*&quot;: res = num1 * num2; break; case &quot;/&quot;: res = num2 / num1; break; default: break; &#125; return res; &#125;; const calculator = () =&gt; &#123; let expression = &quot;70+2*6-4&quot;; // 15//如何处理多位数的问题? //创建两个栈，数栈，一个符号栈 let numStack = []; let operStack = []; //定义需要的相关变量 let index = 0; //用于扫描 let num1 = 0; let num2 = 0; let oper = 0; let res = 0; let ch = &quot;&quot;; //将每次扫描得到char保存到ch let keepNum = &quot;&quot;; // 数字拼接 //开始while循环的扫描expression while (true) &#123; //依次得到expression的每个字符 ch = expression.slice(index, index + 1); //判断ch是什么，然后做相应的处理 if (isOper(ch)) &#123; //如果是运算符 //判断当前的符号栈是否为空 if (operStack.length) &#123; //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数, //在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 if (priority(ch) &lt;= priority(operStack[operStack.length - 1])) &#123; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); //然后将当前的操作符入符号栈 operStack.push(ch); &#125; else &#123; //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。 operStack.push(ch); &#125; &#125; else &#123; //如果为空直接入符号栈.. operStack.push(ch); &#125; &#125; else &#123; //如果是数，则直接入数栈 //处理多位数 keepNum += ch; //如果ch已经是expression的最后一位,就直接入栈 if (index == expression.length - 1) &#123; numStack.push(Number(keepNum)); &#125; else &#123; //判断下一个字符是不是数字，如果是数字，就继续扫描,如果是运算符，则入栈 //注意是看后一位，不是index++ if ( isOper(expression.slice(index + 1, index + 2)) ) &#123; //如果后一 位是运算符，则入栈keepNum =“1&quot; 或者“123&quot; numStack.push(Number(keepNum)); //重要的!!!!!, keepNum清空 keepNum = &quot;&quot;; &#125; &#125; &#125; //让index + 1,并判断是否扫描到expression最后。 index++; if (index &gt;= expression.length) &#123; break; &#125; &#125; //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号,并运行。 while (true) &#123; //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字[结果] if (!operStack.length) &#123; break; &#125; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = cal(num1, num2, oper); numStack.push(res); //入栈 &#125; //将数栈的最后数，pop出，就是结果 let res2 = numStack.pop(); console.log(&quot;表达式&quot;, expression, res2); &#125;; calculator() 编译原理 分词 12345678910111213141516171819202122// 方法一：正则匹配while (true) &#123;// 每次循环匹配出相应的 token let result = RegExpObject.exec(script); ... 略 ... &#125;// 方法二：有限状态机function start(char) &#123; if (char === &quot;&lt;&quot;) &#123; emit(&#123; type: tokenTypes.LeftParentheses, value: &quot;&lt;&quot; &#125;); return foundLeftParentheses; //找到了 &lt; &#125;&#125;function foundLeftParentheses(char) &#123; ... 略 ...&#125;... 略 ..let state = start;for (let char of input) &#123; if (state) state = state(char);&#125; 语法分析，描述了代码语句中的每一个片段以及它们之间的关系或者 AST 123456789101112131415161718// 语法规则 进阶 巴科范式add -&gt; multiple |multiple + addmultiple -&gt; NUMBER | NUMBER * multiple// 算法： 递归向下，从外层往内层下降function toAST(tokenReader) &#123; ... 略 ... let child = additive(tokenReader); // 能推导出来，就 push ... 略 ...&#125;function additive(tokenReader) &#123; let child1 = minus(tokenReader); ... 略 ... let child2 = additive(tokenReader); ... 略 ...&#125;... 略 ... 根据AST递归计算(很多相似结构) 逆波兰计算器1https://www.youtube.com/watch?v=635SxlJgq7I&amp;list=PLmOn9nNkQxJFvyhDYx0ya4F75uTtUHA_f&amp;index=36 汉诺塔递归12345678910111213141516// 分治算法const hanoiTower = (num, a, b, c) =&gt; &#123; //如果只有一个盘 if (num == 1) &#123; console.log(&quot;第1个盘从&quot; + a + &quot;-&gt;&quot; + c); &#125; else &#123; //如果我们有n &gt;= 2情况,我们总是可以看做是两个盘1.最下边的一个盘2.上 面的所有盘 //1.先把最上面的所有盘A-&gt;B，移动过程会使用到C hanoiTower(num - 1, a, c, b); //2.把最下边的盘A-&gt;C console.log(&quot;第&quot; + num + &quot;个盘从&quot; + a + &quot;-&gt;&quot; + c); //3.把B塔的所有盘从B-&gt;C，移动过程使用到a塔 hanoiTower(num - 1, b, a, c); &#125;&#125;;console.log(hanoiTower(3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)); 24点判断是否可以通过运算得到 241234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var judgePoint = function (nums) &#123; if (nums.length == 1) return Math.abs(nums[0] - 24) &lt; 1e-6; for (let i = 0; i &lt; nums.length; i++) for (let j = i + 1; j &lt; nums.length; j++) &#123; let rest = nums.filter((value, index) =&gt; index != i &amp;&amp; index != j); if (judgePoint([nums[i] + nums[j], ...rest]) || judgePoint([nums[i] * nums[j], ...rest]) || judgePoint([nums[i] - nums[j], ...rest]) || judgePoint([nums[j] - nums[i], ...rest]) || judgePoint([nums[i] / nums[j], ...rest]) || judgePoint([nums[j] / nums[i], ...rest])) return true; &#125; return false;&#125; 列举所有可以得到 24的结果 思路：先计算 a, b 再组合 c，d; 要保证a,b,c,d都计算到，则需要计算a,b,c,d; a,c,b,d; a,d,c,b; b,c,a,d; b,d,c,a; c,d,b,a; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function dataWarp(...num) &#123; return num.map((a) =&gt; (&#123; m: a, r: a &#125;));&#125;function calm(a,b) &#123; var r = [ &#123; m: `($&#123;a.m&#125;+$&#123;b.m&#125;)`, r: a.r+b.r &#125;, &#123; m: `($&#123;a.m&#125;-$&#123;b.m&#125;)`, r: a.r-b.r &#125;, &#123; m: `($&#123;b.m&#125;-$&#123;a.m&#125;)`, r: b.r-a.r &#125;, &#123; m: `($&#123;a.m&#125;*$&#123;b.m&#125;)`, r: a.r*b.r &#125;, ]; a.r !== 0 &amp;&amp; r.push(&#123; m: `($&#123;b.m&#125;/$&#123;a.m&#125;)`, r: b.r/a.r &#125;); b.r !==0 &amp;&amp; r.push(&#123; m: `($&#123;a.m&#125;/$&#123;b.m&#125;)`, r: a.r/b.r &#125;); return r;&#125;function allCalm(a,b,c,d,u) &#123; var s = [], t = []; calm(a,b).forEach((i) =&gt; &#123; s = s.concat(calm(i, c)); t = t.concat(calm(i, d)); &#125;); s.forEach((i) =&gt; &#123; u = u.concat(calm(i, d)); &#125;); t.forEach((i) =&gt; &#123; u = u.concat(calm(i, c)); &#125;); return u;&#125;function get24(a,b,c,d) &#123; [a,b,c,d]= dataWarp(a,b,c,d); allCalm(c,d,b,a,allCalm(b,d,a,c,allCalm(b,c,a,d,allCalm(a,d,b,c,allCalm(a,c,b,d,allCalm(a,b,c,d,[])))))).forEach((i) =&gt; &#123; if (i.r === 24) &#123; console.log(i.m); &#125; &#125;);&#125;","comments":true,"tags":[]},{"title":"编译器工作原理","date":"2021-05-28T23:19:02.000Z","path":"2021/05/29/编译器工作原理/","text":"[TOC]","comments":true,"tags":[]},{"title":"扎记","date":"2021-05-18T16:48:00.000Z","path":"2021/05/19/扎记1/","text":"题目 响应浏览器事件 展示当前浏览器窗口的宽高，并在窗口 resize 后实时反馈： 笔试 我当时的思路大体这样的： 1234567891011121314151617181920212223242526272829303132333435const throttle = (fn, time)=&gt;&#123; let timer = null; return (...args)=&gt;&#123; if(!timer)&#123; timer = setTimeout(()=&gt;&#123; fn.apply(this, args); timer = null &#125;, time) &#125; &#125;&#125;const useResize = (props)=&gt;&#123; const [p, setP] = useState(&#123;...props&#125;); const fn = function(e)&#123; setP(&#123;width: e.clientWidth, height: e.clientHeight&#125;) &#125; useEffect(()=&gt;&#123; window.onresize= throttle(fn, 100); return ()=&gt;&#123; window.onresize=null; &#125; &#125;, []) return [&#123;width: p.width, height: p.height&#125;, setP]&#125;const resizeComponent = ()=&gt;&#123; const [data, SetData] = useResize(&#123;width: 1, height: 1&#125;) return &lt;div&gt;&#123;data.width&#125; &#123;data.height&#125;&lt;/div&gt;&#125; 项目中 项目中是真实用到的，因为播放器的宽会随着屏幕变化 思考 涉及到一个实验中(Experimental)的 api: ResizeObserver，所以会涉及到兼容 参考链接：https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver 文中这样描述‘ResizeObserver避免了在自身回调中调整大小，从而触发的无限回调和循环依赖。它仅通过在后 续帧中处理DOM中更深层次的元素来实现这一点。’ 还跟浏览器渲染有点关系window.requestAnimationFrame 还跟react的合成事件有点关系，e.persist() 阻止重新设置事件的属性。 参考链接：https://reactjs.org/docs/legacy-event-pooling.html 实现 throttle 这个网上很多 123export const throttle = &lt;T extends any[]&gt;(func: (...arg: T) =&gt; void, delay = 0, flush = true) =&gt; &#123; .... 略 ...&#125;; 判断是否支持 ResizeObserver 123export function isSupported() &#123; return isBrowser() &amp;&amp; window.ResizeObserver &amp;&amp; typeof ResizeObserver === &apos;function&apos;;&#125; 工具函数 resizeHelper.js 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const resizeListeners = new Map&lt;Element | SVGElement, (rect: DOMRectReadOnly) =&gt; void&gt;();const observer = isSupported() ? new ResizeObserver(entries =&gt; &#123; ... 略... entries.forEach(entry =&gt; &#123; if (resizeListeners.has(entry.target)) &#123; resizeListeners.get(entry.target)!(entry.contentRect); &#125; &#125;); ... 略... &#125; : (() =&gt; &#123; let timer: any; const initTimer = () =&gt; &#123; timer = setInterval(() =&gt; &#123; ... 略... Array.from(resizeListeners.keys()).forEach((element: Element | SVGElement) =&gt; &#123; resizeListeners.get(element)!(element.getBoundingClientRect()); &#125;); &#125;, 500); &#125;; return &#123; observe() &#123; if (!timer) &#123; initTimer(); &#125; &#125;, unobserve() &#123; if (resizeListeners.size === 0 &amp;&amp; timer) &#123; clearInterval(timer); timer = null; &#125; &#125; &#125;; &#125;)();export default &#123; observe(element: Element | SVGElement, cb: (rect: DOMRectReadOnly) =&gt; void) &#123; if (!resizeListeners.has(element)) &#123; observer.observe(element); logger.debug(element, &apos;绑定resize事件&apos;); &#125; resizeListeners.set(element, throttle(cb, 200)); &#125;, unobserve(element: Element | SVGElement) &#123; if (resizeListeners.has(element)) &#123; observer.unobserve(element); logger.debug(element, &apos;解除resize事件&apos;); &#125; resizeListeners.delete(element); &#125;&#125;; 播放器使用 12345678910111213componentDidMount() &#123; if (this.container.current) &#123; if (isSupported()) &#123; ... 略... resizeHelper.observe(this.container.current, rect =&gt; &#123; this.setSize(rect.width); &#125;); &#125; &#125;&#125; 扩展MutationObserver MutationObserver 监视对DOM树所做更改的能力。包括 增加/删除 子元素，修改子元素属性。 MutationObserver 属于微任务。 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver12345..... 略 .....const observer = new MutationObserver(callback);// 以上述配置开始观察目标节点observer.observe(targetNode, config); IntersectionObserver IntersectionObserver一种异步检测目标元素与祖先元素或 viewport 相交情况变化的方法。 可以实现图片懒加载——当图片滚动到可见时才进行加载 属于轮询？ 12345678910// 实现图片懒加载// 原理，底部的div可见就调用函数observer = new IntersectionObserver(changes =&gt; &#123; changes.forEach(change =&gt; &#123; if (change.target == bottomRef.current &amp;&amp; change.isIntersecting) &#123; !stop &amp;&amp; nextPageFunc &amp;&amp; nextPageFunc(); &#125; &#125;); &#125;); observer.observe(bottomRef.current); 通过 IntersectionObserver 实现滑动到底部自动翻页 思考： 底部设置一个dom 元素 xx ，进入视口就加载下一页 封装一个公共组件 ScrollWrap ，异步列表做为组件的children ScrollWrap 每次重新渲染，是因为 xx 进入视口，请求下一页数据，假如每次都要创建 observer 对象，那什么时候应该销毁 observer 对象。(其实想想可以通过单例仅仅创建一个observer 对象)123456789101112131415161718192021222324252627282930313233343536373839404142434445// 相关变量 page， page变化创建新的 observer// useEffect 返回函数销毁上次 observer// 下一页没数据的时候，销毁上次 observer// 暴露一个获取下一页的 callbacklet observer!: IntersectionObserver;const bottomRef = React.createRef&lt;HTMLDivElement&gt;();const ScrollWrap = (&#123; children, page, nextPageFunc, stop &#125;: &#123; children: any; page: number; nextPageFunc: Function; stop?: boolean &#125;) =&gt; &#123; useEffect(() =&gt; &#123; if (!stop) &#123; observer = new IntersectionObserver(changes =&gt; &#123; changes.forEach(change =&gt; &#123; // console.error(&apos;scroll&apos;, stop, page, change, observer); if (change.target == bottomRef.current &amp;&amp; change.isIntersecting) &#123; !stop &amp;&amp; nextPageFunc &amp;&amp; nextPageFunc(); &#125; &#125;); &#125;); if (bottomRef.current) &#123; observer.observe(bottomRef.current); &#125; &#125; else &#123; observer?.disconnect(); &#125; return () =&gt; &#123; observer?.disconnect(); &#125;; &#125;, [stop, page]); return ( &lt;div className=&#123;css.siteScrollWrap&#125;&gt; &#123;children&#125; &lt;div className=&#123;css.more&#125; onClick=&#123;e =&gt; &#123; e.stopPropagation(); e.preventDefault(); !stop &amp;&amp; nextPageFunc &amp;&amp; nextPageFunc(); &#125;&#125; &gt; &#123;stop ? &apos;&apos; : &apos;--- 查看更多 ---&apos;&#125; &lt;/div&gt; &lt;div className=&#123;css.listBottom&#125; ref=&#123;bottomRef&#125;&gt;&lt;/div&gt; &lt;/div&gt; );&#125;; 上面那个还涉及到 page 这个参数该不该传的问题，跟如何去更新 page有关，hooks?变量?reducer? 另一种思路： 单例创建 observer ，无数据时销毁 observer 扩展思考： 这种写法难道不是观察者模式吗？ 它内部的实现可能类似下面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104function myObserver()&#123; const observer = (obj, targetVariable, callback)=&gt; &#123; Object.defineProperty(obj, targetVariable, &#123; get() &#123; return this.data[targetVariable] &#125;, set(val) &#123; this.data[targetVariable] = val // 目标主动通知观察者 callback &amp;&amp; callback(val) &#125;, &#125;) if (obj.data[targetVariable]) &#123; callback &amp;&amp; callback(obj.data[targetVariable]) &#125; &#125; const disconnect = (obj, targetVariable)=&gt;&#123; // 怎么把 descriptor.writable: false &#125; return &#123; observer, disconnect &#125; &#125; let myOber = new myObserver() // 目标 const obj = &#123; data: &#123; description: &apos;原始值&apos; &#125;, &#125; // 观察者 myOber.observer(obj, &apos;description&apos;, value =&gt; &#123; const div = document.createElement(&apos;div&apos;); div.innerHTML = value document.body.appendChild(div) &#125;) setInterval(()=&gt;&#123; obj.description = &apos;改变了对象的值&apos;+Math.random() &#125;, 1000)var New =function(fn)&#123; var obj=&#123;&#125;; obj.__proto__=fn.prototype; // 将 arguments 对象转为数组 var args = [].slice.call(arguments, 1); // 执行构造函数并改变this对象 var result = fn.apply(obj, args); return result instanceof Object ? result : obj&#125; // 比较常见的观察者模式//观察者列表function ObserverList()&#123; this.observerList = [];&#125;ObserverList.prototype.add = function( obj )&#123; return this.observerList.push( obj );&#125;;ObserverList.prototype.count = function()&#123; return this.observerList.length;&#125;;ObserverList.prototype.get = function( index )&#123; if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length )&#123; return this.observerList[ index ]; &#125;&#125;;ObserverList.prototype.indexOf = function( obj, startIndex )&#123; var i = startIndex; while( i &lt; this.observerList.length )&#123; if( this.observerList[i] === obj )&#123; return i; &#125; i++; &#125; return -1;&#125;;ObserverList.prototype.removeAt = function( index )&#123; this.observerList.splice( index, 1 );&#125;;//目标function Subject()&#123; this.observers = new ObserverList();&#125;Subject.prototype.addObserver = function( observer )&#123; this.observers.add( observer );&#125;;Subject.prototype.removeObserver = function( observer )&#123; this.observers.removeAt( this.observers.indexOf( observer, 0 ) );&#125;;Subject.prototype.notify = function( context )&#123; var observerCount = this.observers.count(); for(var i=0; i &lt; observerCount; i++)&#123; this.observers.get(i).update( context ); &#125;&#125;;//观察者function Observer()&#123; this.update = function()&#123; // ... &#125;;&#125;","comments":true,"tags":[]},{"title":"vscode调试xxx.js","date":"2021-05-18T16:46:09.000Z","path":"2021/05/19/vscode调试xxx-js/","text":"","comments":true,"tags":[]},{"title":"youtube札记","date":"2020-11-09T02:15:44.000Z","path":"2020/11/09/youtube札记/","text":"并查集(Disjoint-set)： 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。 主要操作 查找(Find)：查找元素所在的集合，即根节点。 合并(Unit)：将两个元素所在的集合合并为一个集合。 例题：检测无向图图中是否有环？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const checkCycle = ()=&gt;&#123; let paths = [[0,1],[1,2],[2, 5],[2, 4],[1, 3],[3, 4]]; // 初始化 // 添加注意初始化数组的长度跟节点个数n有关系，防止出现undefined。 let arr = new Array(6).fill(-1); let rank = new Array(6).fill(0); // 错误，是在unit 合并时才集合链 // const init= (paths, arr)=&gt;&#123; // paths.forEach(([x,y])=&gt;&#123; // arr[x] = y // &#125;) // &#125; const findParent= (x)=&gt;&#123; let p = x; while(arr[p]!==-1)&#123; p = arr[p] &#125; return p &#125; // 是否合并,连接起来 const unit = (x, y, arr)=&gt;&#123; let x_p = findParent(x); let y_p = findParent(y); // 父节点相同，说明已经链接起来了 if(x_p === y_p) return false else &#123; if(rank[x_p]&gt;rank[y_p]) &#123; arr[y_p] = x_p &#125; else if(rank[x_p]&lt;rank[y_p])&#123; arr[x_p] = y_p &#125; else &#123; rank[y_p]++ // unit 合并时才生成链 arr[x_p] = y_p &#125; return true &#125; &#125; // init(paths, arr) for(let [x, y] of paths)&#123; // 无需合并存在圈 if(!unit(x, y, arr)) &#123; return true &#125; &#125; return false&#125;console.log(checkCycle()) 堆排序 heapSort 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 初始化堆复杂度O(n), 堆排序复杂度O(n*logn)。 完全二叉树：生成节点的顺序是从上到下，从左到右的顺序进行编号。与满二叉树中编号，在二叉树中的位置相同。 大顶堆： 父节点值&gt;子节点值，且为完全二叉树。 例题：初始化大顶堆？排序时重写构建大顶堆？ 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let heap = ()=&gt;&#123; const swap = (tree, a, b)=&gt;&#123; if(a === b) return let tmp = tree[a]; tree[a] = tree[b]; tree[b] = tmp &#125;// O(logn) const heapify = (tree, n, i)=&gt;&#123; if(i&gt;=n) return let c1 = 2*i+1; let c2 = 2*i+2; let max = i; if(c1&lt;n &amp;&amp; tree[c1]&gt;tree[max])&#123; max = c1 &#125; if(c2&lt;n &amp;&amp; tree[c2]&gt;tree[max])&#123; max = c2 &#125; if(max !==i)&#123; swap(tree, max, i) heapify(tree, n, max) &#125; &#125;// 这个构建堆也应该是 nlog(n) const buildHeap = (tree, n)=&gt;&#123; // 最末尾节点索引 let lastNode = n-1; // 最末尾父节点开始向上 heapify let parent = Math.floor((lastNode-1)/2); for(let i=parent; i&gt;=0; i--)&#123; heapify(tree, n, i) &#125; &#125; const heapSort = (tree, n)=&gt;&#123; buildHeap(tree, n); for(let i=n-1; i&gt;=0; i--)&#123; // 顶点和末尾交换 swap(tree, i, 0) heapify(tree, i, 0) &#125; console.log(&apos;sort: &apos;,tree) &#125; let tree = [4, 10, 3, 5, 1, 2,6, 7, 8]; let n=9; // 构建二叉树 结果1 buildHeap(tree, n)// 堆排序 结果2 heapSort(tree, n) console.log(&apos;tree: &apos;,tree)&#125; // 结果1// 结果2 heapSort2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class MaxHeap &#123; // 数组索引决定堆的排列，所以只是交换索引对应的值 arr = []; left(i)&#123; return i*2+1 &#125; right(i)&#123; return i*2+2 &#125; parent(i)&#123; return Math.floor((i-1)/2) &#125; swap(i, j)&#123; if(i===j) return; let tmp = this.arr[i]; this.arr[i] = this.arr[j]; this.arr[j] = tmp &#125; // 保证坐标i要不断下沉 sink(i)&#123; let len = this.arr.length; // 或运算时短路求值 while(this.left(i)&lt;len || this.right(i)&lt;len)&#123; let max = this.arr[i], m = i, l = this.left(i), r = this.right(i); if(this.arr[l]&gt;=max) &#123; max = this.arr[l] m = l &#125; if(this.arr[r]&gt;=max) &#123; max = this.arr[r] m = r &#125; // i===m 说明顺序对，不必下沉，避免死循环 if(i===m) break this.swap(i, m) i = m; &#125; &#125; // 保证i能持续上浮，i的兄弟不管 swim(i)&#123; let p; // i &gt; 0 能避免掉初始数组是 空 的情况, 还有 this.parent(0) undefind 情况。 while(i&gt;0 &amp;&amp; (this.arr[p = this.parent(i)]&lt;=this.arr[i]))&#123; this.swap(i, p) i=p; &#125; &#125; // 放入末尾，然后上浮 insert(v)&#123; this.arr.push(v) this.swim(this.arr.length-1) &#125; delMax()&#123; let max = this.arr[0]; this.swap(0, this.arr.length-1); this.arr.pop() this.sink(0) return max; &#125;&#125;var findKthLargest = function(nums, k) &#123; let maxheap = new MaxHeap(); nums.forEach(n=&gt;maxheap.insert(n)) console.log(&apos;xx: &apos;,maxheap.arr)let r;let sr = []; while(k--)&#123; r = maxheap.delMax()sr.unshift(r)&#125;console.log(‘sr: ’, sr)return r&#125;;let nums = [4, 10, 3, 5, 1, 2,6, 7, 8];let k=9;console.log(findKthLargest(nums, k)) // xx 的结果// sr 结果 最短路径 Dijkstra 是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。 例题： 遍历graph， a到各个点的最短距离： 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let graph=&#123; &apos;a&apos;: &#123;&apos;b&apos;:5, &apos;c&apos;:1&#125;, &apos;b&apos;: &#123;&apos;a&apos;:5, &apos;c&apos;:2, &apos;d&apos;:1&#125;, &apos;c&apos;: &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;d&apos;:4, &apos;e&apos;:8&#125;, &apos;d&apos;: &#123;&apos;b&apos;:1, &apos;c&apos;:4, &apos;e&apos;:3, &apos;f&apos;:6&#125;, &apos;e&apos;: &#123;&apos;c&apos;:8, &apos;d&apos;:3&#125;, &apos;f&apos;: &#123;&apos;d&apos;:6&#125;&#125;const distance = (s)=&gt;&#123; let d = &#123;[s]:0&#125;; for(let k in graph)&#123; if(k!==s)&#123; d[k]=Infinity &#125; &#125; return d&#125;const dijkstra = (s)=&gt;&#123; let q = new MinPriorityQueue(&#123; priority: (turn) =&gt; turn.value &#125;) q.enqueue(&#123; name: s, value: 0 &#125;) let visited = new Set(); let parent = &#123;[s]:-1&#125;; let d = distance(s); while(q.size())&#123; const &#123; priority: p, element: e&#125; = q.dequeue(); let en = e.name; visited.add(en); let ns = Object.keys(graph[en]); ns.forEach(n=&gt;&#123; // 相邻边必然存在已经访问过的，所有要过滤 if(!visited.has(n))&#123; // p en节点的最短距离 let np = p + graph[en][n] if(np &lt; d[n])&#123; // 这样就可能存在距离不同的，多个重复名字的点 q.enqueue(&#123; name: n, value: np &#125;) parent[n] = en; d[n] = np &#125; &#125; &#125;) &#125; return [parent, d]&#125;let [p, d] = dijkstra(&apos;a&apos;);console.log(&apos;parent: &apos;,p)console.log(&apos;distance: &apos;, d) BFS 123456789101112131415161718192021222324252627let graph=&#123; &apos;a&apos;: [&apos;b&apos;, &apos;c&apos;], &apos;b&apos;: [&apos;a&apos;, &apos;c&apos;, &apos;d&apos;], &apos;c&apos;: [&apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;], &apos;d&apos;: [&apos;b&apos;, &apos;c&apos;, &apos;e&apos;, &apos;f&apos;], &apos;e&apos;: [&apos;c&apos;, &apos;d&apos;], &apos;f&apos;: [&apos;d&apos;]&#125;const bfs = (s)=&gt;&#123; let q = [s]; let v = new Set(); while(q.length)&#123; let n = q.shift(); v.add(n) let ns = graph[n]; ns.forEach(n=&gt;&#123; if(!v.has(n))&#123; q.push(n) &#125; &#125;) &#125; console.log(&apos;r: &apos;, [...v])&#125;console.log(bfs(&apos;a&apos;))// 结果r: (6) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] DFS1 12345678910111213141516171819const dfs = (s)=&gt;&#123; let stack = [s]; let v = new Set(); while(stack.length)&#123; let n = stack.pop(); v.add(n) let ns = graph[n]; ns.forEach(n=&gt;&#123; if(!v.has(n))&#123; stack.push(n) &#125; &#125;) &#125; console.log(&apos;r: &apos;, [...v])&#125;console.log(dfs(&apos;a&apos;))// 结果r: (6) [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;d&quot;, &quot;f&quot;, &quot;b&quot;] DFS2 1234567891011121314151617181920let v = new Set();const dfs = (s, v) =&gt;&#123; if(!s)&#123; return &#125; v.add(s); console.log(&apos;前序r: &apos;, [...v]); let ns = graph[s] if(ns.length) &#123; ns.forEach(n=&gt;&#123; if(!v.has(n))&#123; dfs(n, v) &#125; &#125;) &#125; &#125;console.log(dfs(&apos;a&apos;, v))// 结果 前序r: (6) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 线段树 线段树，线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 例题：随机取数组连续一部分求和，随机修改 的复杂度。 Query O(n) =&gt; O(logn) Update O(logn) 动态规划 DP(Dynamic Programming) Fibonacci sequence,O(2^n) =&gt; O(n) 这么个思想。 爬楼梯 背包9讲 KMP 字符串匹配算法 根据前缀和后缀相同，匹配完第一轮，匹配第二轮时看能不能直接匹配后缀。 复杂度 O(m+n) 步骤 1.求出前缀表。 当下个字符匹配时： len 目前达到的最长公共前缀的长度，比较长度； i 是prefix数组当前的索引，prefix[0]=0, i从第一个字母比较； 当下一个不匹配时： 为了好计算，prefix整体右移，将prefix[0] = -1， 1234567891011121314151617181920212223242526272829303132333435function prefix_table(pattern, prefix, n) &#123; prefix[0] = 0; let len = 0; let i= 1; while(i&lt;n)&#123; if( pattern[i] == pattern[len] ) &#123; len++; prefix[i] = len; i++; &#125; else &#123; if(len&gt;0)&#123; len = prefix[len - 1]; &#125; else &#123; // len === 0 prefix[i] = len; i++; &#125; &#125; &#125;&#125;function move_prefix_table(prefix, n) &#123; for (let i=n-1; i&gt;0; i--)&#123; prefix[i] = prefix[i-1]; &#125; prefix[0] = -1;&#125;let pattern = &quot;ABABCABAA&quot;;let prefix = new Array(9);let n=9;// 下面这2个api可通用prefix_table(pattern, prefix, n);move_prefix_table(prefix, n);console.log(&apos;prefix: &apos;,prefix) 2.开始匹配： 相同 i++, j++； 不相同如下图： j 从指向4C，指向2A, 1234567891011121314151617181920212223242526272829303132333435 let pattern = &quot;ABABCABAA&quot;;let text = &quot;ABABABCABAABABABABA&quot;; // 2// let text = &quot;ABABABABCABAAB&quot;; // 4function kmp_search(text, pattern)&#123; let n = pattern.length; let m = text.length; let prefix = new Array(n); let i=0; let j=0; prefix_table(pattern, prefix, n); move_prefix_table(prefix, n); // text[i] , len(text), = m // pattern[j] , len(pattern) = n while(i &lt; m)&#123; if (j==n - 1 &amp;&amp; text[i] == pattern[j]) &#123; console.log(&quot;Found pattern&quot;, i - j); // 找到后，继续往下匹配，看还有没有 j = prefix[j]; &#125; if (text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = prefix[j]; if(j==-1)&#123; i++; j++; &#125; &#125; &#125;&#125;kmp_search(text, pattern)// 结果应该是2 参考例题：https://leetcode-cn.com/problems/implement-strstr/submissions/","comments":true,"tags":[]},{"title":"decorator","date":"2020-10-31T14:54:43.000Z","path":"2020/10/31/decorator/","text":"","comments":true,"tags":[]},{"title":"札记","date":"2020-08-30T14:48:44.000Z","path":"2020/08/30/札记/","text":"","comments":true,"tags":[]},{"title":"算法题","date":"2020-07-26T13:47:55.000Z","path":"2020/07/26/算法leetcode/","text":"概率最大的路径给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 示例 1： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2输出：0.25000解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25示例 2： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2输出：0.30000示例 3： 输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2输出：0.00000解释：节点 0 和 节点 2 之间不存在路径 提示： 2 &lt;= n &lt;= 10^40 &lt;= start, end &lt; nstart != end0 &lt;= a, b &lt; na != b0 &lt;= succProb.length == edges.length &lt;= 2*10^40 &lt;= succProb[i] &lt;= 1每两个节点之间最多有一条边 这个是一个关于“图的最短路径”问题。 可以考虑使用bfs+优先队列的方法，但是js没有PriorityQueue这种数据结构，可以粗略这样处理。 12345678910111213141516171819202122232425262728293031var maxProbability = function(n, edges, succProb, start, end) &#123; let vi = new Array(n).fill(false); let path = new Array(n) while(n--)&#123; path[n] = [] &#125; for (let i = 0; i &lt; edges.length; i++) &#123; let e = edges[i]; path[e[0]].push([succProb[i], e[1]]); path[e[1]].push([succProb[i], e[0]]); &#125; let pq = []; pq.push([ 1, start]); while (pq.length) &#123; let [curProb, cur] = pq.shift()// pq.pop(); pop是操作数组的后边 if (vi[cur]) continue; vi[cur] = true; if (cur == end) return curProb; let pp =path[cur]; for(let i=0; i&lt;pp.length; i++)&#123; let [nextProb, next] = pp[i]; if (vi[next]) continue; pq.push([curProb * nextProb, next]); // 9000多数据每次排序， ST算法，RMQ问题 | 堆 pq.sort((a, b)=&gt;b[0]-a[0]) &#125; &#125; return 0;&#125;; 但是这样处理的话，当测试用例的节点数达到 10000 时就会超时。 其实优先队列是Dijkstra算法 的一种优化，将时间复杂度从 O(n^2) 降到 O((m+n)logn)，m边数，n是顶点数。优先队列的内部似乎是斐波那契堆(Fibonacci heap)Fibonacci heap，这里不要求那么严格由于是要概率最大的路径，所以实现一个最大堆。 Dijkstra (Dijkstra)之优先队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203// 最大堆实现 https://github.com/datastructures-jsclass HeapNode &#123; constructor(key, value) &#123; this._key = key; this._value = value; &#125; getKey() &#123; return this._key; &#125; getValue() &#123; return this._value; &#125;&#125;class Heap &#123; constructor(nodes) &#123; this._nodes = Array.isArray(nodes) ? nodes : []; this._leaf = null; &#125; size() &#123; return this._nodes.length; &#125; _swap(i, j) &#123; const temp = this._nodes[i]; this._nodes[i] = this._nodes[j]; this._nodes[j] = temp; &#125; root() &#123; if (this.isEmpty()) return null; return this._nodes[0]; &#125; insert(key, value) &#123; const newNode = new HeapNode(key, value); this._nodes.push(newNode); this._heapifyUp(); return newNode; &#125; _getLeftChildIndex(parentIndex) &#123; return (parentIndex * 2) + 1; &#125; _getRightChildIndex(parentIndex) &#123; return (parentIndex * 2) + 2; &#125; _compareChildrenOf(parentIndex) &#123; const leftChildIndex = this._getLeftChildIndex(parentIndex); const rightChildIndex = this._getRightChildIndex(parentIndex); const size = this.size(); if (leftChildIndex &gt;= size &amp;&amp; rightChildIndex &gt;= size) return -1; if (leftChildIndex &gt;= size) return rightChildIndex; if (rightChildIndex &gt;= size) return leftChildIndex; return this._compareChildren(leftChildIndex, rightChildIndex); &#125; _heapifyUp() &#123; let childIndex = this._getLastIndex(); let parentIndex = this._getParentIndex(childIndex); while (this._shouldSwap(childIndex, parentIndex)) &#123; this._swap(childIndex, parentIndex); childIndex = parentIndex; parentIndex = this._getParentIndex(childIndex); &#125; &#125; _getLastIndex() &#123; return this._nodes.length - 1; &#125; _getParentIndex(childIndex) &#123; return Math.floor((childIndex - 1) / 2); &#125; _heapifyDown() &#123; let parentIndex = 0; let childIndex = this._compareChildrenOf(parentIndex); while (this._shouldSwap(childIndex, parentIndex)) &#123; this._swap(childIndex, parentIndex); parentIndex = childIndex; childIndex = this._compareChildrenOf(parentIndex); &#125; &#125; isEmpty() &#123; return this.size() === 0; &#125; extractRoot() &#123; if (this.isEmpty()) return null; const root = this.root(); this._nodes[0] = this._nodes[this._getLastIndex()]; this._nodes.pop(); this._heapifyDown(); if (root === this._leaf) &#123; if (this.isEmpty()) &#123; this._leaf = null; &#125; else &#123; this._leaf = this.root(); &#125; &#125; return root; &#125;&#125;class MaxHeap extends Heap &#123; _getMaxChildIndex(leftChildIndex, rightChildIndex) &#123; const leftChild = this._nodes[leftChildIndex]; const rightChild = this._nodes[rightChildIndex]; if (leftChild.getKey() &gt; rightChild.getKey()) &#123; return leftChildIndex; &#125; return rightChildIndex; &#125; _compareChildren(leftChildIndex, rightChildIndex) &#123; return this._getMaxChildIndex(leftChildIndex, rightChildIndex); &#125; _shouldSwap(childIndex, parentIndex) &#123; if (childIndex &lt; 0 || childIndex &gt;= this.size()) return false; if (parentIndex &lt; 0 || parentIndex &gt;= this.size()) return false; const child = this._nodes[childIndex]; const parent = this._nodes[parentIndex]; return child.getKey() &gt; parent.getKey(); &#125;&#125;class PriorityQueue &#123; constructor(options = &#123;&#125;) &#123; const &#123; priority &#125; = options; if (priority !== undefined &amp;&amp; typeof priority !== &apos;function&apos;) &#123; throw new Error(&apos;invalid priority callback&apos;); &#125; this._getPriority = typeof priority === &apos;function&apos; ? priority : null; &#125; size() &#123; return this._heap.size(); &#125; isEmpty() &#123; return this._heap.isEmpty(); &#125; enqueue(element, priority) &#123; if (priority &amp;&amp; (Number.isNaN(+priority))) &#123; throw new Error(&apos;invalid priority number&apos;); &#125; if (!priority &amp;&amp; this._getPriority === null) &#123; throw new Error(&apos;missing priority number or constructor callback&apos;); &#125; this._heap.insert(priority || this._getPriority(element), element); &#125; dequeue() &#123; if (this.isEmpty()) return null; const first = this._heap.extractRoot(); return &#123; priority: first.getKey(), element: first.getValue() &#125;; &#125;&#125;class MaxPriorityQueue extends PriorityQueue &#123; constructor(options) &#123; super(options); this._heap = new MaxHeap(); &#125;&#125;// 最小堆class MinHeap extends Heap &#123; insert(key, value) &#123; const newNode = super.insert(key, value); if (this._leaf === null || key &gt; this._leaf.getKey()) &#123; this._leaf = newNode; &#125; return newNode; &#125; _getMinChildIndex(leftChildIndex, rightChildIndex) &#123; const leftChild = this._nodes[leftChildIndex]; const rightChild = this._nodes[rightChildIndex]; if (leftChild.getKey() &lt; rightChild.getKey()) &#123; return leftChildIndex; &#125; return rightChildIndex; &#125; _compareChildren(leftChildIndex, rightChildIndex) &#123; return this._getMinChildIndex(leftChildIndex, rightChildIndex); &#125; _shouldSwap(childIndex, parentIndex) &#123; if (childIndex &lt; 0 || childIndex &gt;= this.size()) return false; if (parentIndex &lt; 0 || parentIndex &gt;= this.size()) return false; const child = this._nodes[childIndex]; const parent = this._nodes[parentIndex]; return child.getKey() &lt; parent.getKey(); &#125;&#125;class MinPriorityQueue extends PriorityQueue &#123; constructor(options) &#123; super(options); this._heap = new MinHeap(); &#125;&#125;let patientsQueue = new MinPriorityQueue(); 应用上面的最大堆 123456789101112131415161718192021222324252627282930var maxProbability = function(n, edges, succProb, start, end) &#123; let vi = new Array(n).fill(false); let path = new Array(n) while(n--)&#123; path[n] = [] &#125; for (let i = 0; i &lt; edges.length; i++) &#123; let e = edges[i]; path[e[0]].push([succProb[i], e[1]]); path[e[1]].push([succProb[i], e[0]]); &#125; let pq = new MaxPriorityQueue() pq.enqueue(start, 1) while (!pq.isEmpty()) &#123; let &#123;element: cur, priority: curProb&#125; = pq.dequeue() if (vi[cur]) continue; vi[cur] = true; if (cur == end) return curProb; let pp =path[cur]; for(let i=0; i&lt;pp.length; i++)&#123; let [nextProb, next] = pp[i]; if (vi[next]) continue; pq.enqueue(next, curProb * nextProb) &#125; &#125; return 0;&#125;; Bellman-Ford 算法 Bellman-Ford也是一种求最短路径的方法 1234567891011121314151617181920212223// Bellman-Ford， 100000节点 10ms 多; //https://zhuanlan.zhihu.com/p/72185593// https://www.cnblogs.com/lxt1105/p/6477639.htmlvar maxProbability = function(n, edges, succProb, start, end) &#123; // 求最大值，初始赋值最小；反之 let dp = new Array(n).fill(0); dp[start] = 1; while(true)&#123; let k = false; for(let j=0; j&lt;edges.length; j++)&#123; if(dp[edges[j][0]] * succProb[j] &gt; dp[edges[j][1]])&#123; dp[edges[j][1]] = dp[edges[j][0]] * succProb[j]; k = true; &#125; if (dp[edges[j][1]] * succProb[j] &gt; dp[edges[j][0]]) &#123; dp[edges[j][0]] = dp[edges[j][1]] * succProb[j]; k = true; &#125; &#125; if(!k) break; &#125; return dp[end]&#125; 子树中标签相同的节点数给你一棵树（即，一个连通的无环无向图），这棵树由编号从 0 到 n - 1 的 n 个节点组成，且恰好有 n - 1 条 edges 。树的根节点为节点 0 ，树上的每一个节点都有一个标签，也就是字符串 labels 中的一个小写字符（编号为 i 的 节点的标签就是 labels[i] ） 边数组 edges 以 edges[i] = [ai, bi] 的形式给出，该格式表示节点 ai 和 bi 之间存在一条边。 返回一个大小为 n 的数组，其中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数。 树 T 中的子树是由 T 中的某个节点及其所有后代节点组成的树。 示例 1： 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = “abaedcd”输出：[2,1,1,1,1,1,1]解释：节点 0 的标签为 ‘a’ ，以 ‘a’ 为根节点的子树中，节点 2 的标签也是 ‘a’ ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。节点 1 的标签为 ‘b’ ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。示例 2： 输入：n = 4, edges = [[0,1],[1,2],[0,3]], labels = “bbbb”输出：[4,2,1,1]解释：节点 2 的子树中只有节点 2 ，所以答案为 1 。节点 3 的子树中只有节点 3 ，所以答案为 1 。节点 1 的子树中包含节点 1 和 2 ，标签都是 ‘b’ ，因此答案为 2 。节点 0 的子树中包含节点 0、1、2 和 3，标签都是 ‘b’，因此答案为 4 。示例 3： 输入：n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = “aabab”输出：[3,2,1,1,1]示例 4： 输入：n = 6, edges = [[0,1],[0,2],[1,3],[3,4],[4,5]], labels = “cbabaa”输出：[1,2,1,1,2,1]示例 5： 输入：n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]], labels = “aaabaaa”输出：[6,5,4,1,3,2,1] 提示： 1 &lt;= n &lt;= 10^5edges.length == n - 1edges[i].length == 20 &lt;= ai, bi &lt; nai != bilabels.length == nlabels 仅由小写英文字母组成 由于当时第一时间想到的是图的遍历， 所以我就这么写了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var countSubTrees = function(n, edges, labels) &#123; let path = new Array(n); let n1 = n; while(n1--)&#123; path[n1] = []; &#125; edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push([e, labels[e]]); path[e].push([s, labels[s]])&#125;);.....// p&gt;num 子树 const isSub = (p, num)=&gt;&#123; // p必须在下面 let rp = getLen(p); let rn = getLen(num); if(rp&gt;rn) return true return false &#125; const getNum = (num)=&gt;&#123; let r = 1; let v = new Array(n).fill(false); let l1 = labels[num]; // node label let s = [num, l1]; let stack = []; stack.push(s) while(stack.length)&#123; let [s, l] = stack.shift(); if(v[s]) continue; v[s] = true let pp = path[s]; for(let i=0; i&lt;pp.length; i++)&#123; let [p, n] = pp[i]; if(v[p]) continue; // p是num的子节点 if(isSub(p, num)) &#123; if(n == l1)&#123; r++ &#125; stack.push([p, n]) &#125; &#125; &#125; return r &#125; return new Array(n).fill(0).map((f, n)=&gt;&#123; return getNum(n) &#125;)&#125;; 这个题中有个难点就是怎么才算是子树呢，它要是数字大就是数字小的子树，那就好了，但是不是。后来想想用“求最短路径”的常用套路，bfs。看它距离 源点0的距离，距离越大越远。 123456789101112131415161718192021222324252627282930313233343536373839let memorized = new Array(n).fill(0); memorized[0] = 1; const getLen = (start)=&gt;&#123; // if(start==0) return 0; if(memorized[start]) return memorized[start] let level = 1; let v = new Array(n).fill(false); let st = []; st.push(start); while(st.length)&#123; level++; let len = st.length; while(len--)&#123; let n = st.shift(); if(v[n]) continue v[n] = true // 初始不是0 if(level!=2)&#123; if(n==0) &#123; memorized[start] = level; return level &#125; &#125; let pa = path[n]; for(let i=0; i&lt;pa.length; i++)&#123; let pp = pa[i]; let [e] = pp; if(v[e]) continue st.push(e) &#125; &#125; &#125; &#125; 但是，最终结果却是超时 原始的dijkstra 算法 出于学习的目的又从百度上看了原始的dijkstra 算法，最后js的GC（last few GCs）报错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// Dijkstra，求出每个点距离0点的最短距离，确定是否是子树var countSubTrees = function(n, edges, labels) &#123; // 图 let path = new Array(n); let arcs = new Array(n); // 矩阵，相邻点1，不相临 无穷大 let n1 = n; while(n1--)&#123; path[n1] = []; arcs[n1] = new Array(n).fill(Infinity) &#125; edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push([e, labels[e]]); path[e].push([s, labels[s]]) arcs[s][e] = 1; arcs[e][s] = 1; &#125;); // Dijkstra，有出入，仿https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989?fr=aladdin教程写的 let s = new Array(n).fill(0); // 最短距离 let v = new Array(n).fill(false); // 访问过的点在S中，其余 T 中 let d = new Array(n).fill(Infinity); // 初始距离 无穷大,保存0-&gt;n的距离 d[0] = 0; path[0].forEach(p=&gt;d[p[0]]=1); // 与0相临的距离1 v[0] = true; let vi = 0; // 每个点到 0 的最短距离，并加入到s中 for(let i=1; i&lt;n; i++)&#123; let min = Infinity; for(let w=0; w&lt;n; w++)&#123; // 与0相邻，距离最短点 if(!v[w])&#123; if(d[w]&lt;min)&#123; // 每次产生一个最近点 vi = w; min = d[w]; &#125; &#125; &#125; v[vi] = true; //每次一个点S // 更新最短距离 for(let w=0; w&lt;n; w++)&#123; let x = arcs[vi][w]; // 满足条件就更新，可能多点, 如果出现 d(0-&gt;1) + d(1-&gt;w) &lt;d(0-&gt;w)，更新d[w]距离 if(!v[w] &amp;&amp; (min+ x&lt;d[w]))&#123; d[w] = min + x; &#125; &#125; &#125; // console.log(d); const isSub = (p, num)=&gt;&#123; // p必须在下面 let rp = d[p]; let rn = d[num]; if(rp&gt;rn) return true return false &#125; const getNum = (num)=&gt;&#123; let r = 1; let v = new Array(n).fill(false); let l1 = labels[num]; // node label let s = [num, l1]; let stack = []; stack.push(s) while(stack.length)&#123; let [s, l] = stack.shift(); if(v[s]) continue; v[s] = true let pp = path[s]; for(let i=0; i&lt;pp.length; i++)&#123; let [p, n] = pp[i]; if(v[p]) continue; // p是num的子节点 if(isSub(p, num)) &#123; if(n == l1)&#123; r++ &#125; stack.push([p, n]) &#125; &#125; &#125; return r &#125; return new Array(n).fill(0).map((f, n)=&gt;&#123; return getNum(n) &#125;)&#125; 官网给出的答案是 dfs，但是当节点为10万个时，栈的深度将近 1万，最后栈溢出报错，但是java和 c++是没有问题的。 123456789101112131415161718192021222324252627282930313233343536373839var countSubTrees = function(n, edges, labels) &#123; let path = new Array(n); let n1 = n; while(n1--)&#123; path[n1] = []; &#125; edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push([e, labels[e]]); path[e].push([s, labels[s]]) &#125;); let v = new Array(n).fill(false); let count = new Array(n).fill(0); // 100000十万 个点 RangeError: Maximum call stack size exceeded，但是java c++ python都不会 // 树的深度差不多超过了 10000 const dfs=(node, path, v, count, labels)=&gt;&#123; v[node] = true; // count[node] ++; let curCount = new Array(26).fill(0); curCount[labels[node].charCodeAt(0)-&apos;a&apos;.charCodeAt(0)]++ let cp = path[node]; for(let i=0; i&lt;cp.length; i++)&#123; let [next, l] = cp[i]; if(!v[next])&#123; let childCount = dfs(next, path, v, count, labels); let t = 26; while(t--)&#123; curCount[t] += childCount[t] &#125; &#125; &#125; count[node] = curCount[labels[node].charCodeAt(0)-&apos;a&apos;.charCodeAt(0)] return curCount &#125; dfs(0, path, v, count, labels) return count&#125; 最后呢，只能是 bfs，然后从底想下累加节点数目。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var countSubTrees = function(n, edges, labels) &#123; let path = new Array(n); let siz = new Array(n); let n1 = n; let n2 = n; while(n2--)&#123; siz[n2] = new Array(26).fill(0) &#125; while(n1--)&#123; path[n1] = []; &#125; // 生成图 edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push(e); path[e].push(s) &#125;); let fa = new Array(n).fill(0); let q = []; q.push(0); // bfs + 每个点的父节点 fa for(let i=0; i&lt;q.length; i++)&#123; let v = q[i]; for(let j=0; j&lt;path[v].length; j++)&#123; let y = path[v][j] if(y!=fa[v])&#123; fa[y] = v; q.push(y) &#125; &#125; &#125; // 从底向上，统计每个点对应字母个数 for(let i = n - 1; i &gt;= 0; i--) &#123; let v = q[i]; siz[v][labels[v].charCodeAt(0) - &apos;a&apos;.charCodeAt(0)]++; if(!v) break; for(let j = 0; j &lt; 26; j++) &#123; siz[fa[v]][j] += siz[v][j]; &#125; &#125; let res = []; for(let i = 0; i &lt; n; i++) res.push(siz[i][labels[i].charCodeAt(0) - &apos;a&apos;.charCodeAt(0)]); return res;&#125; 最大得分你有两个 有序 且数组内元素互不相同的数组 nums1 和 nums2 。 一条 合法路径 定义如下： 选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。从左到右遍历当前数组。如果你遇到了 nums1 和 nums2 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。得分定义为合法路径中不同数字的和。 请你返回所有可能合法路径中的最大得分。 由于答案可能很大，请你将它对 10^9 + 7 取余后返回。 示例 1： 输入：nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]输出：30解释：合法路径包括：[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10] （从 nums2 开始遍历）最大得分为上图中的绿色路径 [2,4,6,8,10] 。示例 2： 输入：nums1 = [1,3,5,7,9], nums2 = [3,5,100]输出：109解释：最大得分由路径 [1,3,5,100] 得到。示例 3： 输入：nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]输出：40解释：nums1 和 nums2 之间无相同数字。最大得分由路径 [6,7,8,9,10] 得到。示例 4： 输入：nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]输出：61 提示： 1 &lt;= nums1.length &lt;= 10^51 &lt;= nums2.length &lt;= 10^51 &lt;= nums1[i], nums2[i] &lt;= 10^7nums1 和 nums2 都是严格递增的数组。 如果题中求的是最短距离，那我们可以用图的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var maxSum = function(nums1, nums2) &#123; let n12 = [...new Set([...nums1.concat(nums2)])]; console.log(&apos;n12: &apos;, n12) let n12l = n12.length; let s1 = nums1[0], s2 = nums2[0], r1 = nums1[nums1.length - 1], r2 = nums2[nums2.length - 1], s1Index = n12.indexOf(s1), s2Index = n12.indexOf(s2), r1Index = n12.indexOf(r1), r2Index = n12.indexOf(r2); let e1 = [], e2 = []; nums1.forEach((n1, i) = &gt;&#123; if (nums1[i + 1] !== undefined) e1.push([n1, nums1[i + 1]]); &#125;) nums2.forEach((n1, i) = &gt;&#123; if (nums2[i + 1] !== undefined) e1.push([n1, nums2[i + 1]]) &#125;) let e12 = e1.concat(e2); let len = n12.length; let nl = n12.length; let paths = []; while (nl--) &#123; paths[nl] = [] &#125; let edges = []; let succProb = []; e12.forEach(([s, e]) = &gt;&#123; let sI = n12.indexOf(s), eI = n12.indexOf(e), w = s + e; // s-e 的权重 w paths[sI].push([eI, w]); paths[eI].push([sI, w]); edges.push([sI, eI]) succProb.push(w) &#125;) let mod = 10 * *9 + 7; // Dijkstra每次选距离最小的点，是一种贪心决策。从源点出发时，也必须挑选最短点。eg：d(0-c)&gt;d(0-a)+d(a-c),所以初始c点时不能进入S集合的。 const getCount = (s, e) = &gt;&#123; let v = new Array(n12l).fill(false); let stack = [[s, 0]]; while (stack.length) &#123; console.log(&apos;stack: &apos;, JSON.stringify(stack)) let[n, weight] = stack.shift(); if (v[n]) continue v[n] = true; if (n === e) return weight; let ps = paths[n]; for (let i = 0; i &lt; ps.length; i++) &#123; let[nn, nw] = ps[i]; if (v[nn]) continue; let f = 0; if (n !== s) &#123; // 这个权限是2点的和，会重复累加，所以要减去 f = n12[n] &#125; stack.push([nn, (weight + nw - f) % mod]); // 这个应该是从小到大，虽然从大到小测试用例也一样，纯属巧合 stack.sort((a, b) = &gt;a[1] - b[1]) &#125; &#125; &#125; let res1 = 0, res2 = 0, res3 = 0, res4 = 0; res1 = getCount(s1Index, r1Index); res2 = getCount(s1Index, r2Index); res3 = getCount(s2Index, r1Index); res4 = getCount(s2Index, r2Index); return Math.max(res1, res2, res3, res4)&#125;;let nums1 = [1, 4, 5, 8, 9, 11, 19],nums2 = [2, 3, 4, 11, 12];Aconsole.log(maxSum(nums1, nums2))// 最小距离// console.log(res1, res2, res3, res4)// 35 28 39 32 本题解法之一 双指针 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */// 双指针, 分成好几个区段，每段求最大值var maxSum = function(nums1, nums2) &#123; let l1 = nums1.length, l2 = nums2.length; let i =0, j=0; let s1=0,s2=0; let res = 0; // 某条分支结束遍历 while(i&lt;l1 &amp;&amp; j&lt;l2)&#123; if(nums1[i] === nums2[j])&#123; res += Math.max(s1, s2)+nums1[i]; i++; j++; s1 = 0; s2 = 0; &#125; while(nums1[i] &lt; nums2[j])&#123; s1+=nums1[i]; i++ &#125; while(nums1[i] &gt; nums2[j])&#123; s2+=nums2[j]; j++ &#125; &#125; while(i&lt;l1)&#123; s1+=nums1[i]; i++ &#125; while(j&lt;l2)&#123; s2+=nums2[j]; j++ &#125; res += Math.max(s1, s2) return res % (10**9+7)&#125;; 解法二- 动态规划 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var maxSum = function(nums1, nums2) &#123; let ord = new Set(); let n = nums1.length,m = nums2.length; let t1=3, t2=3; let pos = [], dp = []; // 储存位置，eg: 4=&gt;0, pos[2][4] = 0; while(t1--)&#123; pos[t1] = [] &#125; while(t2--)&#123; dp[t2] = new Array(10**5).fill(0) &#125; for(let i=0;i&lt;n;i++) ord.add(nums1[i]),pos[1][nums1[i]] = i; for(let i=0;i&lt;m;i++) ord.add(nums2[i]),pos[2][nums2[i]] = i; let newArr = [ ...ord ].sort((a, b)=&gt; a-b); for(let i=0;i&lt; newArr.length; i++)&#123; let p = newArr[i]; if(pos[2][p] != undefined &amp;&amp; pos[1][p] != undefined)&#123; dp[2][pos[2][p] + 1] = dp[1][pos[1][p] + 1] = Math.max(dp[1][pos[1][p]],dp[2][pos[2][p]]) + p; &#125;else if(pos[1][p] != undefined)&#123; dp[1][pos[1][p] + 1] = dp[1][pos[1][p]] + p; &#125;else if(pos[2][p] != undefined)&#123; dp[2][pos[2][p] + 1] = dp[2][pos[2][p]] + p; &#125; &#125; return Math.max(dp[1][n],dp[2][m]) % 1000000007;&#125;; 吃掉 N 个橘子的最少天数厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子： 吃掉一个橘子。如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。每天你只能从以上 3 种方案中选择一种方案。 请你返回吃掉所有 n 个橘子的最少天数。 示例 1： 输入：n = 10输出：4解释：你总共有 10 个橘子。第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。第 2 天：吃 6 个橘子，剩余橘子数 9 - 2(9/3) = 9 - 6 = 3。（9 可以被 3 整除）第 3 天：吃 2 个橘子，剩余橘子数 3 - 2(3/3) = 3 - 2 = 1。第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。你需要至少 4 天吃掉 10 个橘子。示例 2： 输入：n = 6输出：3解释：你总共有 6 个橘子。第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。你至少需要 3 天吃掉 6 个橘子。示例 3： 输入：n = 1输出：1示例 4： 输入：n = 56输出：6 提示： 1 &lt;= n &lt;= 2*10^9 如果把这道题看成图的形式，节点是剩余橘子数，边是花费的天数 1234567891011121314151617181920var minDays = function(n) &#123;// 剩余n 个橘子，花费0天 let q = [[0,n]]; let v = []; let ans = 0; while(true)&#123; let [days, rest] = q.shift(); if(v[rest]) continue v[rest] = true if(rest == 1) &#123; ans = days + 1; break; &#125; // rest%2 为剩余橘子数是2的倍数花费的天数 q.push([days+rest%2+1, Math.floor(rest/2)]); q.push([days+rest%3+1, Math.floor(rest/3)]); q.sort((a, b)=&gt;a[0]-b[0]) &#125; return ans&#125; 动态规划，超时 12345678910111213141516171819var minDays = function(n) &#123; // 吃 n 个橘子 最少天数是 d[n] let dp = new Array(n+1).fill(0); dp[1] = 1; dp[2] = 2; for(let i=3; i&lt;=n; i++)&#123; let m1 = Infinity, m2 = Infinity, m3 = Infinity; // 必须加 () if(!(i%2))&#123; m1 = dp[i/2]+1 &#125; if(!(i%3))&#123; m2 = dp[i/3]+1 &#125; m3 = dp[i-1]+1 dp[i] = Math.min(m1, m2, m3) &#125; return dp[n]&#125;; 动态规划 + 备忘录 12345678910111213var minDays = function(n) &#123; let d = []; const dfs = (n, d)=&gt;&#123; if(n===1) return 1; if(n===2) return 2; if(d[n]) return d[n]; let ans = Infinity; ans = Math.min(ans, n % 2 + dfs(Math.floor(n/2),d)+1) ans = Math.min(ans, n % 3 + dfs(Math.floor(n/3),d)+1) return d[n] = ans &#125; return dfs(n, d)&#125; 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-with-maximum-probability著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","comments":true,"tags":[]},{"title":"git rebase","date":"2020-06-27T23:02:59.000Z","path":"2020/06/28/git-rebase/","text":"","comments":true,"tags":[]},{"title":"https网站搭建","date":"2020-05-26T00:20:26.000Z","path":"2020/05/26/https网站搭建/","text":"","comments":true,"tags":[]},{"title":"reduxjs/redux","date":"2019-08-28T00:08:29.000Z","path":"2019/08/28/reduxjs-redux/","text":"createStore.js1export default function createStore(reducer, preloadedState, enhancer) &#123;...&#125; reducer 传入自定义reducer用来计算state，默认返回initState; preloadedState 初始状态 enhancer 加强，比如常用的applyMiddleWare123456789101112131415... if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; ... 这也就是说，第二个参数如果是function的话，会赋值给enhancer，平时应用的时候可以这样let store = createStore(reducer, applyMiddleware(thunk, sagaMiddleWare));也可以这样let store = applyMiddleware(promise, thunk, logger)(createStore)(reducers);编写中间件时都是固定写法123456789const middleware = function(&#123;getState, dispatch&#125;)&#123; return function(next)&#123; // 原生dispatch方法，next return function(action)&#123; // 重写的 dispatch console.log(`middleware 状态更改前：$&#123;JSON.stringify(getState())&#125;`) next(action) console.log(`middleware 状态更改后：$&#123;JSON.stringify(getState())&#125;`) &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859... function getState() &#123; ... return currentState &#125; function subscribe(listener) &#123; ... let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; ... isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) currentListeners = null &#125; &#125; function dispatch(action) &#123; ... try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125; ... store.dispatch({type: xxx, xx: xx}) 执行时既会执行 currentReducer(currentState, action) 计算新属性，又会遍历listeners将数组中订阅的函数都执行，大多数情况我们会使用boundAction就像下面 actions会单独集中式写一个文件，let boundActions = bindActionCreators(actions, store.dispatch)就可以这样使用boundActions.xxx如果引入了react-redux可以这样写this.props.xxxconnect(mapStateToProps, mapDispathToProps)(ComponentName) store.subscribe(fn) 监听某个函数，在不使用react-redux时可以这样123456componentDidMount()&#123; this.unsubscribe = store.subscribe(()=&gt;this.setState(&#123;number: store.getState().counter1.number&#125;))&#125;componentWillUnmount()&#123; this.unsubscribe()&#125; 返回unsubscribe 函数，执行取消订阅； store.getState()获取状态，这里也应用了闭包保存私有变量； More info: createStore.js bindActionCreators.js1234567891011121314151617181920function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;export default function bindActionCreators(actionCreators, dispatch) &#123; if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; ... const boundActionCreators = &#123;&#125; for (const key in actionCreators) &#123; const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; actionCreators 可以传对象形式的action12345678export default &#123; add(args)&#123; return &#123;type: types.ADD1, payload: args&#125; &#125;, minus()&#123; return &#123;type: types.MINUS1&#125; &#125;&#125; 也可以传函数let mapStateToProps = state =&gt; state.counter1;内部会进行判断typeof actionCreators === ‘function’ ，最终的目的还是store.dispatch({type: xxx, xx: xx}) More info: bindActionCreators.js applyMiddleware.js1234567891011121314return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; dispatch: (…args)=&gt;dispatch(…args) 保证dispatch 不是对象是函数的时候每次都是重写后的dispatch方法 dispatch = compose(…chain)(store.dispatch) 通过闭包的形式保存oldDispatch More info: applyMiddleware.js compose.js123return createStore =&gt; (...args) =&gt; &#123; .... return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))) 这里用了reduce,实现方法很多，以前还用了reduceRight,总之将穿进来的中间件从左到右执行即可； More info: compose.js combineReducers.js12345678910111213141516 ...return function combination(state = &#123;&#125;, action) &#123; ...const nextState = &#123;&#125;for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123;const key = finalReducerKeys[i]const reducer = finalReducers[key]const previousStateForKey = state[key]const nextStateForKey = reducer(previousStateForKey, action)...nextState[key] = nextStateForKeyhasChanged = hasChanged || nextStateForKey !== previousStateForKey&#125;hasChanged =hasChanged || finalReducerKeys.length !== Object.keys(state).lengthreturn hasChanged ? nextState : state 一般用来合并reducerexport default combineReducers({ r1, r2 })所有它返回的仍然是个reducer, function combination(state = {}, action) {…} 合并reducer的时候会用到一个新对象nextState = {}，并且后期会对比产生的新状态是否改变hasChanged = hasChanged || nextStateForKey !== previousStateForKey类似这样的对比还有react-redux中的connectfunction strictEqual(a, b) { return a === b }react 里面的PureComponent More info: combineReducers.js","comments":true,"tags":[]},{"title":"redirect","date":"2019-03-28T07:30:41.000Z","path":"2019/03/28/养成算法思维？/","text":"redirect to xxx","comments":true,"tags":[]},{"title":"养成算法思维？","date":"2019-03-25T02:37:37.000Z","path":"2019/03/25/redirect/","text":"","comments":true,"tags":[]},{"title":"js-state-manager","date":"2019-03-25T02:09:09.000Z","path":"2019/03/25/js-state-manager/","text":"js状态管理图","comments":true,"tags":[]},{"title":"diff","date":"2019-03-23T09:41:13.000Z","path":"2019/03/23/diff/","text":"diff算法的实现 通过虚拟dom类创建创建虚拟dom，最终通过render方法将虚拟dom渲染到页面。 12345678class Element &#123; constructor(type, props, children)&#123; this.type = type; this.props = props; this.children = children; &#125;&#125; 先序深度优先遍历生成补丁包patches(key值是遍历节点的顺序)。 1234567let patches = &#123; 0: &#123;type: &apos;ATTRS&apos;, attrs: &#123; class: &apos;xxx&apos;&#125;&#125;, 1: &#123;type: &apos;TEXT&apos;, text: &apos;xxx&apos;&#125;, 2: &#123;type: &apos;REPLACE&apos;, node: Element&#125;, 3: &#123;type: &apos;REMOVE&apos;, index: xxx&#125;&#125; patch函数更新旧dom","comments":true,"tags":[]},{"title":"react-router实现","date":"2019-03-22T18:12:46.000Z","path":"2019/03/23/react-router实现/","text":"react-router相关实现利用let {Provider, Consumer} = React.createContext();实现 HashRouter Link组件 Redirect组件 Route组件 Switch组件","comments":true,"tags":[]},{"title":"","date":"2018-10-07T09:01:04.000Z","path":"2018/10/07/新世界/","text":"","comments":true,"tags":[]},{"title":"VUE相关","date":"2018-10-07T08:18:52.000Z","path":"2018/10/07/分分钟系列之-VUE实现/","text":"实现一个简单的VUE功能包括 数据劫持 数据代理 模板编译 视图同步 computed订阅发布实现 v-model双向绑定实现 数据的对象嵌套 未完成 存在订阅了相同的函数 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123;a.b&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;c&#125;&#125;&#123;&#123;d&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sum&#125;&#125;&lt;/div&gt; &lt;input type=\"text\" v-model=\"a.b\"&gt; &lt;input type=\"text\" v-model=\"c\"&gt;&lt;/div&gt;&lt;script&gt;function Dep() &#123; // 实现订阅发布的数组 this.subs = [];&#125;Dep.prototype = &#123; addSub(sub) &#123; this.subs.push(sub); &#125;, notify() &#123; this.subs.forEach(sub =&gt; sub.update()); &#125;&#125;let dep = new Dep();let mvvm = new Mvvm(&#123; el: '#app', data: &#123; a: &#123; b: 1 &#125;, c: 2, d: 3 &#125;, computed: &#123; sum() &#123; // 调用一次，订阅一次，导致有2个sum return this.c + this.d; &#125;, noop() &#123; &#125; &#125;, &#125;); function Watcher(vm, exp, fn) &#123; ..... &#125; Watcher.prototype.update = function() &#123; this.fn() &#125; function Mvvm(options = &#123;&#125;) &#123; this.$options = options; let data = this._data = options.data // 数据劫持 observe(data) //数据代理 ...... initComputed.bind(this)() // 模板编译 Compile(options.el, this); &#125; function initComputed() &#123; ..... &#125; function Observe(data) &#123; &#125;&lt;/script&gt; 注意点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function Watcher &#123;.....// 可以通过reduce来调用defineProperty中的get方法，进而订阅Watcher实例this.exp.split('.').reduce((val, key)=&gt;&#123; return val[key]&#125;, this.vm) .....&#125;Watcher.prototype.update = function() &#123; // 这里仅需要执行fn()即可，不需要别的 this.fn()&#125;function Compile(el, vm) &#123; ...... // 满足非贪婪匹配 reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; ..... if(node.nodeType === 3 &amp;&amp; reg.test(txt))&#123; function replaceTxt() &#123; // replace函数的参数(match匹配的字符串，$1,$2...第n个括号匹配的字符串， offset，string) node.textContent = txt.replace(reg, (matched, placeholder)=&gt;&#123; return placeholder.split('.').reduce((val, key)=&gt;&#123; return val[key]; &#125;, vm) &#125;) &#125;; replaceTxt() new Watcher(vm, RegExp.$1, replaceTxt); &#125; // 双向绑定 if(node.nodeType === 1) &#123; let nodeAttr = node.attributes; Array.from(nodeAttr).forEach(attr =&gt; &#123; let name = attr.name, exp = attr.value, arr = exp.split('.'); if(name.includes('v-model'))&#123; replaceModel() node.addEventListener('input', e=&gt;&#123; let newVal = e.target.value; // 更新实例中的值，执行set中的发布；并满足类似a.b.c这样的表达式 eval('vm.'+exp+'='+newVal); node.value = newVal; &#125;) &#125; function replaceModel() &#123; node.value = arr.reduce((val, key)=&gt;&#123; return val[key] &#125;, vm) &#125; // 更新实例时，对应的node也要更新 new Watcher(vm, exp, replaceModel); &#125;) &#125;&#125;","comments":true,"tags":[]},{"title":"promise实现","date":"2018-09-28T22:25:15.000Z","path":"2018/09/29/promise实现/","text":"实现一个简单的promise 首先实现这种形式 12345678910111213new Promise((resolve, reject)=&gt;&#123; console.log(111) resolve(222)&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const pedding = 'pedding';const fulfilled = 'fulfilled';const rejected = 'rejected';const isFunction = (val) =&gt; typeof val === 'function'class MyPromise &#123; constructor(handler) &#123; if(!isFunction(handler)) &#123; throw new Error('promise必须传入函数！') &#125; // 值传递 this._value; // 内部状态 this._status = pedding; try &#123; // 保证异步调用时this指向 handler(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (error) &#123; &#125; &#125; _resolve(val) &#123; this._value = val; // resolve之后更改状态 this._status = fulfilled; &#125; _reject(val) &#123; &#125; then(resolve, reject) &#123; const &#123; _value, _status &#125; = this switch(_status) &#123; case pedding: break; case fulfilled: resolve(_value); break; case rejected: reject(_value) break; &#125; &#125;&#125; 对异步的处理 上面那种形式如果碰见异步就会出现问题，如何实现异步的情况？类似订阅发布形式。 123456789101112131415new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(111) resolve(222) &#125;, 100)&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class MyPromise &#123; constructor(handler) &#123; if(!isFunction(handler)) &#123; throw new Error('promise必须传入函数！') &#125; // 值传递 this._value; // 内部状态 this._status = pedding; this._fulfilledList = []; this._rejectedList = []; try &#123; // 保证异步调用时this指向 handler(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (error) &#123; &#125; &#125; _resolve(val) &#123; // 避免resolve多次执行 if(this._status !== pedding) return // resolve之后更改状态，如果用解构赋值，这里就不执行？ this._status = fulfilled; this._value = val; this._fulfilledList.forEach((item)=&gt;&#123; item(val) &#125;) &#125; _reject(val) &#123; if(this._status !== pedding) return this._status = rejected; this._value = val; this._rejectedList.forEach((item)=&gt;&#123; item(val) &#125;) &#125; then(onFulfilled, onRejected) &#123; const &#123; _value, _status, _fulfilledList, _rejectedList &#125; = this switch(_status) &#123; case pedding: _fulfilledList.push(onFulfilled); _rejectedList.push(onRejected); break; case fulfilled: onFulfilled(_value); break; case rejected: onRejected(_value) break; &#125; &#125;&#125; then之间的值传递 链式调用中，上一个then的返回值，下一个then如何接收？这里要用到闭包。 1234567891011121314151617181920new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(111) resolve(222) &#125;, 100)&#125;).then((data)=&gt;&#123; console.log(data) return 333&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222333 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.......then(onFulfilled, onRejected) &#123; const &#123; _value, _status, _fulfilledList, _rejectedList &#125; = this return new MyPromise((nextFulfiled, nextRejected)=&gt;&#123; const _onFulfilled = (val) =&gt; &#123; let res = onFulfilled(val); nextFulfiled(res) &#125; const _onRejected = (val) =&gt; &#123; let res = onRejected(val); nextRejected(res) &#125; switch(_status) &#123; case pedding: _fulfilledList.push(_onFulfilled); _rejectedList.push(_onRejected); break; case fulfilled: onFulfilled(_value); break; case rejected: onRejected(_value) break; &#125; &#125;) &#125;new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(1111) resolve(2222) &#125;, 500)&#125;).then((data)=&gt;&#123; console.log(data) return 333&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：11112222333 扩展： 12new 实现bind实现","comments":true,"tags":[]},{"title":"数据可视化","date":"2018-08-13T23:58:25.000Z","path":"2018/08/14/数据可视化/","text":"如何提高可视化技术 牛顿经典力学 函数、微积分 工具 信息图表 D3图形知识 ECharts和G2 地理空间 Leaflet OpenLayer Mapbox 三维空间 three.js最全的webgl库 spritejs好用的canvas动画库","comments":true,"tags":[]},{"title":"数据结构","date":"2018-08-12T22:59:54.000Z","path":"2018/08/13/数据结构/","text":"","comments":true,"tags":[]},{"title":"算法","date":"2018-08-12T22:59:40.000Z","path":"2018/08/13/排序算法/","text":"","comments":true,"tags":[]},{"title":"工程化","date":"2018-07-28T23:07:33.000Z","path":"2018/07/29/工程化/","text":"所谓工程化就是方法论，将软件研发的各个链路规范化，系统化，流程化 单元测试 网页性能分析 代码托管 bug日志 模块加载器 脚手架CLI搭建 数据分析（可视化） 接口测试（压力测试）","comments":true,"tags":[]},{"title":"架构设计","date":"2018-07-28T23:04:57.000Z","path":"2018/07/29/架构设计/","text":"1234参考项目:https://github.com/zhangzs000/my-works/tree/master/projects/RunningMan","comments":true,"tags":[]},{"title":"mobx文档翻译","date":"2018-07-08T22:54:59.000Z","path":"2018/07/09/mobx文档翻译/","text":"","comments":true,"tags":[]},{"title":"网页分析","date":"2018-06-18T08:08:18.000Z","path":"2018/06/18/网页分析/","text":"","comments":true,"tags":[]},{"title":"编码测试","date":"2018-06-05T00:07:02.000Z","path":"2018/06/05/编码测试/","text":"乱码乱码乱码编码测试编码测试编码测试","comments":true,"tags":[]},{"title":"深复制和浅复制","date":"2018-04-15T01:00:31.000Z","path":"2018/04/15/深复制和浅复制/","text":"关于复制也是很常见的问题 关于我们经常写的=赋值，就不把它归为复制，它只是赋值 还有就是常见的数组的方法比如concat、slice都是浅复制 还有ES6里面的Object.assign或…(扩展运算符)实现方式也是浅复制 第二点中举个例子1234567891011// 说明它是浅复制var arr5 = [1, 2, 3, [100, 200, 300]]var arr6 = arr5.slice(0);arr5[3][0]=555console.log(&apos;arr5: &apos;,arr5)console.log(&apos;arr6: &apos;,arr6)结果：arr5: (4) [1, 2, 3, [555, 200, 300]]arr6: (4) [1, 2, 3, [555, 200, 300]] 知乎上有张关于浅复制shallow图还是不错的，就是基本数据变量占存储值，对象类型的存引用 关于第三点展开运算符babel解析的时候，可能是数组的形式也可能是对象的Object.assign1234567891011121314let obj = [1, 2, &#123;a: 1&#125;]let obj2 = [...obj]// babel解析后var obj = [1, 2, &#123; a: 1 &#125;];var obj2 = [].concat(obj);------------let obj3 = &#123;a:1,b:3,d:&#123;d:4&#125;&#125;let obj4 = &#123;c:1, ...obj3&#125;// babel解析后var obj3 = &#123; a: 1, b: 3 &#125;;var obj4 = _extends(&#123; c: 1 &#125;, obj3);var _extends = Object.assign || function (target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target; &#125;; 可以看出当展开对象的时候可以是Object.assign或是循环第二个参数和第二个后面的参数给第一个参数(对象)上扩展属性。上例中对于obj4中通过扩展运算符添加的属性d只是单纯的引用关系。下面手动实现一个浅复制123456789101112var obj = &#123; a: 1, arr:[2, 3]&#125;var shallowObj = shallowObj(obj)function shallowObj (obj) &#123; var res = &#123;&#125;; for (prop in obj) &#123; if(obj.hasOwnProperty(prop)) &#123; res[prop] = obj[prop] &#125; &#125; return res;&#125; 但是这个只能浅复制对象，其实数组类似只是循环方法不同罢了，还有其它数据类型，下面讨论。深复制实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 一个比较简单的深复制实现// 单层嵌套的深复制JSON.stringify()但是，1、它无法实现函数、正则、类的实例、稀疏数组(长度可能大于值得个数)、循环引用等特殊对象的深度克隆2、它会抛弃构造函数constructor，所有构造函数会指向Object3、对象的循环引用会报错// 函数function a() &#123; console.log(111)&#125;// 正则new RegExp(&apos;a&apos;)// 构造函数function animal(color) &#123; this.color = color&#125;var ani = new animal(&apos;red&apos;)var oldObj = &#123; a: a, b: new RegExp(&apos;a&apos;), c: ani, d: new Array(1)&#125;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newObj.a, oldObj.a); // undefined// 无法复制正则对象console.log(newObj.b, oldObj.b); // 构造函数指向错误console.log(newObj.c.constructor, oldObj.c.constructor);// 稀疏数组复制错误console.log(newObj.d, oldObj.d);// 循环引用复制错误const oldObj = &#123;&#125;;oldObj.a = oldObj;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.a, oldObj.a); 实现深复制数组1234567891011121314function deepcopy(arr)&#123; let _deepcopy = [] for (var i = 0, len=arr.length; i &lt; len; i++) &#123; // 不能让它总是执行下面这段话啊，即使是深复制了，一执行有浅复制了 _deepcopy[i] = arr[i] if(arr[i] instanceof Array) &#123; // 直接赋值引用 VS 循环一下返回个新数组,i是索引。 _deepcopy[i] = deepcopy(arr[i]) &#125; &#125;; return _deepcopy&#125; 但是这个只能深复制数组，原理就是对象类型就用新的对象。还有其它数据类型，下面讨论。类型比较全的深复制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const getRegExp = re =&gt; &#123; var flags = &apos;&apos;; if (re.global) flags += &apos;g&apos;; if (re.ignoreCase) flags += &apos;i&apos;; if (re.multiline) flags += &apos;m&apos;; return flags; &#125;;function deepcopy(obj) &#123; let typeString, newobj; if(typeof obj !== &quot;object&quot; &amp;&amp; typeof obj !== &apos;function&apos;) &#123; // 基本数据类型才返回 return obj; &#125; typeString = Object.prototype.toString.call(obj); switch(typeString) &#123; case &apos;[object Array]&apos;: newobj = []; break; case &apos;[object RegExp]&apos;: newobj = new RegExp(obj.source, getRegExp(obj)); break; case &apos;[object Date]&apos;: newobj = new Date(obj); break; default: newobj = &#123;&#125;; // 处理对象原型，这样也行 // proto = Object.getPrototypeOf(parent); // 利用Object.create切断原型链 // child = Object.create(proto); &#125; for (let i in obj) &#123; // 递归 newobj[i] = deepcopy(obj[i]); &#125; return newobj&#125;var arr = [1, &#123;a:1&#125;,2]var copyArr = deepcopy(arr);arr[1][&apos;a&apos;] = 2console.log(&apos;arr: &apos;,arr)console.log(&apos;copyArr: &apos;, copyArr)var reg = new RegExp(/\\w/,&apos;ig&apos;);var copyReg = deepcopy(reg)console.log(&apos;reg: &apos;,reg)console.log(&apos;copyReg: &apos;, copyReg)var d1 = new Date()var copyD1 = deepcopy(d1)console.log(&apos;d1: &apos;,d1)console.log(&apos;copyD1: &apos;, copyD1)var obj = &#123;a:&#123;a1:&#123;a2:1&#125;&#125;,b:1&#125;var copyObj = deepcopy(obj)obj[&apos;a&apos;][&apos;a1&apos;][&apos;a2&apos;]=2console.log(&apos;obj: &apos;,obj)console.log(&apos;copyObj: &apos;, copyObj) 其它数据类型参考loadsh 和 知乎一篇文章 123456789101112131415161718192021222324var argsTag = &apos;[object Arguments]&apos;, arrayTag = &apos;[object Array]&apos;, boolTag = &apos;[object Boolean]&apos;, dateTag = &apos;[object Date]&apos;, errorTag = &apos;[object Error]&apos;, funcTag = &apos;[object Function]&apos;, mapTag = &apos;[object Map]&apos;, numberTag = &apos;[object Number]&apos;, objectTag = &apos;[object Object]&apos;, regexpTag = &apos;[object RegExp]&apos;, setTag = &apos;[object Set]&apos;, stringTag = &apos;[object String]&apos;, weakMapTag = &apos;[object WeakMap]&apos;;var arrayBufferTag = &apos;[object ArrayBuffer]&apos;, float32Tag = &apos;[object Float32Array]&apos;, float64Tag = &apos;[object Float64Array]&apos;, int8Tag = &apos;[object Int8Array]&apos;, int16Tag = &apos;[object Int16Array]&apos;, int32Tag = &apos;[object Int32Array]&apos;, uint8Tag = &apos;[object Uint8Array]&apos;, uint8ClampedTag = &apos;[object Uint8ClampedArray]&apos;, uint16Tag = &apos;[object Uint16Array]&apos;, uint32Tag = &apos;[object Uint32Array]&apos;;","comments":true,"tags":[]},{"title":"常见面试题","date":"2018-04-15T00:20:18.000Z","path":"2018/04/15/常见面试题/","text":"","comments":true,"tags":[]},{"title":"分页","date":"2018-04-15T00:19:52.000Z","path":"2018/04/15/分页/","text":"1.先整个假数据 123let _data = &#123; &quot;images&quot;: [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]&#125; 2.把基本结构和样式写好 1234567891011121314&lt;style type=&quot;text/css&quot;&gt; body&#123; margin:0 auto;&#125; #container&#123; width:1000px; height:200px; overflow:hidden; margin:0 auto;&#125; #container span&#123; display:block; width:172px; height:172px; padding:3px; border:solid 1px #ccc; float:left; margin:10px; display:inline;&#125; #container span img&#123; width:172px; height:172px; border:none; float:left;&#125; #button&#123; width:1000px; height:40px; margin:0 auto; overflow:hidden;&#125; #button span.root&#123; display:block; width:180px; height:40px; overflow:hidden; margin:0 auto;&#125; #button span span&#123; display:block; width:28px; height:28px; overflow:hidden; border:solid 1px #ccc; float:left; margin-left:5px; display:inline; line-height:30px; font-size:13px; color:#555; text-align:center; cursor:pointer;&#125;&lt;/style&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;div id=&quot;button&quot;&gt;&lt;/div&gt; 3.创建分页类，并构思好架构 1234567891011121314151617181920// 分页类function PageContent() &#123; ..... this.bindEvent = function()&#123; ....用于绑定事件 &#125; this.initButton = function()&#123; .... 用于初始化分页按钮 &#125; this.getImg = function() &#123; ...用于获取图片,并对图片做样式包装 &#125; this.initData = function() &#123; ...用于初始化数据 &#125;&#125; 4.实现初始化数据 123456789// 也就是展示第一页的内容this.initData = function() &#123; // 加载图片并包装 this.getImg(_data, 0, this.pagesize) // 获取总页数 this.totalPages = Math.ceil(_data[&apos;images&apos;].length/this.pagesize) // 初始化分页按钮数 this.initButton()&#125; 5.实现获取图片 1234567this.getImg=function(data,_s,_o)&#123; var _html=&quot;&quot;; for(var i=_s;i&lt;_o;i++)&#123; _html+=&quot;&lt;span&gt;&lt;img alt=\\&quot;\\&quot; src=\\&quot;waterfall/&quot;+data[&quot;images&quot;][i]+&quot;.jpg&quot;+&quot;\\&quot;/&gt;&lt;/span&gt;&quot;; &#125; $(&quot;#container&quot;).html(_html);&#125; 6.初始化分页按钮 12345678910// 把一页展示的几个按钮显示出来,为了简单可以一页把所有的按钮都展示-_-!!!this.initButton=function()&#123; var _btn=&quot;&lt;span class=\\&quot;root\\&quot;&gt;&quot;; for(var i=this.s;i&lt;=this.o &amp;&amp; i&lt;this.total;i++)&#123; _btn+=&quot;&lt;span&gt;&quot;+i+&quot;&lt;/span&gt;&quot;; &#125; _btn+=&quot;&lt;/span&gt;&quot;; $(&quot;#button&quot;).html(_btn); this.bindEvent();&#125; 7.绑定事件 1234567891011this.bindEvent=function()&#123; var _self=this; $(&quot;.root span&quot;).click(function()&#123; // 为每个按钮添加点击事件，并且还要刷新按钮样式 _self.s=(parseInt($(this).html())-1)*_self.size; _self.o=_self.s+_self.size; // reloadData加载数据 _self.getImg(data,_self.s,_self.o); &#125;);&#125; 太草率了，以后附上github链接上面写法有问题，就是每次new对象的时候方法之类的重新创建，没做到原型共享12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 无聊花半小时写了个简单版，亲测有效const LoadData = &#123; &quot;images&quot;: [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]&#125;class PageContent &#123; constructor() &#123; this.pageSize = 5; this.totalBtns = 0; this.btnWrapper = document.getElementById(&apos;button&apos;); &#125; bindEvent() &#123; let btns = this.btnWrapper.querySelectorAll(&apos;button&apos;) for (var i = 0; i &lt; btns.length; i++) &#123; (function(i)&#123; btns[i].addEventListener(&apos;click&apos;,function () &#123; this.getImgs(LoadData, i*this.pageSize, (i+1)*this.pageSize) &#125;.bind(this)) &#125;.bind(this))(i) &#125;; &#125; getImgs(data, s, e) &#123; console.log(data, s, e) let wrapper = document.getElementById(&apos;container&apos;); let container = &apos;&apos;; for (var i = s; i &lt; e; i++) &#123; container+=` &lt;span&gt; &lt;img src=&quot;waterfall/$&#123;LoadData[&quot;images&quot;][i]&#125;.jpg&quot;/&gt; &lt;/span&gt; ` &#125;; wrapper.innerHTML = container; &#125; initButtons() &#123; this.totalBtns = Math.ceil(LoadData[&quot;images&quot;].length/this.pageSize); let container = &apos;&apos;; for (var i = 0; i &lt; this.totalBtns; i++) &#123; container+=` &lt;button&gt; $&#123;i+1&#125; &lt;/button&gt; ` &#125;; this.btnWrapper.innerHTML = container; this.bindEvent() &#125; initData () &#123; this.getImgs(LoadData, 0, this.pageSize) this.initButtons() &#125; &#125;var _pc=new PageContent(); _pc.initData();","comments":true,"tags":[]},{"title":"debounce和throttle","date":"2018-04-15T00:15:40.000Z","path":"2018/04/15/debounce和throttle/","text":"这个问题也经常会碰到，于是手动实现试试 debounce(防抖)间隔时间内只能执行一次 把该封装的封装，抽离的抽离123456789101112btn.addEventListener(&apos;click&apos;,debounce())function debounce() &#123; return function() &#123; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; todo() &#125;,500) &#125;&#125;function todo() &#123; console.log(11111)&#125; 再优化一下，回调，传参，绑定作用域123456789101112131415// 这个还是蛮标准的。btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; return function() &#123; let context = this; // btn let args = arguments; // 事件e clearTimeout(this.timer) this.timer = setTimeout(function()&#123; fn.apply(context, args) &#125;,delay) &#125;&#125;function todo(param) &#123; console.log(11111, param)&#125; 目前的情况是间隔时间后才触发，如果我想开始就触发，间隔时间后才能再次触发123456789101112131415161718192021btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; let flag = true; return function() &#123; let context = this; let args = arguments; flag &amp;&amp; fn.apply(context, args) flag = false; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; // 想再间隔时间后再执行，就加上它；感觉也行吧 // fn.apply(context, args) flag = true; &#125;,delay) &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 那如果我有时想立即触发，有时想最后一次点击delay后触发，加个参数呗1234btn.addEventListener(&apos;click&apos;,debounce(todo, 500, [true/false]))function debounce(fn, delay, immediate) &#123; ...&#125; throttle(节流) 在规定时间内，不断触发，就行水龙头的水一样 下面呢就实现间隔时间delay内不断触发，并且在最后一次触发的时候，delay秒后将再次自动触发1234567891011121314151617btn.addEventListener(&apos;click&apos;,throttle(todo, 500))function throttle(fn, delay) &#123; return function() &#123; let context = this; let args = arguments; if (!this.timer) &#123; // 没报错说明没语法错误，不执行说明逻辑没走掉这 this.timer = setTimeout(function()&#123; fn.apply(context, args) this.timer = null; &#125;.bind(this), delay) &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 但是呢，上面那个总是在delay后执行，不能立即执行；下面就用时间戳的形式实现立即执行,前提是初始点击的时候已经是delay后了12345678910111213141516btn.addEventListener(&apos;click&apos;,throttle(todo, 500)) function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; &#125; &#125; function todo(params) &#123; console.log(11111, params) &#125; 假如我想开始立即触发，最后那一次delay后也要执行一次呢12345678910111213141516171819202122btn.addEventListener(&apos;click&apos;,throttle(todo, 1000))function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; else &#123; // 一直清除定时器 clearTimeout(this.timer); this.timer = setTimeout(fn.bind(this, args),delay); &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 适用场景 防抖放在购物车结算时，它只能点击一次； 节流放在购物车加减商品时，还有类似淘宝的搜索框，还有类似的resize,之类的不断触发AjAx的场景 有时防抖和节流会混合试用 看下lodash 关于防抖和节流的实现源码，反正是饶了一大圈，就不详细看了1234567891011121314151617181920212223242526272829303132333435363738394041424344function shouldInvoke(time) &#123; var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we&apos;re at the // trailing edge, the system time has gone backwards and we&apos;re treating // it as the trailing edge, or we&apos;ve hit the ```maxWait``` limit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));&#125;// 这个是判断是否解析时间的函数，应该是：1、初始点击要解析；2、大于间隔时间要解析。。。/** * A simple wrapper around the global [```setTimeout```](https://mdn.io/setTimeout). * * @private * @param &#123;Function&#125; func The function to delay. * @param &#123;number&#125; wait The number of milliseconds to delay invocation. * @returns &#123;number|Object&#125; Returns the timer id or timeout object. */ var setTimeout = ctxSetTimeout || function(func, wait) &#123; return root.setTimeout(func, wait); &#125;; // 对setTimeout进行封装，不知其意 function leadingEdge(time) &#123; // Reset any ```maxWait``` timer. lastInvokeTime = time; // Start the timer for the trailing edge. timerId = setTimeout(timerExpired, wait); // Invoke the leading edge. return leading ? invokeFunc(time) : result; &#125;// 中途调用了leadingEdge这个应该是加载方法，并且第一次调用时调用了invokeFunc(time)function invokeFunc(time) &#123; var args = lastArgs, thisArg = lastThis; lastArgs = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; &#125;// 而这个invokeFunc里面就调用了result = func.apply(thisArg, args);// func就是要执行的回调。","comments":true,"tags":[]},{"title":"手写react和redux","date":"2018-04-15T00:14:38.000Z","path":"2018/04/15/手写react和redux/","text":"","comments":true,"tags":[]},{"title":"��дvue��vuex","date":"2018-04-15T00:14:38.000Z","path":"2018/04/15/手写vue和vuex/","text":"�ο�����","comments":true,"tags":[]},{"title":"jQuery源码分析","date":"2018-04-15T00:14:00.000Z","path":"2018/04/15/jQuery源码分析/","text":"","comments":true,"tags":[]},{"title":"diary18-2-13","date":"2018-02-13T13:53:46.000Z","path":"2018/02/13/diary18-2-13/","text":"楚人有卖某珠于郑者。","comments":true,"tags":[]},{"title":"vue动画","date":"2017-06-19T14:03:32.000Z","path":"2017/06/19/vue动画/","text":"","comments":true,"tags":[]},{"title":"Node.js","date":"2017-03-18T14:56:18.000Z","path":"2017/03/18/Node-js/","text":"","comments":true,"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"xmapp","slug":"xmapp","permalink":"http://yoursite.com/tags/xmapp/"}]},{"title":"canvas","date":"2017-03-16T09:32:58.000Z","path":"2017/03/16/canvas/","text":"这篇主要是canvas最终要达到的效果是下面这个样子： demo1 弹弹球，碰撞就变色 这个解决最长时间的问题是： 1234ctx.beginPath();drawBall(ballX,ballY);ctx.closePath(); 缺了2行代码，导致运动完的路径一直都在。 demo2 时钟 demo3 画板 demo4 运动 这个的主要问题是： canvas的旋转是从上一次旋转开始计算的和css3不一样，除非加上save()和restore()方法； clearRect的时候还待translate(0,0)，这个问题。。反正我的浏览器待这样弄。 一个画板要画多个连续运动图像怎么办？ demo5 canvas拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;canvas id=\"can\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var can=document.getElementById(\"can\"); var ctx=can.getContext(\"2d\"); //移动时要覆盖以前的坐标，所以先配置 var points = [ &#123;x:100,y:100,r:50,startA:0,endA:2*Math.PI&#125;, &#123;x:200,y:200,r:50,startA:0,endA:2*Math.PI&#125; ] function drawArc()&#123; for (var i = 0; i &lt; points.length; i++) &#123; ctx.beginPath(); ctx.arc(points[i].x,points[i].y,points[i].r,points[i].startA,points[i].endA); ctx.fill(); &#125; &#125; drawArc(); //移动图形 can.onmousedown = function(e)&#123; var e = e || window.event; document.onmousemove=function(e)&#123; var e = e || window.event; ctx.clearRect(0,0,500,500); var x = e.layerX; var y = e.layerY; //重新绘制 for (var i = points.length - 1; i &gt;= 0; i--) &#123; var event = new addEvent(ctx,\"arc\",points[i].x+\",\"+points[i].y+\",\"+points[i].r+\",\"+points[i].startA+\",\"+points[i].endA,function()&#123; ctx.beginPath(); console.log(points[i].r+\"我是第53行\") var [callbackR,callbackX,callbackY] = [points[i].r,points[i].x,points[i].y] ctx.arc(x,y,callbackR,callbackX,callbackY); ctx.fill(); points[i].x = x; points[i].y = y; &#125;) event.isPointInPathCallback(x,y); &#125; event.isPointInPathCallback(x,y); &#125; document.onmouseup=function()&#123; document.onmousemove = null; document.onmouseup = null; &#125; &#125; /* //未点击之前先绘制，点击后再绘制；确保点击后是最新绘制的 ctx.beginPath(); ctx.arc(100,100,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(200,200,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.rect(400,200,50,50); ctx.fill(); //点击对应的图片，弹出对应的值 // can.onclick = function (e)&#123; // var e = e || window.event; // var x = e.layerX; // var y = e.layerY; // //和上面一个意思 // // var xx = e.offsetX; // // var yy = e.offsetY; // //如果把2*Math.PI当成字符串传进去是不行的。 // var event1 = new addEvent(ctx,\"arc\",\"100,100,50,0,\"+2*Math.PI,function()&#123; // alert(1); // &#125;) // event1.isPointInPathCallback(x,y); // var event2 = new addEvent(ctx,\"arc\",\"200,200,50,0,\"+2*Math.PI,function()&#123; // alert(2); // &#125;) // event2.isPointInPathCallback(x,y); // var event3 = new addEvent(ctx,\"rect\",\"400,200,50,50\",function()&#123; // alert(3); // &#125;) // event3.isPointInPathCallback(x,y); // &#125; */ //封装成一个util function addEvent (obj,type,data,callback)&#123; this.obj = obj; this.type = type; this.data = data; this.callback = callback; this.reDraw(); &#125; addEvent.prototype = &#123; reDraw:function()&#123; if(this.type == \"arc\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.arc(arr[0],arr[1],arr[2],arr[3],arr[4]); this.obj.fill(); &#125;else if(this.type == \"rect\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.rect(arr[0],arr[1],arr[2],arr[3]); this.obj.fill(); &#125; &#125;, isPointInPathCallback:function(x,y)&#123; if(this.obj.isPointInPath(x,y))&#123; this.callback(); &#125; &#125; &#125;;&lt;/script&gt; 存在的问题： 53行能打印出来，但是也报错Uncaught TypeError: Cannot read property ‘r’ of undefined。 点击图形起始点和图形的圆心是有距离的，后期拖拽时直接将拖拽的相对距离赋值给了圆心，导致误差。 还是有点懵。每次new 相同的event? demo6 canvas实现3d效果 很棒的canvas3次贝塞尔曲线算法地图 canvas库 参考链接：https://www.evget.com/article/2014/4/9/20799.html 报表统计 项目实现一个绘图工具 git地址：","comments":true,"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"","date":"2017-03-16T02:11:23.000Z","path":"2017/03/16/开源项目/","text":"","comments":true,"tags":[{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"搭载git服务器","date":"2017-03-05T06:55:49.000Z","path":"2017/03/05/搭载git服务器/","text":"","comments":true,"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"Flux架构","date":"2017-03-04T14:19:53.000Z","path":"2017/03/04/Flux架构/","text":"","comments":true,"tags":[{"name":"前端架构","slug":"前端架构","permalink":"http://yoursite.com/tags/前端架构/"}]},{"title":"框架对比","date":"2017-03-04T10:59:30.000Z","path":"2017/03/04/框架对比/","text":"","comments":true,"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"}]},{"title":"React开发","date":"2017-03-04T04:20:08.000Z","path":"2017/03/04/React开发/","text":"","comments":true,"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"js理解","date":"2017-03-03T10:08:31.000Z","path":"2017/03/03/js理解/","text":"","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"学习md语法","date":"2017-03-03T08:51:40.000Z","path":"2017/03/03/md语法/","text":"这是大标题这是小标题1$ 这里面放代码 这里放超链接: Writing 下面是插入图片 这里也是图片 1![不支持](/assets/blogImg/touxiang.png&#123;100x100&#125; \"测试图片并且定义宽高\") 1![不支持](/assets/blogImg/touxiang.png =100x100 \"测试图片并且定义宽高\") 1$ http://wowubuntu.com/markdown/basic.html 在博客园写博客想要好的样式，还必须用第三方工具，我记得是writerlive之类的；现在感觉太棒了！！下面这幅图是用截图工具处理的。。。。 这里是列表 这里是列表 1基本可以应付了。 步骤123hexo new title //默认问post布局，title改为你的文章名似乎还待加一句 $ hexo generate //生成静态文件hexo deploy 列表： 。。。。 。。。 Great !!!!","comments":true,"tags":[]},{"title":"用hexo制作博客","date":"2017-03-02T14:32:55.508Z","path":"2017/03/02/hexo博客/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]