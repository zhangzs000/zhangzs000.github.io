[{"title":"虚拟列表","date":"2021-07-05T23:00:08.000Z","path":"2021/07/06/虚拟列表/","text":"","comments":true,"tags":[]},{"title":"信息安全","date":"2021-06-27T22:58:40.000Z","path":"2021/06/28/信息安全/","text":"[TOC] 1234无善无恶心之体，有善有恶意之动，知善知恶是良知，为善去恶是格物。 xss攻击什么是xss攻击 XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。 xss攻击的分类反射型 服务端返回的链接有恶意脚本 1234服务端没有过滤返回的链接，比如 服务端返回ctx.body = &apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;;http://xxx/?redirect_to=javascript:alert(&apos;XSS&apos;);就注入恶意脚本 如何防范 12345678910111213141516方式一：XSS 防御之 URL 编码返回的链接用 encodeURIComponent 执行eg: encodeURIComponent(&apos;https://www.baidu.com/&apos;)&quot;https%3A%2F%2Fwww.baidu.com%2F&quot;这个链接浏览器不识别方法二：// 根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 scheme 等allowSchemes = [&quot;http&quot;, &quot;https&quot;];valid = isValid(getParameter(&quot;redirect_to&quot;), allowSchemes);方法三：XSS 防御之 CSS 编码&lt;style&gt;body&#123;background-image: url(&quot;javascript:alert(&apos;xss&apos;)&quot;);&#125;&lt;/style&gt;方法四：开启CSP网页安全政策 DOM-base 取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 1不基于后端的攻击，修改属性插入内容 如何防范 12对内容进行编码encodeURI 存储型(持久型) 恶意代码提交到目标网站的数据库或服务器中 1比如没有对输入框中的链接做过滤，便提交到数据库中 如何防范 12345678客户端传给服务器时，先过滤;服务端过滤;输出时过滤，转义;function html2Escape(sHtml) &#123; return sHtml.replace(/[&lt;&gt;&amp;&quot;]/g,function(c)&#123;console.log(&apos;c: &apos;,c); return &#123;&apos;&lt;&apos;:&apos;&amp;lt;&apos;,&apos;&gt;&apos;:&apos;&amp;gt;&apos;,&apos;&amp;&apos;:&apos;&amp;amp;&apos;,&apos;&quot;&apos;:&apos;&amp;quot;&apos;&#125;[c]; &#125;);&#125; XSS 防御之 URL 编码12345返回的链接用 encodeURIComponent 执行eg: encodeURIComponent(&apos;https://www.baidu.com/&apos;)&quot;https%3A%2F%2Fwww.baidu.com%2F&quot;这个链接浏览器不识别 白名单123// 根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 scheme 等allowSchemes = [&quot;http&quot;, &quot;https&quot;];valid = isValid(getParameter(&quot;redirect_to&quot;), allowSchemes); XSS 防御之 CSS 编码1&lt;style&gt;body&#123;background-image: url(&quot;javascript:alert(&apos;xss&apos;)&quot;);&#125;&lt;/style&gt; 开启CSP网页安全政策1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;&quot;&gt; 等 在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？1答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。 csrf什么是 csrf 攻击 CSRF一般指跨站请求伪造。跨站请求伪造（英语：Cross-site request forgery） csrf 攻击产生的前提 表单提交，为了可用性考虑，浏览器的同源策略是不做限制的。 同源策略限制内容有：Cookie、LocalStorage、IndexedDB 等存储性内容；DOM 节点，AJAX 请求不能发送。 如何防范 1231. 添加验证码(体验不好)， 验证码可以防止并发量2. 判断来源 referer 防盗链3. token 表单提交的 token 和 session 中的 token 做对比 易混淆123456JWT: Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。jwt 验证登陆let token = jwt.encode(非敏感信息) jwt.decode(token, secret) 解码校验token判断是否能登陆过JIT: JavaScript 程序最初都是被编译为字节码，通过解释器进行解释执行，解释执行能够获得更好的启动时间。某些被频繁执行的方法或者代码块，被认定为“热点代码”。在运行时, 会把这些热点代码编译成与本地平台相关的机器码，并且进行各种层次的优化，以提高执行效率。完成这个任务的编译器称为即时编译器（JIT编译器）。 扩展sql 注入1select * from user where username = &apos;&apos; and password = &apos; &apos; or &apos;1&apos; = &apos;1 &apos; 如何防范 1预编译，这样就不会出现拼串的问题了 参考链接：https://tech.meituan.com/2018/09/27/fe-security.htmlhttps://tech.meituan.com/2018/10/11/fe-security-csrf.htmlhttps://www.cnblogs.com/tugenhua0707/p/10909284.html","comments":true,"tags":[]},{"title":"前端监控","date":"2021-06-10T22:19:33.000Z","path":"2021/06/11/前端监控/","text":"什么是前端监控 对前端性能和错误的监控 为什么要做前端监控 更快发现问题和解决问题 做产品的决策依据 提升前端工程师的技术深度和广度 为业务扩展提供了更多可能性 怎么做前端监控 jsError 1window.addEventListener(&quot;error&quot;,function()&#123;&#125;, true) promiseError 1window.addEventListener(&quot;unhandledrejection&quot;,function()&#123;&#125;, true) 资源加载 1234567// 必须捕获过程，并且先加载 window.addEventListener&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;error&apos;,(e)=&gt;&#123; console.log(&apos;e: &apos;,e) &#125;, true)&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./xxx.js&quot;&gt;&lt;/script&gt; 加载时间 12new PerformanceObserver((entryList, observer) =&gt; &#123;&#125;).observe(&#123; type: &quot;xx&quot;, buffered: true &#125;);performance.timing 监听白屏幕 12// 返还在特定坐标点下的HTML元素数组document.elementsFromPoint() 怎么上报 gif 图 1gif 图片做上传, 图片速度快, 没有跨域问题； post请求 1无长度限制，阿里云上报; 链家开源项目：灯塔https://github.com/LianjiaTech/fee 环境配置 系统版本 1MacOs 10.13.4 mysql 12345.6.39参考链接：https://downloads.mysql.com/archives/community/https://www.cnblogs.com/benbenzhu/p/5578162.html redis 12346.2.4参考链接：https://redis.io/downloadhttps://www.jianshu.com/p/3bdfda703552 nginx 1231.18.0http://nginx.org/en/download.htmlhttps://www.yinxiang.com/everhub/note/6d95496a-1f34-444e-bcce-607a94cb7955 未解决问题 1很多细节问题，比如 mysql`max key length ` 等，懒得折腾 项目流程","comments":true,"tags":[]},{"title":"微前端应用","date":"2021-05-28T23:23:00.000Z","path":"2021/05/29/微前端应用/","text":"需求有几个问题： 1.域名不同，在与存储小组对接时涉及到token问题、； 2.项目的技术栈不同，有的是vue，有的是react。之前是通过不同二级域名解决，体验不是太好； 3.有一个公共项目，每次版本更新，所有项目都待上下线，虽然我们上线是前端直接点击Jenkins； 微前端 微前端就是将不同的功能按照不同的维度拆分成多个子应用，通过主应用来加载这些子应用。还有后端的微服务是面向服务架构（SOA）的一种变体，把应用程序设计成一系列松耦合的细粒度服务，并通过轻量级的通信协议组织起来。 使用微前端可以解决前两个问题 公共项目版本更新的原理类似协商缓存实现原理 应用的加载与切换 1// 路由实现 应用的隔离与通信 1234// 父子，子子应用通信父子通信 props子子通信 window对象，发布订阅模式 参考链接：1https://blog.csdn.net/webyouxuan/article/details/107603165 附录参考链接：1https://mp.weixin.qq.com/s?__biz=MzI3NTM5NDgzOA==&amp;mid=2247496957&amp;idx=2&amp;sn=4020ee80490cb78b7215f3fd8e3bb7dc&amp;chksm=eb07cc84dc704592f91893620981863c5f0d3603e273e04bad109724b1d1ba7590594a2a4308&amp;mpshare=1&amp;scene=1&amp;srcid=0528HdOyZzGuc6ZcznDaTBXV&amp;sharer_sharetime=1623205674082&amp;sharer_shareid=addda33c4eab5e9d285d29057d1ba689#rd","comments":true,"tags":[]},{"title":"有意思的问题","date":"2021-05-28T23:21:32.000Z","path":"2021/05/29/有意思的问题/","text":"生活中常见的问题 计算器 汉诺塔 24点 计算器平时支持 +-x/ 的简单计算器是如何计算的 粗糙的做法 eval() 栈 编译原理 逆波兰计算器 栈 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;string&#125; s * @return &#123;number&#125; */var calculate = function(s) &#123; let i=0; let len = s.length; let pre = &apos;+&apos;; let num = 0; let q =[]; while(i&lt;len)&#123; let c = s[i]; if(!isNaN(c) &amp;&amp; c!==&apos; &apos;)&#123; num = num*10 + Number(c) &#125; if(isNaN(c) || i=== len - 1) &#123; if(pre === &apos;+&apos;)&#123; q.push(num) pre = c; num = 0; &#125; else if(pre === &apos;-&apos;)&#123; q.push(-num ) pre = c; num = 0; &#125; else if(pre === &apos;*&apos;)&#123; q.push( q.pop() * num ) pre = c; num = 0; &#125; else if(pre === &apos;/&apos;)&#123; // 取整 q.push( q.pop() / num | 0 ) pre = c; num = 0; &#125; &#125; i++ &#125; return q.reduce((a,b)=&gt;a+b, 0)&#125;; 双栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131分析：使用栈完成表达式的计算思路1.通过一个index值(索引) ,来遍历我们的表达式2.如果我们发现是一个数字,就直接入数栈3.如果发现扫描到是一个符号,就分如下情况3.1如果发现当前的符号栈为空，就直接入栈3.2如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数在从符号栈中pop出-一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈4.当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行。5. 最后在数栈只有一个数字，就是表达式的结果const priority = (oper) =&gt; &#123; if (oper === &quot;*&quot; || oper == &quot;/&quot;) &#123; return 1; &#125; else if (oper === &quot;+&quot; || oper === &quot;-&quot;) &#123; return 0; &#125; else &#123; return -1; //假定目前的表达式只有+，-，*，/ &#125; &#125;; const isOper = (val) =&gt; &#123; return val === &quot;+&quot; || val === &quot;-&quot; || val === &quot;*&quot; || val === &quot;/&quot;; &#125;; const cal = (num1, num2, oper) =&gt; &#123; let res = 0; // res用于存放汁算的拮果 switch (oper) &#123; case &quot;+&quot;: res = num1 + num2; break; case &quot;-&quot;: res = num2 - num1; break; case &quot;*&quot;: res = num1 * num2; break; case &quot;/&quot;: res = num2 / num1; break; default: break; &#125; return res; &#125;; const calculator = () =&gt; &#123; let expression = &quot;70+2*6-4&quot;; // 15//如何处理多位数的问题? //创建两个栈，数栈，一个符号栈 let numStack = []; let operStack = []; //定义需要的相关变量 let index = 0; //用于扫描 let num1 = 0; let num2 = 0; let oper = 0; let res = 0; let ch = &quot;&quot;; //将每次扫描得到char保存到ch let keepNum = &quot;&quot;; // 数字拼接 //开始while循环的扫描expression while (true) &#123; //依次得到expression的每个字符 ch = expression.slice(index, index + 1); //判断ch是什么，然后做相应的处理 if (isOper(ch)) &#123; //如果是运算符 //判断当前的符号栈是否为空 if (operStack.length) &#123; //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数, //在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 if (priority(ch) &lt;= priority(operStack[operStack.length - 1])) &#123; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); //然后将当前的操作符入符号栈 operStack.push(ch); &#125; else &#123; //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。 operStack.push(ch); &#125; &#125; else &#123; //如果为空直接入符号栈.. operStack.push(ch); &#125; &#125; else &#123; //如果是数，则直接入数栈 //处理多位数 keepNum += ch; //如果ch已经是expression的最后一位,就直接入栈 if (index == expression.length - 1) &#123; numStack.push(Number(keepNum)); &#125; else &#123; //判断下一个字符是不是数字，如果是数字，就继续扫描,如果是运算符，则入栈 //注意是看后一位，不是index++ if ( isOper(expression.slice(index + 1, index + 2)) ) &#123; //如果后一 位是运算符，则入栈keepNum =“1&quot; 或者“123&quot; numStack.push(Number(keepNum)); //重要的!!!!!, keepNum清空 keepNum = &quot;&quot;; &#125; &#125; &#125; //让index + 1,并判断是否扫描到expression最后。 index++; if (index &gt;= expression.length) &#123; break; &#125; &#125; //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号,并运行。 while (true) &#123; //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字[结果] if (!operStack.length) &#123; break; &#125; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = cal(num1, num2, oper); numStack.push(res); //入栈 &#125; //将数栈的最后数，pop出，就是结果 let res2 = numStack.pop(); console.log(&quot;表达式&quot;, expression, res2); &#125;; calculator() 编译原理 分词 12345678910111213141516171819202122// 方法一：正则匹配while (true) &#123;// 每次循环匹配出相应的 token let result = RegExpObject.exec(script); ... 略 ... &#125;// 方法二：有限状态机function start(char) &#123; if (char === &quot;&lt;&quot;) &#123; emit(&#123; type: tokenTypes.LeftParentheses, value: &quot;&lt;&quot; &#125;); return foundLeftParentheses; //找到了 &lt; &#125;&#125;function foundLeftParentheses(char) &#123; ... 略 ...&#125;... 略 ..let state = start;for (let char of input) &#123; if (state) state = state(char);&#125; 语法分析，描述了代码语句中的每一个片段以及它们之间的关系或者 AST 123456789101112131415161718// 语法规则 进阶 巴科范式add -&gt; multiple |multiple + addmultiple -&gt; NUMBER | NUMBER * multiple// 算法： 递归向下，从外层往内层下降function toAST(tokenReader) &#123; ... 略 ... let child = additive(tokenReader); // 能推导出来，就 push ... 略 ...&#125;function additive(tokenReader) &#123; let child1 = minus(tokenReader); ... 略 ... let child2 = additive(tokenReader); ... 略 ...&#125;... 略 ... 根据AST递归计算(很多相似结构) 逆波兰计算器1https://www.youtube.com/watch?v=635SxlJgq7I&amp;list=PLmOn9nNkQxJFvyhDYx0ya4F75uTtUHA_f&amp;index=36 汉诺塔递归12345678910111213141516// 分治算法const hanoiTower = (num, a, b, c) =&gt; &#123; //如果只有一个盘 if (num == 1) &#123; console.log(&quot;第1个盘从&quot; + a + &quot;-&gt;&quot; + c); &#125; else &#123; //如果我们有n &gt;= 2情况,我们总是可以看做是两个盘1.最下边的一个盘2.上 面的所有盘 //1.先把最上面的所有盘A-&gt;B，移动过程会使用到C hanoiTower(num - 1, a, c, b); //2.把最下边的盘A-&gt;C console.log(&quot;第&quot; + num + &quot;个盘从&quot; + a + &quot;-&gt;&quot; + c); //3.把B塔的所有盘从B-&gt;C，移动过程使用到a塔 hanoiTower(num - 1, b, a, c); &#125;&#125;;console.log(hanoiTower(3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)); 24点判断是否可以通过运算得到 241234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var judgePoint = function (nums) &#123; if (nums.length == 1) return Math.abs(nums[0] - 24) &lt; 1e-6; for (let i = 0; i &lt; nums.length; i++) for (let j = i + 1; j &lt; nums.length; j++) &#123; let rest = nums.filter((value, index) =&gt; index != i &amp;&amp; index != j); if (judgePoint([nums[i] + nums[j], ...rest]) || judgePoint([nums[i] * nums[j], ...rest]) || judgePoint([nums[i] - nums[j], ...rest]) || judgePoint([nums[j] - nums[i], ...rest]) || judgePoint([nums[i] / nums[j], ...rest]) || judgePoint([nums[j] / nums[i], ...rest])) return true; &#125; return false;&#125; 列举所有可以得到 24的结果 思路：先计算 a, b 再组合 c，d; 要保证a,b,c,d都计算到，则需要计算a,b,c,d; a,c,b,d; a,d,c,b; b,c,a,d; b,d,c,a; c,d,b,a; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function dataWarp(...num) &#123; return num.map((a) =&gt; (&#123; m: a, r: a &#125;));&#125;function calm(a,b) &#123; var r = [ &#123; m: `($&#123;a.m&#125;+$&#123;b.m&#125;)`, r: a.r+b.r &#125;, &#123; m: `($&#123;a.m&#125;-$&#123;b.m&#125;)`, r: a.r-b.r &#125;, &#123; m: `($&#123;b.m&#125;-$&#123;a.m&#125;)`, r: b.r-a.r &#125;, &#123; m: `($&#123;a.m&#125;*$&#123;b.m&#125;)`, r: a.r*b.r &#125;, ]; a.r !== 0 &amp;&amp; r.push(&#123; m: `($&#123;b.m&#125;/$&#123;a.m&#125;)`, r: b.r/a.r &#125;); b.r !==0 &amp;&amp; r.push(&#123; m: `($&#123;a.m&#125;/$&#123;b.m&#125;)`, r: a.r/b.r &#125;); return r;&#125;function allCalm(a,b,c,d,u) &#123; var s = [], t = []; calm(a,b).forEach((i) =&gt; &#123; s = s.concat(calm(i, c)); t = t.concat(calm(i, d)); &#125;); s.forEach((i) =&gt; &#123; u = u.concat(calm(i, d)); &#125;); t.forEach((i) =&gt; &#123; u = u.concat(calm(i, c)); &#125;); return u;&#125;function get24(a,b,c,d) &#123; [a,b,c,d]= dataWarp(a,b,c,d); allCalm(c,d,b,a,allCalm(b,d,a,c,allCalm(b,c,a,d,allCalm(a,d,b,c,allCalm(a,c,b,d,allCalm(a,b,c,d,[])))))).forEach((i) =&gt; &#123; if (i.r === 24) &#123; console.log(i.m); &#125; &#125;);&#125;","comments":true,"tags":[]},{"title":"编译器工作原理","date":"2021-05-28T23:19:02.000Z","path":"2021/05/29/编译器工作原理/","text":"[TOC] 编译器工作流 解析 词法分析 语法分析 遍历 转化 代码生成 解析 解析(Parsing)解析是将最初原始的代码转换为一种更加抽象的表示(即AST) 词法分析接收原始代码,然后把它分割成一些token 语法分析接收之 前生成的token ， 把它们转换成一种抽象的表示AST(Vue与React互转) 词法分析(Lexical Analysis) 词法分析接收原始代码,然后把它分割成一些被称为token 的东西，这个过程是在词法分析器(Tokenizer或者Lexer)中完成的 原始代码 1&lt;h1 id=&quot;title&quot;&gt;hello world&lt;/h1&gt; token (分词) 1234567891011121314151617Module &#123; type: &apos;Program&apos;, body: [ ExpressionStatement &#123; type: &apos;ExpressionStatement&apos;, expression: [JSXElement] &#125; ], sourceType: &apos;module&apos;, tokens: [ &#123; type: &apos;Punctuator&apos;, value: &apos;&lt;&apos; &#125;, &#123; type: &apos;JSXIdentifier&apos;, value: &apos;h1&apos; &#125;, &#123; type: &apos;JSXIdentifier&apos;, value: &apos;id&apos; &#125;, &#123; type: &apos;Punctuator&apos;, value: &apos;=&apos; &#125;, &#123; type: &apos;String&apos;, value: &apos;&quot;title&quot;&apos; &#125;, &#123; type: &apos;Punctuator&apos;, value: &apos;&gt;&apos; &#125;, &#123; type: &apos;JSXText&apos;, value: &apos;hello world&apos; &#125;, &#123; type: &apos;Punctuator&apos;, value: &apos;&lt;&apos; &#125;, &#123; type: &apos;Punctuator&apos;, value: &apos;/&apos; &#125;, &#123; type: &apos;JSXIdentifier&apos;, value: &apos;h1&apos; &#125;, &#123; type: &apos;Punctuator&apos;, value: &apos;&gt;&apos; &#125; ] &#125; 实现方式(算法下一篇实现) 有限状态机 正则 语法分析(Syntactic Analysis)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ExpressionStatement&quot;, &quot;expression&quot;: &#123; &quot;type&quot;: &quot;JSXElement&quot;, &quot;openingElement&quot;: &#123; &quot;type&quot;: &quot;JSXOpeningElement&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;h1&quot;, &#125;, &quot;selfClosing&quot;: false, &quot;attributes&quot;: [ &#123; &quot;type&quot;: &quot;JSXAttribute&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;id&quot;, &#125;, &quot;value&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;title&quot;, &quot;raw&quot;: &quot;\\&quot;title\\&quot;&quot;, &#125; &#125; ] &#125;, &quot;children&quot;: [ &#123; &quot;type&quot;: &quot;JSXText&quot;, &quot;value&quot;: &quot;hello world&quot;, &quot;raw&quot;: &quot;hello world&quot; &#125; ], &quot;closingElement&quot;: &#123; &quot;type&quot;: &quot;JSXClosingElement&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;h1&quot;, &#125;, &#125;, &#125;, &#125; ],&#125; 实现方式(算法下一篇实现) 递归下降算法 遍历 对于上面的AST进行使用的是深度优先遍历。 转化 它只是把AST拿过来然后对它做一些修改。 代码生成 编译器的最后一个阶段是代码生成，根据AST来输出代码。","comments":true,"tags":[]},{"title":"日记","date":"2021-05-18T16:48:00.000Z","path":"2021/05/19/日记/","text":"题目 响应浏览器事件 展示当前浏览器窗口的宽高，并在窗口 resize 后实时反馈： 笔试 我当时的思路大体这样的： 1234567891011121314151617181920212223242526272829303132333435const throttle = (fn, time)=&gt;&#123; let timer = null; return (...args)=&gt;&#123; if(!timer)&#123; timer = setTimeout(()=&gt;&#123; fn.apply(this, args); timer = null &#125;, time) &#125; &#125;&#125;const useResize = (props)=&gt;&#123; const [p, setP] = useState(&#123;...props&#125;); const fn = function(e)&#123; setP(&#123;width: e.clientWidth, height: e.clientHeight&#125;) &#125; useEffect(()=&gt;&#123; window.onresize= throttle(fn, 100); return ()=&gt;&#123; window.onresize=null; &#125; &#125;, []) return [&#123;width: p.width, height: p.height&#125;, setP]&#125;const resizeComponent = ()=&gt;&#123; const [data, SetData] = useResize(&#123;width: 1, height: 1&#125;) return &lt;div&gt;&#123;data.width&#125; &#123;data.height&#125;&lt;/div&gt;&#125; 项目中 项目中是真实用到的，因为播放器的宽会随着屏幕变化 思考 涉及到一个实验中(Experimental)的 api: ResizeObserver，所以会涉及到兼容 参考链接：https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver 文中这样描述‘ResizeObserver避免了在自身回调中调整大小，从而触发的无限回调和循环依赖。它仅通过在后 续帧中处理DOM中更深层次的元素来实现这一点。’ 还跟浏览器渲染有点关系window.requestAnimationFrame 还跟react的合成事件有点关系，e.persist() 阻止重新设置事件的属性。 参考链接：https://reactjs.org/docs/legacy-event-pooling.html 实现 throttle 这个网上很多 123export const throttle = &lt;T extends any[]&gt;(func: (...arg: T) =&gt; void, delay = 0, flush = true) =&gt; &#123; .... 略 ...&#125;; 判断是否支持 ResizeObserver 123export function isSupported() &#123; return isBrowser() &amp;&amp; window.ResizeObserver &amp;&amp; typeof ResizeObserver === &apos;function&apos;;&#125; 工具函数 resizeHelper.js 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const resizeListeners = new Map&lt;Element | SVGElement, (rect: DOMRectReadOnly) =&gt; void&gt;();const observer = isSupported() ? new ResizeObserver(entries =&gt; &#123; ... 略... entries.forEach(entry =&gt; &#123; if (resizeListeners.has(entry.target)) &#123; resizeListeners.get(entry.target)!(entry.contentRect); &#125; &#125;); ... 略... &#125; : (() =&gt; &#123; let timer: any; const initTimer = () =&gt; &#123; timer = setInterval(() =&gt; &#123; ... 略... Array.from(resizeListeners.keys()).forEach((element: Element | SVGElement) =&gt; &#123; resizeListeners.get(element)!(element.getBoundingClientRect()); &#125;); &#125;, 500); &#125;; return &#123; observe() &#123; if (!timer) &#123; initTimer(); &#125; &#125;, unobserve() &#123; if (resizeListeners.size === 0 &amp;&amp; timer) &#123; clearInterval(timer); timer = null; &#125; &#125; &#125;; &#125;)();export default &#123; observe(element: Element | SVGElement, cb: (rect: DOMRectReadOnly) =&gt; void) &#123; if (!resizeListeners.has(element)) &#123; observer.observe(element); logger.debug(element, &apos;绑定resize事件&apos;); &#125; resizeListeners.set(element, throttle(cb, 200)); &#125;, unobserve(element: Element | SVGElement) &#123; if (resizeListeners.has(element)) &#123; observer.unobserve(element); logger.debug(element, &apos;解除resize事件&apos;); &#125; resizeListeners.delete(element); &#125;&#125;; 播放器使用 12345678910111213componentDidMount() &#123; if (this.container.current) &#123; if (isSupported()) &#123; ... 略... resizeHelper.observe(this.container.current, rect =&gt; &#123; this.setSize(rect.width); &#125;); &#125; &#125;&#125; 扩展MutationObserver MutationObserver 监视对DOM树所做更改的能力。包括 增加/删除 子元素，修改子元素属性。 MutationObserver 属于微任务。 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver12345..... 略 .....const observer = new MutationObserver(callback);// 以上述配置开始观察目标节点observer.observe(targetNode, config); IntersectionObserver IntersectionObserver一种异步检测目标元素与祖先元素或 viewport 相交情况变化的方法。 可以实现图片懒加载——当图片滚动到可见时才进行加载 属于轮询？ 12345678910// 实现图片懒加载// 原理，底部的div可见就调用函数observer = new IntersectionObserver(changes =&gt; &#123; changes.forEach(change =&gt; &#123; if (change.target == bottomRef.current &amp;&amp; change.isIntersecting) &#123; !stop &amp;&amp; nextPageFunc &amp;&amp; nextPageFunc(); &#125; &#125;); &#125;); observer.observe(bottomRef.current); 通过 IntersectionObserver 实现滑动到底部自动翻页 思考： 底部设置一个dom 元素 xx ，进入视口就加载下一页 封装一个公共组件 ScrollWrap ，异步列表做为组件的children ScrollWrap 每次重新渲染，是因为 xx 进入视口，请求下一页数据，假如每次都要创建 observer 对象，那什么时候应该销毁 observer 对象。(其实想想可以通过单例仅仅创建一个observer 对象)123456789101112131415161718192021222324252627282930313233343536373839404142434445// 相关变量 page， page变化创建新的 observer// useEffect 返回函数销毁上次 observer// 下一页没数据的时候，销毁上次 observer// 暴露一个获取下一页的 callbacklet observer!: IntersectionObserver;const bottomRef = React.createRef&lt;HTMLDivElement&gt;();const ScrollWrap = (&#123; children, page, nextPageFunc, stop &#125;: &#123; children: any; page: number; nextPageFunc: Function; stop?: boolean &#125;) =&gt; &#123; useEffect(() =&gt; &#123; if (!stop) &#123; observer = new IntersectionObserver(changes =&gt; &#123; changes.forEach(change =&gt; &#123; // console.error(&apos;scroll&apos;, stop, page, change, observer); if (change.target == bottomRef.current &amp;&amp; change.isIntersecting) &#123; !stop &amp;&amp; nextPageFunc &amp;&amp; nextPageFunc(); &#125; &#125;); &#125;); if (bottomRef.current) &#123; observer.observe(bottomRef.current); &#125; &#125; else &#123; observer?.disconnect(); &#125; return () =&gt; &#123; observer?.disconnect(); &#125;; &#125;, [stop, page]); return ( &lt;div className=&#123;css.siteScrollWrap&#125;&gt; &#123;children&#125; &lt;div className=&#123;css.more&#125; onClick=&#123;e =&gt; &#123; e.stopPropagation(); e.preventDefault(); !stop &amp;&amp; nextPageFunc &amp;&amp; nextPageFunc(); &#125;&#125; &gt; &#123;stop ? &apos;&apos; : &apos;--- 查看更多 ---&apos;&#125; &lt;/div&gt; &lt;div className=&#123;css.listBottom&#125; ref=&#123;bottomRef&#125;&gt;&lt;/div&gt; &lt;/div&gt; );&#125;; 上面那个还涉及到 page 这个参数该不该传的问题，跟如何去更新 page有关，hooks?变量?reducer? 另一种思路： 单例创建 observer ，无数据时销毁 observer 扩展思考： 这种写法难道不是观察者模式吗？ 它内部的实现可能类似下面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104function myObserver()&#123; const observer = (obj, targetVariable, callback)=&gt; &#123; Object.defineProperty(obj, targetVariable, &#123; get() &#123; return this.data[targetVariable] &#125;, set(val) &#123; this.data[targetVariable] = val // 目标主动通知观察者 callback &amp;&amp; callback(val) &#125;, &#125;) if (obj.data[targetVariable]) &#123; callback &amp;&amp; callback(obj.data[targetVariable]) &#125; &#125; const disconnect = (obj, targetVariable)=&gt;&#123; // 怎么把 descriptor.writable: false &#125; return &#123; observer, disconnect &#125; &#125; let myOber = new myObserver() // 目标 const obj = &#123; data: &#123; description: &apos;原始值&apos; &#125;, &#125; // 观察者 myOber.observer(obj, &apos;description&apos;, value =&gt; &#123; const div = document.createElement(&apos;div&apos;); div.innerHTML = value document.body.appendChild(div) &#125;) setInterval(()=&gt;&#123; obj.description = &apos;改变了对象的值&apos;+Math.random() &#125;, 1000)var New =function(fn)&#123; var obj=&#123;&#125;; obj.__proto__=fn.prototype; // 将 arguments 对象转为数组 var args = [].slice.call(arguments, 1); // 执行构造函数并改变this对象 var result = fn.apply(obj, args); return result instanceof Object ? result : obj&#125; // 比较常见的观察者模式//观察者列表function ObserverList()&#123; this.observerList = [];&#125;ObserverList.prototype.add = function( obj )&#123; return this.observerList.push( obj );&#125;;ObserverList.prototype.count = function()&#123; return this.observerList.length;&#125;;ObserverList.prototype.get = function( index )&#123; if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length )&#123; return this.observerList[ index ]; &#125;&#125;;ObserverList.prototype.indexOf = function( obj, startIndex )&#123; var i = startIndex; while( i &lt; this.observerList.length )&#123; if( this.observerList[i] === obj )&#123; return i; &#125; i++; &#125; return -1;&#125;;ObserverList.prototype.removeAt = function( index )&#123; this.observerList.splice( index, 1 );&#125;;//目标function Subject()&#123; this.observers = new ObserverList();&#125;Subject.prototype.addObserver = function( observer )&#123; this.observers.add( observer );&#125;;Subject.prototype.removeObserver = function( observer )&#123; this.observers.removeAt( this.observers.indexOf( observer, 0 ) );&#125;;Subject.prototype.notify = function( context )&#123; var observerCount = this.observers.count(); for(var i=0; i &lt; observerCount; i++)&#123; this.observers.get(i).update( context ); &#125;&#125;;//观察者function Observer()&#123; this.update = function()&#123; // ... &#125;;&#125;","comments":true,"tags":[]},{"title":"vscode调试xxx.js","date":"2021-05-18T16:46:09.000Z","path":"2021/05/19/vscode调试xxx-js/","text":"调试 js文件vscode 版本: 1.56.2调试js文件时默认添加的配置是这样的123456789&#123; &quot;type&quot;: &quot;pwa-node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/crawl/compiler/src/parser.js&quot; &#125; 你会发现不管怎么搞都走不到断点，这是为什么呢？？？？？？其实你只需要修改 type 参数就可以了。 保证 type 和 路径正确，可以调试 123456789&#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/crawl/compiler/src/parser.js&quot; &#125; 修改 settings.json去除掉 &quot;debug.javascript.usePreview&quot;: false,后发现，即使 “type”: “node” 都走不了断点，不好使。 并且 debugger 运行时必须选择 Launch Progrem 。难道要和 launch.json 中的name 值一致？ 另一台 mac但是我换另一台mac笔记本配置如下，却是可以正常 debugger 的，那我就不知道为什么了：123456789&#123; &quot;name&quot;: &quot;Launch Program&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/compiler/src/parser.js&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;type&quot;: &quot;pwa-node&quot; &#125; node 和 pwa-node的区别：https://segmentfault.com/q/1010000023049217?utm_source=tag-newest","comments":true,"tags":[]},{"title":"youtube札记","date":"2020-11-09T02:15:44.000Z","path":"2020/11/09/youtube札记/","text":"并查集(Disjoint-set)： 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。 主要操作 查找(Find)：查找元素所在的集合，即根节点。 合并(Unit)：将两个元素所在的集合合并为一个集合。 例题：检测无向图图中是否有环？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const checkCycle = ()=&gt;&#123; let paths = [[0,1],[1,2],[2, 5],[2, 4],[1, 3],[3, 4]]; // 初始化 // 添加注意初始化数组的长度跟节点个数n有关系，防止出现undefined。 let arr = new Array(6).fill(-1); let rank = new Array(6).fill(0); // 错误，是在unit 合并时才集合链 // const init= (paths, arr)=&gt;&#123; // paths.forEach(([x,y])=&gt;&#123; // arr[x] = y // &#125;) // &#125; const findParent= (x)=&gt;&#123; let p = x; while(arr[p]!==-1)&#123; p = arr[p] &#125; return p &#125; // 是否合并,连接起来 const unit = (x, y, arr)=&gt;&#123; let x_p = findParent(x); let y_p = findParent(y); // 父节点相同，说明已经链接起来了 if(x_p === y_p) return false else &#123; if(rank[x_p]&gt;rank[y_p]) &#123; arr[y_p] = x_p &#125; else if(rank[x_p]&lt;rank[y_p])&#123; arr[x_p] = y_p &#125; else &#123; rank[y_p]++ // unit 合并时才生成链 arr[x_p] = y_p &#125; return true &#125; &#125; // init(paths, arr) for(let [x, y] of paths)&#123; // 无需合并存在圈 if(!unit(x, y, arr)) &#123; return true &#125; &#125; return false&#125;console.log(checkCycle()) 堆排序 heapSort 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 初始化堆复杂度O(n), 堆排序复杂度O(n*logn)。 完全二叉树：生成节点的顺序是从上到下，从左到右的顺序进行编号。与满二叉树中编号，在二叉树中的位置相同。 大顶堆： 父节点值&gt;子节点值，且为完全二叉树。 例题：初始化大顶堆？排序时重写构建大顶堆？ 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let heap = ()=&gt;&#123; const swap = (tree, a, b)=&gt;&#123; if(a === b) return let tmp = tree[a]; tree[a] = tree[b]; tree[b] = tmp &#125;// O(logn) const heapify = (tree, n, i)=&gt;&#123; if(i&gt;=n) return let c1 = 2*i+1; let c2 = 2*i+2; let max = i; if(c1&lt;n &amp;&amp; tree[c1]&gt;tree[max])&#123; max = c1 &#125; if(c2&lt;n &amp;&amp; tree[c2]&gt;tree[max])&#123; max = c2 &#125; if(max !==i)&#123; swap(tree, max, i) heapify(tree, n, max) &#125; &#125;// 这个构建堆也应该是 nlog(n) const buildHeap = (tree, n)=&gt;&#123; // 最末尾节点索引 let lastNode = n-1; // 最末尾父节点开始向上 heapify let parent = Math.floor((lastNode-1)/2); for(let i=parent; i&gt;=0; i--)&#123; heapify(tree, n, i) &#125; &#125; const heapSort = (tree, n)=&gt;&#123; buildHeap(tree, n); for(let i=n-1; i&gt;=0; i--)&#123; // 顶点和末尾交换 swap(tree, i, 0) heapify(tree, i, 0) &#125; console.log(&apos;sort: &apos;,tree) &#125; let tree = [4, 10, 3, 5, 1, 2,6, 7, 8]; let n=9; // 构建二叉树 结果1 buildHeap(tree, n)// 堆排序 结果2 heapSort(tree, n) console.log(&apos;tree: &apos;,tree)&#125; // 结果1// 结果2 heapSort2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class MaxHeap &#123; // 数组索引决定堆的排列，所以只是交换索引对应的值 arr = []; left(i)&#123; return i*2+1 &#125; right(i)&#123; return i*2+2 &#125; parent(i)&#123; return Math.floor((i-1)/2) &#125; swap(i, j)&#123; if(i===j) return; let tmp = this.arr[i]; this.arr[i] = this.arr[j]; this.arr[j] = tmp &#125; // 保证坐标i要不断下沉 sink(i)&#123; let len = this.arr.length; // 或运算时短路求值 while(this.left(i)&lt;len || this.right(i)&lt;len)&#123; let max = this.arr[i], m = i, l = this.left(i), r = this.right(i); if(this.arr[l]&gt;=max) &#123; max = this.arr[l] m = l &#125; if(this.arr[r]&gt;=max) &#123; max = this.arr[r] m = r &#125; // i===m 说明顺序对，不必下沉，避免死循环 if(i===m) break this.swap(i, m) i = m; &#125; &#125; // 保证i能持续上浮，i的兄弟不管 swim(i)&#123; let p; // i &gt; 0 能避免掉初始数组是 空 的情况, 还有 this.parent(0) undefind 情况。 while(i&gt;0 &amp;&amp; (this.arr[p = this.parent(i)]&lt;=this.arr[i]))&#123; this.swap(i, p) i=p; &#125; &#125; // 放入末尾，然后上浮 insert(v)&#123; this.arr.push(v) this.swim(this.arr.length-1) &#125; delMax()&#123; let max = this.arr[0]; this.swap(0, this.arr.length-1); this.arr.pop() this.sink(0) return max; &#125;&#125;var findKthLargest = function(nums, k) &#123; let maxheap = new MaxHeap(); nums.forEach(n=&gt;maxheap.insert(n)) console.log(&apos;xx: &apos;,maxheap.arr)let r;let sr = []; while(k--)&#123; r = maxheap.delMax()sr.unshift(r)&#125;console.log(‘sr: ’, sr)return r&#125;;let nums = [4, 10, 3, 5, 1, 2,6, 7, 8];let k=9;console.log(findKthLargest(nums, k)) // xx 的结果// sr 结果 最短路径 Dijkstra 是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。 例题： 遍历graph， a到各个点的最短距离： 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let graph=&#123; &apos;a&apos;: &#123;&apos;b&apos;:5, &apos;c&apos;:1&#125;, &apos;b&apos;: &#123;&apos;a&apos;:5, &apos;c&apos;:2, &apos;d&apos;:1&#125;, &apos;c&apos;: &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;d&apos;:4, &apos;e&apos;:8&#125;, &apos;d&apos;: &#123;&apos;b&apos;:1, &apos;c&apos;:4, &apos;e&apos;:3, &apos;f&apos;:6&#125;, &apos;e&apos;: &#123;&apos;c&apos;:8, &apos;d&apos;:3&#125;, &apos;f&apos;: &#123;&apos;d&apos;:6&#125;&#125;const distance = (s)=&gt;&#123; let d = &#123;[s]:0&#125;; for(let k in graph)&#123; if(k!==s)&#123; d[k]=Infinity &#125; &#125; return d&#125;const dijkstra = (s)=&gt;&#123; let q = new MinPriorityQueue(&#123; priority: (turn) =&gt; turn.value &#125;) q.enqueue(&#123; name: s, value: 0 &#125;) let visited = new Set(); let parent = &#123;[s]:-1&#125;; let d = distance(s); while(q.size())&#123; const &#123; priority: p, element: e&#125; = q.dequeue(); let en = e.name; visited.add(en); let ns = Object.keys(graph[en]); ns.forEach(n=&gt;&#123; // 相邻边必然存在已经访问过的，所有要过滤 if(!visited.has(n))&#123; // p en节点的最短距离 let np = p + graph[en][n] if(np &lt; d[n])&#123; // 这样就可能存在距离不同的，多个重复名字的点 q.enqueue(&#123; name: n, value: np &#125;) parent[n] = en; d[n] = np &#125; &#125; &#125;) &#125; return [parent, d]&#125;let [p, d] = dijkstra(&apos;a&apos;);console.log(&apos;parent: &apos;,p)console.log(&apos;distance: &apos;, d) BFS 123456789101112131415161718192021222324252627let graph=&#123; &apos;a&apos;: [&apos;b&apos;, &apos;c&apos;], &apos;b&apos;: [&apos;a&apos;, &apos;c&apos;, &apos;d&apos;], &apos;c&apos;: [&apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;], &apos;d&apos;: [&apos;b&apos;, &apos;c&apos;, &apos;e&apos;, &apos;f&apos;], &apos;e&apos;: [&apos;c&apos;, &apos;d&apos;], &apos;f&apos;: [&apos;d&apos;]&#125;const bfs = (s)=&gt;&#123; let q = [s]; let v = new Set(); while(q.length)&#123; let n = q.shift(); v.add(n) let ns = graph[n]; ns.forEach(n=&gt;&#123; if(!v.has(n))&#123; q.push(n) &#125; &#125;) &#125; console.log(&apos;r: &apos;, [...v])&#125;console.log(bfs(&apos;a&apos;))// 结果r: (6) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] DFS1 12345678910111213141516171819const dfs = (s)=&gt;&#123; let stack = [s]; let v = new Set(); while(stack.length)&#123; let n = stack.pop(); v.add(n) let ns = graph[n]; ns.forEach(n=&gt;&#123; if(!v.has(n))&#123; stack.push(n) &#125; &#125;) &#125; console.log(&apos;r: &apos;, [...v])&#125;console.log(dfs(&apos;a&apos;))// 结果r: (6) [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;d&quot;, &quot;f&quot;, &quot;b&quot;] DFS2 1234567891011121314151617181920let v = new Set();const dfs = (s, v) =&gt;&#123; if(!s)&#123; return &#125; v.add(s); console.log(&apos;前序r: &apos;, [...v]); let ns = graph[s] if(ns.length) &#123; ns.forEach(n=&gt;&#123; if(!v.has(n))&#123; dfs(n, v) &#125; &#125;) &#125; &#125;console.log(dfs(&apos;a&apos;, v))// 结果 前序r: (6) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 线段树 线段树，线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 例题：随机取数组连续一部分求和，随机修改 的复杂度。 Query O(n) =&gt; O(logn) Update O(logn) 动态规划 DP(Dynamic Programming) Fibonacci sequence,O(2^n) =&gt; O(n) 这么个思想。 爬楼梯 背包9讲 KMP 字符串匹配算法 根据前缀和后缀相同，匹配完第一轮，匹配第二轮时看能不能直接匹配后缀。 复杂度 O(m+n) 步骤 1.求出前缀表。 当下个字符匹配时： len 目前达到的最长公共前缀的长度，比较长度； i 是prefix数组当前的索引，prefix[0]=0, i从第一个字母比较； 当下一个不匹配时： 为了好计算，prefix整体右移，将prefix[0] = -1， 1234567891011121314151617181920212223242526272829303132333435function prefix_table(pattern, prefix, n) &#123; prefix[0] = 0; let len = 0; let i= 1; while(i&lt;n)&#123; if( pattern[i] == pattern[len] ) &#123; len++; prefix[i] = len; i++; &#125; else &#123; if(len&gt;0)&#123; len = prefix[len - 1]; &#125; else &#123; // len === 0 prefix[i] = len; i++; &#125; &#125; &#125;&#125;function move_prefix_table(prefix, n) &#123; for (let i=n-1; i&gt;0; i--)&#123; prefix[i] = prefix[i-1]; &#125; prefix[0] = -1;&#125;let pattern = &quot;ABABCABAA&quot;;let prefix = new Array(9);let n=9;// 下面这2个api可通用prefix_table(pattern, prefix, n);move_prefix_table(prefix, n);console.log(&apos;prefix: &apos;,prefix) 2.开始匹配： 相同 i++, j++； 不相同如下图： j 从指向4C，指向2A, 1234567891011121314151617181920212223242526272829303132333435 let pattern = &quot;ABABCABAA&quot;;let text = &quot;ABABABCABAABABABABA&quot;; // 2// let text = &quot;ABABABABCABAAB&quot;; // 4function kmp_search(text, pattern)&#123; let n = pattern.length; let m = text.length; let prefix = new Array(n); let i=0; let j=0; prefix_table(pattern, prefix, n); move_prefix_table(prefix, n); // text[i] , len(text), = m // pattern[j] , len(pattern) = n while(i &lt; m)&#123; if (j==n - 1 &amp;&amp; text[i] == pattern[j]) &#123; console.log(&quot;Found pattern&quot;, i - j); // 找到后，继续往下匹配，看还有没有 j = prefix[j]; &#125; if (text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = prefix[j]; if(j==-1)&#123; i++; j++; &#125; &#125; &#125;&#125;kmp_search(text, pattern)// 结果应该是2 参考例题：https://leetcode-cn.com/problems/implement-strstr/submissions/","comments":true,"tags":[]},{"title":"decorator","date":"2020-10-31T14:54:43.000Z","path":"2020/10/31/decorator/","text":"装饰器 ES6的装饰器，是一种函数。可以修饰类，属性和方法。 修饰类 第一个参数就是这个类 结果 嵌套装饰器的执行顺序类似洋葱模型 结果 修饰属性 结果 修饰方法 结果 IOC(Inversion of Control) &amp; DI(Dependency Injection) 控制反转。一种编程思想，无需手动创建实例，交给容器去做。所有服务统一注册到容器中，当用户需要时特定服务时，容器会负责该服务及其依赖的创建和管理。像朝鲜的社会主义体系。 依赖注入。需要哪个服务注入哪个服务。控制反转依靠依赖注入实现。 应用：nestjs, midwayjs, springMVC。","comments":true,"tags":[]},{"title":"札记","date":"2020-08-30T14:48:44.000Z","path":"2020/08/30/札记/","text":"网上偶然看见一道题12345678910111213141516const delay = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));const subFlow = createFlow([() =&gt; delay(1000).then(() =&gt; log(&quot;c&quot;))]);createFlow([ () =&gt; log(&quot;a&quot;), () =&gt; log(&quot;b&quot;), subFlow, [() =&gt; delay(1000).then(() =&gt; log(&quot;d&quot;)), () =&gt; log(&quot;e&quot;)],]).run(() =&gt; &#123; console.log(&quot;done&quot;);&#125;);// 需要按照 a,b,延迟1秒,c,延迟1秒,d,e, done 的顺序打印复制代码按照上面的测试用例，实现 createFlow：1.flow 是指一系列 effects 组成的逻辑片段。2.flow 支持嵌套。3.effects 的执行只需要支持串行。 如果是异步串行呢，想到的就是用next函数了， 12345678910111213141516const log = console.log;function createFlow(effects)&#123; effects = effects.flat(); return &#123; async run (cb)&#123; for (let i = 0; i &lt; effects.length; i++) &#123; if(effects[i].run)&#123; await effects[i].run() &#125; else &#123; await effects[i]() &#125; &#125; cb &amp;&amp; cb() &#125; &#125; &#125; async await通过 babel 转义成 generator 1234// 测试代码async function test()&#123; await 1&#125; 1234567891011121314151617181920// 测试代码转义后// https://babeljs.io/...function _test() &#123; _test = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() &#123; return regeneratorRuntime.wrap(function _callee$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return 1; case 2: case &quot;end&quot;: return _context.stop(); &#125; &#125; &#125;, _callee); &#125;)); 而 generator 内部实现也是通过 next 函数执行， 就是下面的 _next 123456789101112131415161718192021222324...function asyncGeneratorStep( gen, resolve, reject, _next, _throw, key, arg ) &#123; try &#123; var info = gen[key](arg); var value = info.value; &#125; catch (error) &#123; reject(error); return; &#125; if (info.done) &#123; resolve(value); &#125; else &#123; Promise.resolve(value).then(_next, _throw); &#125; &#125; 将下面 generator 测试函数babel 编译后, 发现确实是和 async + await一样都用了 regeneratorRuntime 1234567891011121314function *test()&#123; let n1 = yield new Promise(r=&gt;setTimeout(()=&gt;r(1), 1000)); let n2 = yield new Promise(r=&gt;setTimeout(()=&gt;r(2+n1), 1000)); return n2 &#125; const gen = test() let &#123; value, done &#125; = gen.next(); value.then((data) =&gt; &#123; console.log(&apos;then: &apos;,data); let &#123; value, done &#125; = gen.next(data); value.then(function (data) &#123; console.log(&apos;then: &apos;,data); &#125;); &#125;); 123456789101112131415161718192021...return regeneratorRuntime.wrap(function test$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return new Promise(function (r) &#123; return setTimeout(function () &#123; return r(1); &#125;, 1000); &#125;); case 2: n1 = _context.sent; _context.next = 5; return new Promise(function (r) &#123; return setTimeout(function () &#123; return r(2 + n1); &#125;, 1000); &#125;); ...... generator 函数执行又会产生一个迭代器, 例如下面2 函数是等价的 1234567891011121314let arr = [...&#123;0: 1, 1: 2, 2: 3,length: 3, [Symbol.iterator]:function()&#123; let i = 0; return &#123; next: ()=&gt;&#123; return i&gt;this.length? &#123;done: true, value: undefined&#125; : &#123;done: false, value: this[i++]&#125; &#125; &#125; &#125; &#125;] for(let e of arr)&#123; console.log(&apos;e: &apos;, e) &#125; 12345678910111213let arr = [...&#123;0: 1, 1: 2, 2: 3,length: 3, [Symbol.iterator]: function*()&#123; let i=0; while(i!==this.length)&#123; yield this[i++] &#125; yield this[i] &#125; &#125;] for(let e of arr)&#123; console.log(&apos;e: &apos;, e) &#125; 上面在处理Promise的过程可以优化成 co 库的形式 1234567891011121314151617function myCo(it) &#123; return new Promise((resolve, reject) =&gt; &#123; function next(r) &#123; let &#123; value, done &#125; = it.next(r); if (!done) &#123; Promise.resolve(value).then((r) =&gt; &#123; console.log(&quot;r: &quot;, r); next(r); &#125;); &#125; else &#123; resolve(value); &#125; &#125; next(); &#125;); &#125; myCo(gen).then((data) =&gt; console.log(&quot;myCo: &quot;, data)); async + await 是 generator + co 的语法糖 express 和 koa 中间件原理也是通过 next 来顺序执行数组中的回调函数。 控制请求并发个数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let urls = [&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;,&#123;status:&apos;wait&apos; &#125;], max = 3, counter = 0, retry = new Array(10).fill(0); const request = (urls, max)=&gt;&#123; return new Promise((resolve, reject)=&gt;&#123; let len = urls.length; const ajax = (config)=&gt;&#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; // resolve(&apos;ok&apos;) console.log(&apos;loading: &apos;,config.i) if(Math.random()&gt;.3)&#123; resolve(&apos;ok&apos;) &#125;else&#123; reject(&apos;error&apos;) &#125; &#125;, 1000) &#125;) &#125; const upload = ()=&gt;&#123; console.log(&apos;再次开启max: &apos;,max) while(max &amp;&amp; counter &lt; len)&#123; max--; // 只能在这 max--, 写到 while判断会再次减1 const i = urls.findIndex(v=&gt;v.status==&apos;wait&apos;|| v.status==&apos;error&apos;) urls[i].status = &apos;uploading&apos; ajax(&#123;i&#125;) .then(data=&gt;&#123; console.log(&apos;ok thunk index: &apos;,i) urls[i].status = &apos;done&apos; max++; counter++; if(counter === len)&#123; console.log(&apos;finish urls: &apos;,urls) resolve() &#125; else &#123; upload(); &#125; &#125;) .catch(()=&gt;&#123; urls[i].status = &apos;error&apos; retry[i]++ console.log(&apos;error thunk index: &apos;,i, &apos;retry times: &apos;,retry[i]) if(retry[i]&gt;=2)&#123; // 某个下载失败 console.log(&apos;fail thunk index: &apos;,i) reject() &#125; max++; upload() &#125;) &#125; &#125; upload() &#125;) &#125; request(urls, max)","comments":true,"tags":[]},{"title":"算法题","date":"2020-07-26T13:47:55.000Z","path":"2020/07/26/算法leetcode/","text":"概率最大的路径给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 示例 1： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2输出：0.25000解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25示例 2： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2输出：0.30000示例 3： 输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2输出：0.00000解释：节点 0 和 节点 2 之间不存在路径 提示： 2 &lt;= n &lt;= 10^40 &lt;= start, end &lt; nstart != end0 &lt;= a, b &lt; na != b0 &lt;= succProb.length == edges.length &lt;= 2*10^40 &lt;= succProb[i] &lt;= 1每两个节点之间最多有一条边 这个是一个关于“图的最短路径”问题。 可以考虑使用bfs+优先队列的方法，但是js没有PriorityQueue这种数据结构，可以粗略这样处理。 12345678910111213141516171819202122232425262728293031var maxProbability = function(n, edges, succProb, start, end) &#123; let vi = new Array(n).fill(false); let path = new Array(n) while(n--)&#123; path[n] = [] &#125; for (let i = 0; i &lt; edges.length; i++) &#123; let e = edges[i]; path[e[0]].push([succProb[i], e[1]]); path[e[1]].push([succProb[i], e[0]]); &#125; let pq = []; pq.push([ 1, start]); while (pq.length) &#123; let [curProb, cur] = pq.shift()// pq.pop(); pop是操作数组的后边 if (vi[cur]) continue; vi[cur] = true; if (cur == end) return curProb; let pp =path[cur]; for(let i=0; i&lt;pp.length; i++)&#123; let [nextProb, next] = pp[i]; if (vi[next]) continue; pq.push([curProb * nextProb, next]); // 9000多数据每次排序， ST算法，RMQ问题 | 堆 pq.sort((a, b)=&gt;b[0]-a[0]) &#125; &#125; return 0;&#125;; 但是这样处理的话，当测试用例的节点数达到 10000 时就会超时。 其实优先队列是Dijkstra算法 的一种优化，将时间复杂度从 O(n^2) 降到 O((m+n)logn)，m边数，n是顶点数。优先队列的内部似乎是斐波那契堆(Fibonacci heap)Fibonacci heap，这里不要求那么严格由于是要概率最大的路径，所以实现一个最大堆。 Dijkstra (Dijkstra)之优先队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203// 最大堆实现 https://github.com/datastructures-jsclass HeapNode &#123; constructor(key, value) &#123; this._key = key; this._value = value; &#125; getKey() &#123; return this._key; &#125; getValue() &#123; return this._value; &#125;&#125;class Heap &#123; constructor(nodes) &#123; this._nodes = Array.isArray(nodes) ? nodes : []; this._leaf = null; &#125; size() &#123; return this._nodes.length; &#125; _swap(i, j) &#123; const temp = this._nodes[i]; this._nodes[i] = this._nodes[j]; this._nodes[j] = temp; &#125; root() &#123; if (this.isEmpty()) return null; return this._nodes[0]; &#125; insert(key, value) &#123; const newNode = new HeapNode(key, value); this._nodes.push(newNode); this._heapifyUp(); return newNode; &#125; _getLeftChildIndex(parentIndex) &#123; return (parentIndex * 2) + 1; &#125; _getRightChildIndex(parentIndex) &#123; return (parentIndex * 2) + 2; &#125; _compareChildrenOf(parentIndex) &#123; const leftChildIndex = this._getLeftChildIndex(parentIndex); const rightChildIndex = this._getRightChildIndex(parentIndex); const size = this.size(); if (leftChildIndex &gt;= size &amp;&amp; rightChildIndex &gt;= size) return -1; if (leftChildIndex &gt;= size) return rightChildIndex; if (rightChildIndex &gt;= size) return leftChildIndex; return this._compareChildren(leftChildIndex, rightChildIndex); &#125; _heapifyUp() &#123; let childIndex = this._getLastIndex(); let parentIndex = this._getParentIndex(childIndex); while (this._shouldSwap(childIndex, parentIndex)) &#123; this._swap(childIndex, parentIndex); childIndex = parentIndex; parentIndex = this._getParentIndex(childIndex); &#125; &#125; _getLastIndex() &#123; return this._nodes.length - 1; &#125; _getParentIndex(childIndex) &#123; return Math.floor((childIndex - 1) / 2); &#125; _heapifyDown() &#123; let parentIndex = 0; let childIndex = this._compareChildrenOf(parentIndex); while (this._shouldSwap(childIndex, parentIndex)) &#123; this._swap(childIndex, parentIndex); parentIndex = childIndex; childIndex = this._compareChildrenOf(parentIndex); &#125; &#125; isEmpty() &#123; return this.size() === 0; &#125; extractRoot() &#123; if (this.isEmpty()) return null; const root = this.root(); this._nodes[0] = this._nodes[this._getLastIndex()]; this._nodes.pop(); this._heapifyDown(); if (root === this._leaf) &#123; if (this.isEmpty()) &#123; this._leaf = null; &#125; else &#123; this._leaf = this.root(); &#125; &#125; return root; &#125;&#125;class MaxHeap extends Heap &#123; _getMaxChildIndex(leftChildIndex, rightChildIndex) &#123; const leftChild = this._nodes[leftChildIndex]; const rightChild = this._nodes[rightChildIndex]; if (leftChild.getKey() &gt; rightChild.getKey()) &#123; return leftChildIndex; &#125; return rightChildIndex; &#125; _compareChildren(leftChildIndex, rightChildIndex) &#123; return this._getMaxChildIndex(leftChildIndex, rightChildIndex); &#125; _shouldSwap(childIndex, parentIndex) &#123; if (childIndex &lt; 0 || childIndex &gt;= this.size()) return false; if (parentIndex &lt; 0 || parentIndex &gt;= this.size()) return false; const child = this._nodes[childIndex]; const parent = this._nodes[parentIndex]; return child.getKey() &gt; parent.getKey(); &#125;&#125;class PriorityQueue &#123; constructor(options = &#123;&#125;) &#123; const &#123; priority &#125; = options; if (priority !== undefined &amp;&amp; typeof priority !== &apos;function&apos;) &#123; throw new Error(&apos;invalid priority callback&apos;); &#125; this._getPriority = typeof priority === &apos;function&apos; ? priority : null; &#125; size() &#123; return this._heap.size(); &#125; isEmpty() &#123; return this._heap.isEmpty(); &#125; enqueue(element, priority) &#123; if (priority &amp;&amp; (Number.isNaN(+priority))) &#123; throw new Error(&apos;invalid priority number&apos;); &#125; if (!priority &amp;&amp; this._getPriority === null) &#123; throw new Error(&apos;missing priority number or constructor callback&apos;); &#125; this._heap.insert(priority || this._getPriority(element), element); &#125; dequeue() &#123; if (this.isEmpty()) return null; const first = this._heap.extractRoot(); return &#123; priority: first.getKey(), element: first.getValue() &#125;; &#125;&#125;class MaxPriorityQueue extends PriorityQueue &#123; constructor(options) &#123; super(options); this._heap = new MaxHeap(); &#125;&#125;// 最小堆class MinHeap extends Heap &#123; insert(key, value) &#123; const newNode = super.insert(key, value); if (this._leaf === null || key &gt; this._leaf.getKey()) &#123; this._leaf = newNode; &#125; return newNode; &#125; _getMinChildIndex(leftChildIndex, rightChildIndex) &#123; const leftChild = this._nodes[leftChildIndex]; const rightChild = this._nodes[rightChildIndex]; if (leftChild.getKey() &lt; rightChild.getKey()) &#123; return leftChildIndex; &#125; return rightChildIndex; &#125; _compareChildren(leftChildIndex, rightChildIndex) &#123; return this._getMinChildIndex(leftChildIndex, rightChildIndex); &#125; _shouldSwap(childIndex, parentIndex) &#123; if (childIndex &lt; 0 || childIndex &gt;= this.size()) return false; if (parentIndex &lt; 0 || parentIndex &gt;= this.size()) return false; const child = this._nodes[childIndex]; const parent = this._nodes[parentIndex]; return child.getKey() &lt; parent.getKey(); &#125;&#125;class MinPriorityQueue extends PriorityQueue &#123; constructor(options) &#123; super(options); this._heap = new MinHeap(); &#125;&#125;let patientsQueue = new MinPriorityQueue(); 应用上面的最大堆 123456789101112131415161718192021222324252627282930var maxProbability = function(n, edges, succProb, start, end) &#123; let vi = new Array(n).fill(false); let path = new Array(n) while(n--)&#123; path[n] = [] &#125; for (let i = 0; i &lt; edges.length; i++) &#123; let e = edges[i]; path[e[0]].push([succProb[i], e[1]]); path[e[1]].push([succProb[i], e[0]]); &#125; let pq = new MaxPriorityQueue() pq.enqueue(start, 1) while (!pq.isEmpty()) &#123; let &#123;element: cur, priority: curProb&#125; = pq.dequeue() if (vi[cur]) continue; vi[cur] = true; if (cur == end) return curProb; let pp =path[cur]; for(let i=0; i&lt;pp.length; i++)&#123; let [nextProb, next] = pp[i]; if (vi[next]) continue; pq.enqueue(next, curProb * nextProb) &#125; &#125; return 0;&#125;; Bellman-Ford 算法 Bellman-Ford也是一种求最短路径的方法 1234567891011121314151617181920212223// Bellman-Ford， 100000节点 10ms 多; //https://zhuanlan.zhihu.com/p/72185593// https://www.cnblogs.com/lxt1105/p/6477639.htmlvar maxProbability = function(n, edges, succProb, start, end) &#123; // 求最大值，初始赋值最小；反之 let dp = new Array(n).fill(0); dp[start] = 1; while(true)&#123; let k = false; for(let j=0; j&lt;edges.length; j++)&#123; if(dp[edges[j][0]] * succProb[j] &gt; dp[edges[j][1]])&#123; dp[edges[j][1]] = dp[edges[j][0]] * succProb[j]; k = true; &#125; if (dp[edges[j][1]] * succProb[j] &gt; dp[edges[j][0]]) &#123; dp[edges[j][0]] = dp[edges[j][1]] * succProb[j]; k = true; &#125; &#125; if(!k) break; &#125; return dp[end]&#125; 子树中标签相同的节点数给你一棵树（即，一个连通的无环无向图），这棵树由编号从 0 到 n - 1 的 n 个节点组成，且恰好有 n - 1 条 edges 。树的根节点为节点 0 ，树上的每一个节点都有一个标签，也就是字符串 labels 中的一个小写字符（编号为 i 的 节点的标签就是 labels[i] ） 边数组 edges 以 edges[i] = [ai, bi] 的形式给出，该格式表示节点 ai 和 bi 之间存在一条边。 返回一个大小为 n 的数组，其中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数。 树 T 中的子树是由 T 中的某个节点及其所有后代节点组成的树。 示例 1： 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = “abaedcd”输出：[2,1,1,1,1,1,1]解释：节点 0 的标签为 ‘a’ ，以 ‘a’ 为根节点的子树中，节点 2 的标签也是 ‘a’ ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。节点 1 的标签为 ‘b’ ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。示例 2： 输入：n = 4, edges = [[0,1],[1,2],[0,3]], labels = “bbbb”输出：[4,2,1,1]解释：节点 2 的子树中只有节点 2 ，所以答案为 1 。节点 3 的子树中只有节点 3 ，所以答案为 1 。节点 1 的子树中包含节点 1 和 2 ，标签都是 ‘b’ ，因此答案为 2 。节点 0 的子树中包含节点 0、1、2 和 3，标签都是 ‘b’，因此答案为 4 。示例 3： 输入：n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = “aabab”输出：[3,2,1,1,1]示例 4： 输入：n = 6, edges = [[0,1],[0,2],[1,3],[3,4],[4,5]], labels = “cbabaa”输出：[1,2,1,1,2,1]示例 5： 输入：n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]], labels = “aaabaaa”输出：[6,5,4,1,3,2,1] 提示： 1 &lt;= n &lt;= 10^5edges.length == n - 1edges[i].length == 20 &lt;= ai, bi &lt; nai != bilabels.length == nlabels 仅由小写英文字母组成 由于当时第一时间想到的是图的遍历， 所以我就这么写了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var countSubTrees = function(n, edges, labels) &#123; let path = new Array(n); let n1 = n; while(n1--)&#123; path[n1] = []; &#125; edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push([e, labels[e]]); path[e].push([s, labels[s]])&#125;);.....// p&gt;num 子树 const isSub = (p, num)=&gt;&#123; // p必须在下面 let rp = getLen(p); let rn = getLen(num); if(rp&gt;rn) return true return false &#125; const getNum = (num)=&gt;&#123; let r = 1; let v = new Array(n).fill(false); let l1 = labels[num]; // node label let s = [num, l1]; let stack = []; stack.push(s) while(stack.length)&#123; let [s, l] = stack.shift(); if(v[s]) continue; v[s] = true let pp = path[s]; for(let i=0; i&lt;pp.length; i++)&#123; let [p, n] = pp[i]; if(v[p]) continue; // p是num的子节点 if(isSub(p, num)) &#123; if(n == l1)&#123; r++ &#125; stack.push([p, n]) &#125; &#125; &#125; return r &#125; return new Array(n).fill(0).map((f, n)=&gt;&#123; return getNum(n) &#125;)&#125;; 这个题中有个难点就是怎么才算是子树呢，它要是数字大就是数字小的子树，那就好了，但是不是。后来想想用“求最短路径”的常用套路，bfs。看它距离 源点0的距离，距离越大越远。 123456789101112131415161718192021222324252627282930313233343536373839let memorized = new Array(n).fill(0); memorized[0] = 1; const getLen = (start)=&gt;&#123; // if(start==0) return 0; if(memorized[start]) return memorized[start] let level = 1; let v = new Array(n).fill(false); let st = []; st.push(start); while(st.length)&#123; level++; let len = st.length; while(len--)&#123; let n = st.shift(); if(v[n]) continue v[n] = true // 初始不是0 if(level!=2)&#123; if(n==0) &#123; memorized[start] = level; return level &#125; &#125; let pa = path[n]; for(let i=0; i&lt;pa.length; i++)&#123; let pp = pa[i]; let [e] = pp; if(v[e]) continue st.push(e) &#125; &#125; &#125; &#125; 但是，最终结果却是超时 原始的dijkstra 算法 出于学习的目的又从百度上看了原始的dijkstra 算法，最后js的GC（last few GCs）报错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// Dijkstra，求出每个点距离0点的最短距离，确定是否是子树var countSubTrees = function(n, edges, labels) &#123; // 图 let path = new Array(n); let arcs = new Array(n); // 矩阵，相邻点1，不相临 无穷大 let n1 = n; while(n1--)&#123; path[n1] = []; arcs[n1] = new Array(n).fill(Infinity) &#125; edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push([e, labels[e]]); path[e].push([s, labels[s]]) arcs[s][e] = 1; arcs[e][s] = 1; &#125;); // Dijkstra，有出入，仿https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989?fr=aladdin教程写的 let s = new Array(n).fill(0); // 最短距离 let v = new Array(n).fill(false); // 访问过的点在S中，其余 T 中 let d = new Array(n).fill(Infinity); // 初始距离 无穷大,保存0-&gt;n的距离 d[0] = 0; path[0].forEach(p=&gt;d[p[0]]=1); // 与0相临的距离1 v[0] = true; let vi = 0; // 每个点到 0 的最短距离，并加入到s中 for(let i=1; i&lt;n; i++)&#123; let min = Infinity; for(let w=0; w&lt;n; w++)&#123; // 与0相邻，距离最短点 if(!v[w])&#123; if(d[w]&lt;min)&#123; // 每次产生一个最近点 vi = w; min = d[w]; &#125; &#125; &#125; v[vi] = true; //每次一个点S // 更新最短距离 for(let w=0; w&lt;n; w++)&#123; let x = arcs[vi][w]; // 满足条件就更新，可能多点, 如果出现 d(0-&gt;1) + d(1-&gt;w) &lt;d(0-&gt;w)，更新d[w]距离 if(!v[w] &amp;&amp; (min+ x&lt;d[w]))&#123; d[w] = min + x; &#125; &#125; &#125; // console.log(d); const isSub = (p, num)=&gt;&#123; // p必须在下面 let rp = d[p]; let rn = d[num]; if(rp&gt;rn) return true return false &#125; const getNum = (num)=&gt;&#123; let r = 1; let v = new Array(n).fill(false); let l1 = labels[num]; // node label let s = [num, l1]; let stack = []; stack.push(s) while(stack.length)&#123; let [s, l] = stack.shift(); if(v[s]) continue; v[s] = true let pp = path[s]; for(let i=0; i&lt;pp.length; i++)&#123; let [p, n] = pp[i]; if(v[p]) continue; // p是num的子节点 if(isSub(p, num)) &#123; if(n == l1)&#123; r++ &#125; stack.push([p, n]) &#125; &#125; &#125; return r &#125; return new Array(n).fill(0).map((f, n)=&gt;&#123; return getNum(n) &#125;)&#125; 官网给出的答案是 dfs，但是当节点为10万个时，栈的深度将近 1万，最后栈溢出报错，但是java和 c++是没有问题的。 123456789101112131415161718192021222324252627282930313233343536373839var countSubTrees = function(n, edges, labels) &#123; let path = new Array(n); let n1 = n; while(n1--)&#123; path[n1] = []; &#125; edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push([e, labels[e]]); path[e].push([s, labels[s]]) &#125;); let v = new Array(n).fill(false); let count = new Array(n).fill(0); // 100000十万 个点 RangeError: Maximum call stack size exceeded，但是java c++ python都不会 // 树的深度差不多超过了 10000 const dfs=(node, path, v, count, labels)=&gt;&#123; v[node] = true; // count[node] ++; let curCount = new Array(26).fill(0); curCount[labels[node].charCodeAt(0)-&apos;a&apos;.charCodeAt(0)]++ let cp = path[node]; for(let i=0; i&lt;cp.length; i++)&#123; let [next, l] = cp[i]; if(!v[next])&#123; let childCount = dfs(next, path, v, count, labels); let t = 26; while(t--)&#123; curCount[t] += childCount[t] &#125; &#125; &#125; count[node] = curCount[labels[node].charCodeAt(0)-&apos;a&apos;.charCodeAt(0)] return curCount &#125; dfs(0, path, v, count, labels) return count&#125; 最后呢，只能是 bfs，然后从底想下累加节点数目。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var countSubTrees = function(n, edges, labels) &#123; let path = new Array(n); let siz = new Array(n); let n1 = n; let n2 = n; while(n2--)&#123; siz[n2] = new Array(26).fill(0) &#125; while(n1--)&#123; path[n1] = []; &#125; // 生成图 edges.forEach(es=&gt;&#123; let [s, e] = es; // node label path[s].push(e); path[e].push(s) &#125;); let fa = new Array(n).fill(0); let q = []; q.push(0); // bfs + 每个点的父节点 fa for(let i=0; i&lt;q.length; i++)&#123; let v = q[i]; for(let j=0; j&lt;path[v].length; j++)&#123; let y = path[v][j] if(y!=fa[v])&#123; fa[y] = v; q.push(y) &#125; &#125; &#125; // 从底向上，统计每个点对应字母个数 for(let i = n - 1; i &gt;= 0; i--) &#123; let v = q[i]; siz[v][labels[v].charCodeAt(0) - &apos;a&apos;.charCodeAt(0)]++; if(!v) break; for(let j = 0; j &lt; 26; j++) &#123; siz[fa[v]][j] += siz[v][j]; &#125; &#125; let res = []; for(let i = 0; i &lt; n; i++) res.push(siz[i][labels[i].charCodeAt(0) - &apos;a&apos;.charCodeAt(0)]); return res;&#125; 最大得分你有两个 有序 且数组内元素互不相同的数组 nums1 和 nums2 。 一条 合法路径 定义如下： 选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。从左到右遍历当前数组。如果你遇到了 nums1 和 nums2 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。得分定义为合法路径中不同数字的和。 请你返回所有可能合法路径中的最大得分。 由于答案可能很大，请你将它对 10^9 + 7 取余后返回。 示例 1： 输入：nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]输出：30解释：合法路径包括：[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10] （从 nums2 开始遍历）最大得分为上图中的绿色路径 [2,4,6,8,10] 。示例 2： 输入：nums1 = [1,3,5,7,9], nums2 = [3,5,100]输出：109解释：最大得分由路径 [1,3,5,100] 得到。示例 3： 输入：nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]输出：40解释：nums1 和 nums2 之间无相同数字。最大得分由路径 [6,7,8,9,10] 得到。示例 4： 输入：nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]输出：61 提示： 1 &lt;= nums1.length &lt;= 10^51 &lt;= nums2.length &lt;= 10^51 &lt;= nums1[i], nums2[i] &lt;= 10^7nums1 和 nums2 都是严格递增的数组。 如果题中求的是最短距离，那我们可以用图的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var maxSum = function(nums1, nums2) &#123; let n12 = [...new Set([...nums1.concat(nums2)])]; console.log(&apos;n12: &apos;, n12) let n12l = n12.length; let s1 = nums1[0], s2 = nums2[0], r1 = nums1[nums1.length - 1], r2 = nums2[nums2.length - 1], s1Index = n12.indexOf(s1), s2Index = n12.indexOf(s2), r1Index = n12.indexOf(r1), r2Index = n12.indexOf(r2); let e1 = [], e2 = []; nums1.forEach((n1, i) = &gt;&#123; if (nums1[i + 1] !== undefined) e1.push([n1, nums1[i + 1]]); &#125;) nums2.forEach((n1, i) = &gt;&#123; if (nums2[i + 1] !== undefined) e1.push([n1, nums2[i + 1]]) &#125;) let e12 = e1.concat(e2); let len = n12.length; let nl = n12.length; let paths = []; while (nl--) &#123; paths[nl] = [] &#125; let edges = []; let succProb = []; e12.forEach(([s, e]) = &gt;&#123; let sI = n12.indexOf(s), eI = n12.indexOf(e), w = s + e; // s-e 的权重 w paths[sI].push([eI, w]); paths[eI].push([sI, w]); edges.push([sI, eI]) succProb.push(w) &#125;) let mod = 10 * *9 + 7; // Dijkstra每次选距离最小的点，是一种贪心决策。从源点出发时，也必须挑选最短点。eg：d(0-c)&gt;d(0-a)+d(a-c),所以初始c点时不能进入S集合的。 const getCount = (s, e) = &gt;&#123; let v = new Array(n12l).fill(false); let stack = [[s, 0]]; while (stack.length) &#123; console.log(&apos;stack: &apos;, JSON.stringify(stack)) let[n, weight] = stack.shift(); if (v[n]) continue v[n] = true; if (n === e) return weight; let ps = paths[n]; for (let i = 0; i &lt; ps.length; i++) &#123; let[nn, nw] = ps[i]; if (v[nn]) continue; let f = 0; if (n !== s) &#123; // 这个权限是2点的和，会重复累加，所以要减去 f = n12[n] &#125; stack.push([nn, (weight + nw - f) % mod]); // 这个应该是从小到大，虽然从大到小测试用例也一样，纯属巧合 stack.sort((a, b) = &gt;a[1] - b[1]) &#125; &#125; &#125; let res1 = 0, res2 = 0, res3 = 0, res4 = 0; res1 = getCount(s1Index, r1Index); res2 = getCount(s1Index, r2Index); res3 = getCount(s2Index, r1Index); res4 = getCount(s2Index, r2Index); return Math.max(res1, res2, res3, res4)&#125;;let nums1 = [1, 4, 5, 8, 9, 11, 19],nums2 = [2, 3, 4, 11, 12];Aconsole.log(maxSum(nums1, nums2))// 最小距离// console.log(res1, res2, res3, res4)// 35 28 39 32 本题解法之一 双指针 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */// 双指针, 分成好几个区段，每段求最大值var maxSum = function(nums1, nums2) &#123; let l1 = nums1.length, l2 = nums2.length; let i =0, j=0; let s1=0,s2=0; let res = 0; // 某条分支结束遍历 while(i&lt;l1 &amp;&amp; j&lt;l2)&#123; if(nums1[i] === nums2[j])&#123; res += Math.max(s1, s2)+nums1[i]; i++; j++; s1 = 0; s2 = 0; &#125; while(nums1[i] &lt; nums2[j])&#123; s1+=nums1[i]; i++ &#125; while(nums1[i] &gt; nums2[j])&#123; s2+=nums2[j]; j++ &#125; &#125; while(i&lt;l1)&#123; s1+=nums1[i]; i++ &#125; while(j&lt;l2)&#123; s2+=nums2[j]; j++ &#125; res += Math.max(s1, s2) return res % (10**9+7)&#125;; 解法二- 动态规划 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var maxSum = function(nums1, nums2) &#123; let ord = new Set(); let n = nums1.length,m = nums2.length; let t1=3, t2=3; let pos = [], dp = []; // 储存位置，eg: 4=&gt;0, pos[2][4] = 0; while(t1--)&#123; pos[t1] = [] &#125; while(t2--)&#123; dp[t2] = new Array(10**5).fill(0) &#125; for(let i=0;i&lt;n;i++) ord.add(nums1[i]),pos[1][nums1[i]] = i; for(let i=0;i&lt;m;i++) ord.add(nums2[i]),pos[2][nums2[i]] = i; let newArr = [ ...ord ].sort((a, b)=&gt; a-b); for(let i=0;i&lt; newArr.length; i++)&#123; let p = newArr[i]; if(pos[2][p] != undefined &amp;&amp; pos[1][p] != undefined)&#123; dp[2][pos[2][p] + 1] = dp[1][pos[1][p] + 1] = Math.max(dp[1][pos[1][p]],dp[2][pos[2][p]]) + p; &#125;else if(pos[1][p] != undefined)&#123; dp[1][pos[1][p] + 1] = dp[1][pos[1][p]] + p; &#125;else if(pos[2][p] != undefined)&#123; dp[2][pos[2][p] + 1] = dp[2][pos[2][p]] + p; &#125; &#125; return Math.max(dp[1][n],dp[2][m]) % 1000000007;&#125;; 吃掉 N 个橘子的最少天数厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子： 吃掉一个橘子。如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。每天你只能从以上 3 种方案中选择一种方案。 请你返回吃掉所有 n 个橘子的最少天数。 示例 1： 输入：n = 10输出：4解释：你总共有 10 个橘子。第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。第 2 天：吃 6 个橘子，剩余橘子数 9 - 2(9/3) = 9 - 6 = 3。（9 可以被 3 整除）第 3 天：吃 2 个橘子，剩余橘子数 3 - 2(3/3) = 3 - 2 = 1。第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。你需要至少 4 天吃掉 10 个橘子。示例 2： 输入：n = 6输出：3解释：你总共有 6 个橘子。第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。你至少需要 3 天吃掉 6 个橘子。示例 3： 输入：n = 1输出：1示例 4： 输入：n = 56输出：6 提示： 1 &lt;= n &lt;= 2*10^9 如果把这道题看成图的形式，节点是剩余橘子数，边是花费的天数 1234567891011121314151617181920var minDays = function(n) &#123;// 剩余n 个橘子，花费0天 let q = [[0,n]]; let v = []; let ans = 0; while(true)&#123; let [days, rest] = q.shift(); if(v[rest]) continue v[rest] = true if(rest == 1) &#123; ans = days + 1; break; &#125; // rest%2 为剩余橘子数是2的倍数花费的天数 q.push([days+rest%2+1, Math.floor(rest/2)]); q.push([days+rest%3+1, Math.floor(rest/3)]); q.sort((a, b)=&gt;a[0]-b[0]) &#125; return ans&#125; 动态规划，超时 12345678910111213141516171819var minDays = function(n) &#123; // 吃 n 个橘子 最少天数是 d[n] let dp = new Array(n+1).fill(0); dp[1] = 1; dp[2] = 2; for(let i=3; i&lt;=n; i++)&#123; let m1 = Infinity, m2 = Infinity, m3 = Infinity; // 必须加 () if(!(i%2))&#123; m1 = dp[i/2]+1 &#125; if(!(i%3))&#123; m2 = dp[i/3]+1 &#125; m3 = dp[i-1]+1 dp[i] = Math.min(m1, m2, m3) &#125; return dp[n]&#125;; 动态规划 + 备忘录 12345678910111213var minDays = function(n) &#123; let d = []; const dfs = (n, d)=&gt;&#123; if(n===1) return 1; if(n===2) return 2; if(d[n]) return d[n]; let ans = Infinity; ans = Math.min(ans, n % 2 + dfs(Math.floor(n/2),d)+1) ans = Math.min(ans, n % 3 + dfs(Math.floor(n/3),d)+1) return d[n] = ans &#125; return dfs(n, d)&#125; 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-with-maximum-probability著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","comments":true,"tags":[]},{"title":"git rebase","date":"2020-06-27T23:02:59.000Z","path":"2020/06/28/git-rebase/","text":"amend 操作 对最近一次的 commit 信息做修改1git commit --amend git rebase 合并提交信息 对以前的commit 信息做修改，就涉及到了变基操作 1234// 这里的”-i“是指交互模式。就是说你可以干预rebase这个事务的过程，包括设置commit message，暂停commit等等。// xxx 是要修改提交信息的父级，也就是要修改提交信息下面的 hash值。git rebase -i xxx 更改策略, 修改 hash 前面的关键字 123p pick = use commit // 使用提交信息r reword = use commit, but edit commit message // 使用信息，但是编辑信息..... 保存退出后，自动进如下一个交互，修改提交记录1// 修改提交信息 查看修改后的状态1git log --graph 多个commit 合并为一个 commit 12// xxx 仍然是父级 hashgit rebase -i xxx 将提交信息合并到上面提交 1s squash = use commit, but meld into pre commit // 合并到上面提交 添加提交信息 查看修改后状态 合并不是连续的提交信息，仍然是使用那些策略1234pick xxxs xxx1pick xxx2// 删除 xxx git rebase 将自己的提交记录的多个分支合并成一条直线 1.master分支当前情况 2.切换到test分支，产生2个提交 3.git rebase master(以master为基础，将feature分支上的修改增加到master分支上，并生成新的版本),以前有rebase操作可能导致效果不同。 3.1 修复冲突 git add . 3.2 git rebase –continue 4.切换到 master 4.1 git merge test 5.删除 test 分支， test分支目前的记录 5.1删除本地 test 分支 1git branch -d test 5.2删除远程 test 分支 1git push origin --delete test git rebase 将旧的提交记录直接合成一条线 1.查看原分支情况 2.git rebase -i HEAD~n (合并最近n次提交) 3.根据提示，从某个commit-id检出新分支，或 git checkout commit-id -b 新分支","comments":true,"tags":[]},{"title":"https网站搭建","date":"2020-05-26T00:20:26.000Z","path":"2020/05/26/https网站搭建/","text":"[TOC] 自建CA + nginx配置查看openssl 版本，服务器基本都内置123openssl version -aOpenSSL 1.0.2k-fips 26 Jan 2017 ...// 我的mac 默认openssl配置文件默认在/private/etc/ssl/openssl.cnf CA机构，最顶层机构，无需认真1mkdir certa 生成CA机构私钥，长度为2048字节1openssl genrsa -out ca.private.key 2048 根据CA私钥产生根证书，合法日期356天，主题中国北京…12openssl req -new -x509 -key ca.private.key -out ca.crt -days 365 -subj /C=CN/ST=Beijing/L=Beijing/O=ca/OU=ca/CN=www.zhangzs.xyz/emailAddress=xxx@qq.com// 生成ca.crt 就是证书 生成服务端私钥1openssl genrsa -out server.private.key 2048 服务器用自己的私钥，CA签名，生成证书签名请求1openssl req -new -key server.private.key -out server.csr -days 365 -subj /C=CN/ST=Beijing/L=Beijing/O=ca/OU=ca/CN=www.zhangzs.xyz/emailAddress=xxx@qq.com CA基于server.csr生成签名证书1openssl x509 -req -days 365 -CA ca.crt -CAkey ca.private.key -CAcreateserial -in server.csr -out server.crt 配置nginx 的ssl部分12ssl_certificate /root/cert1/server.crt; ssl_certificate_key /root/cert1/server.private.key; 将服务端的CA证书拷贝下来1scp -r root@xx.xxx.xx.xx:/root/cert1/ca.crt /Users/bosszhang/Documents 在浏览器内部导入我们的CA证书，因为是我们自己签发的，所以不信任。安装nginx时配置nginx，编译1234./configure --prefix=/usr/nginx --with-http_ssl_module --with-openssl=/root/openssl-1.1.0h --with-http_ssl_module --user=nginx --group=nginxmake make install 修改nginx.conf 将服务器证书和私钥添加上去就可以了自建CA + 自建服务openssl.cnf 配置1234[alt_names] IP.1 = 127.0.0.1DNS.1 = localhostDNS.2 = test.qq.com 服务端代码12345678910111213const https = require(&apos;https&apos;);const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);const options = &#123; key: fs.readFileSync(path.resolve(__dirname, &apos;ssl/server.private.pem&apos;)), cert: fs.readFileSync(path.resolve(__dirname, &apos;ssl/server.crt&apos;))&#125;;https.createServer(options, (req, res) =&gt; &#123; res.end(&apos;hello world\\n&apos;);&#125;).listen(9000); letsencrypt 生成证书1证书 -&gt; nginx安装配置 -&gt; 外网访问https站点 阿里云 或 腾讯云直接生成 server.crt 和 server.private.key实名认证，下载证书12ssl证书免费版-&gt;下载// 这个直接在官网的ssl模块实名认证下载即可..... 解压12yum install -y unzip zipunzip 3720164_www.zhangzs.xyz_nginx.zip 浏览器访问 firefox 导入ca.crt 就可以访问。 chrome 不仅要导入ca.crt ，还要设置该证书为“完全信任”，并且要重启浏览器。 关于nginx 配置 https 我用早以前的nginx配置也不行，c++ 编译安装也不行，似乎浏览器一直接受不到服务器的公匙证书， 难道是阿里云要进行某些配置？后来用宝塔很方便就解决了。 This is my website https://www.zhangzs.xyz/. 当时忘截图留念了 域名和代码已被回收 项目开始 zzs-cli 脚手架初始化 实现功能 antd实现布局 api 接口实现markdown文档拉取，上传。markdown文档编写通过某插件实现 小程序调用https接口 实现接口 get获取文档，post提交字符串，post登陆 持久化 防止内存爆掉，读流的形式123let inputStream = fs.createReadStream(src);let outputStream = fs.createWriteStream(src + &quot;.jsion&quot;);","comments":true,"tags":[]},{"title":"reduxjs/redux","date":"2019-08-28T00:08:29.000Z","path":"2019/08/28/reduxjs-redux/","text":"createStore.js1export default function createStore(reducer, preloadedState, enhancer) &#123;...&#125; reducer 传入自定义reducer用来计算state，默认返回initState; preloadedState 初始状态 enhancer 加强，比如常用的applyMiddleWare123456789101112131415... if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; ... 这也就是说，第二个参数如果是function的话，会赋值给enhancer，平时应用的时候可以这样let store = createStore(reducer, applyMiddleware(thunk, sagaMiddleWare));也可以这样let store = applyMiddleware(promise, thunk, logger)(createStore)(reducers);编写中间件时都是固定写法123456789const middleware = function(&#123;getState, dispatch&#125;)&#123; return function(next)&#123; // 原生dispatch方法，next return function(action)&#123; // 重写的 dispatch console.log(`middleware 状态更改前：$&#123;JSON.stringify(getState())&#125;`) next(action) console.log(`middleware 状态更改后：$&#123;JSON.stringify(getState())&#125;`) &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859... function getState() &#123; ... return currentState &#125; function subscribe(listener) &#123; ... let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; ... isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) currentListeners = null &#125; &#125; function dispatch(action) &#123; ... try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125; ... store.dispatch({type: xxx, xx: xx}) 执行时既会执行 currentReducer(currentState, action) 计算新属性，又会遍历listeners将数组中订阅的函数都执行，大多数情况我们会使用boundAction就像下面 actions会单独集中式写一个文件，let boundActions = bindActionCreators(actions, store.dispatch)就可以这样使用boundActions.xxx如果引入了react-redux可以这样写this.props.xxxconnect(mapStateToProps, mapDispathToProps)(ComponentName) store.subscribe(fn) 监听某个函数，在不使用react-redux时可以这样123456componentDidMount()&#123; this.unsubscribe = store.subscribe(()=&gt;this.setState(&#123;number: store.getState().counter1.number&#125;))&#125;componentWillUnmount()&#123; this.unsubscribe()&#125; 返回unsubscribe 函数，执行取消订阅； store.getState()获取状态，这里也应用了闭包保存私有变量； More info: createStore.js bindActionCreators.js1234567891011121314151617181920function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;export default function bindActionCreators(actionCreators, dispatch) &#123; if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; ... const boundActionCreators = &#123;&#125; for (const key in actionCreators) &#123; const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; actionCreators 可以传对象形式的action12345678export default &#123; add(args)&#123; return &#123;type: types.ADD1, payload: args&#125; &#125;, minus()&#123; return &#123;type: types.MINUS1&#125; &#125;&#125; 也可以传函数let mapStateToProps = state =&gt; state.counter1;内部会进行判断typeof actionCreators === ‘function’ ，最终的目的还是store.dispatch({type: xxx, xx: xx}) More info: bindActionCreators.js applyMiddleware.js1234567891011121314return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; dispatch: (…args)=&gt;dispatch(…args) 保证dispatch 不是对象是函数的时候每次都是重写后的dispatch方法 dispatch = compose(…chain)(store.dispatch) 通过闭包的形式保存oldDispatch More info: applyMiddleware.js compose.js123return createStore =&gt; (...args) =&gt; &#123; .... return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))) 这里用了reduce,实现方法很多，以前还用了reduceRight,总之将穿进来的中间件从左到右执行即可； More info: compose.js combineReducers.js12345678910111213141516 ...return function combination(state = &#123;&#125;, action) &#123; ...const nextState = &#123;&#125;for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123;const key = finalReducerKeys[i]const reducer = finalReducers[key]const previousStateForKey = state[key]const nextStateForKey = reducer(previousStateForKey, action)...nextState[key] = nextStateForKeyhasChanged = hasChanged || nextStateForKey !== previousStateForKey&#125;hasChanged =hasChanged || finalReducerKeys.length !== Object.keys(state).lengthreturn hasChanged ? nextState : state 一般用来合并reducerexport default combineReducers({ r1, r2 })所有它返回的仍然是个reducer, function combination(state = {}, action) {…} 合并reducer的时候会用到一个新对象nextState = {}，并且后期会对比产生的新状态是否改变hasChanged = hasChanged || nextStateForKey !== previousStateForKey类似这样的对比还有react-redux中的connectfunction strictEqual(a, b) { return a === b }react 里面的PureComponent More info: combineReducers.js","comments":true,"tags":[]},{"title":"redirect","date":"2019-03-28T07:30:41.000Z","path":"2019/03/28/养成算法思维？/","text":"redirect to xxx","comments":true,"tags":[]},{"title":"养成算法思维？","date":"2019-03-25T02:37:37.000Z","path":"2019/03/25/redirect/","text":"","comments":true,"tags":[]},{"title":"js-state-manager","date":"2019-03-25T02:09:09.000Z","path":"2019/03/25/js-state-manager/","text":"js状态管理图","comments":true,"tags":[]},{"title":"diff","date":"2019-03-23T09:41:13.000Z","path":"2019/03/23/diff/","text":"diff算法的实现 通过虚拟dom类创建创建虚拟dom，最终通过render方法将虚拟dom渲染到页面。 12345678class Element &#123; constructor(type, props, children)&#123; this.type = type; this.props = props; this.children = children; &#125;&#125; 先序深度优先遍历生成补丁包patches(key值是遍历节点的顺序)。 1234567let patches = &#123; 0: &#123;type: &apos;ATTRS&apos;, attrs: &#123; class: &apos;xxx&apos;&#125;&#125;, 1: &#123;type: &apos;TEXT&apos;, text: &apos;xxx&apos;&#125;, 2: &#123;type: &apos;REPLACE&apos;, node: Element&#125;, 3: &#123;type: &apos;REMOVE&apos;, index: xxx&#125;&#125; patch函数更新旧dom","comments":true,"tags":[]},{"title":"react-router实现","date":"2019-03-22T18:12:46.000Z","path":"2019/03/23/react-router实现/","text":"react-router相关实现利用let {Provider, Consumer} = React.createContext();实现 HashRouter Link组件 Redirect组件 Route组件 Switch组件","comments":true,"tags":[]},{"title":"","date":"2018-10-07T09:01:04.000Z","path":"2018/10/07/新世界/","text":"","comments":true,"tags":[]},{"title":"VUE相关","date":"2018-10-07T08:18:52.000Z","path":"2018/10/07/分分钟系列之-VUE实现/","text":"实现一个简单的VUE功能包括 数据劫持 数据代理 模板编译 视图同步 computed订阅发布实现 v-model双向绑定实现 数据的对象嵌套 未完成 存在订阅了相同的函数 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123;a.b&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;c&#125;&#125;&#123;&#123;d&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;sum&#125;&#125;&lt;/div&gt; &lt;input type=\"text\" v-model=\"a.b\"&gt; &lt;input type=\"text\" v-model=\"c\"&gt;&lt;/div&gt;&lt;script&gt;function Dep() &#123; // 实现订阅发布的数组 this.subs = [];&#125;Dep.prototype = &#123; addSub(sub) &#123; this.subs.push(sub); &#125;, notify() &#123; this.subs.forEach(sub =&gt; sub.update()); &#125;&#125;let dep = new Dep();let mvvm = new Mvvm(&#123; el: '#app', data: &#123; a: &#123; b: 1 &#125;, c: 2, d: 3 &#125;, computed: &#123; sum() &#123; // 调用一次，订阅一次，导致有2个sum return this.c + this.d; &#125;, noop() &#123; &#125; &#125;, &#125;); function Watcher(vm, exp, fn) &#123; ..... &#125; Watcher.prototype.update = function() &#123; this.fn() &#125; function Mvvm(options = &#123;&#125;) &#123; this.$options = options; let data = this._data = options.data // 数据劫持 observe(data) //数据代理 ...... initComputed.bind(this)() // 模板编译 Compile(options.el, this); &#125; function initComputed() &#123; ..... &#125; function Observe(data) &#123; &#125;&lt;/script&gt; 注意点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function Watcher &#123;.....// 可以通过reduce来调用defineProperty中的get方法，进而订阅Watcher实例this.exp.split('.').reduce((val, key)=&gt;&#123; return val[key]&#125;, this.vm) .....&#125;Watcher.prototype.update = function() &#123; // 这里仅需要执行fn()即可，不需要别的 this.fn()&#125;function Compile(el, vm) &#123; ...... // 满足非贪婪匹配 reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; ..... if(node.nodeType === 3 &amp;&amp; reg.test(txt))&#123; function replaceTxt() &#123; // replace函数的参数(match匹配的字符串，$1,$2...第n个括号匹配的字符串， offset，string) node.textContent = txt.replace(reg, (matched, placeholder)=&gt;&#123; return placeholder.split('.').reduce((val, key)=&gt;&#123; return val[key]; &#125;, vm) &#125;) &#125;; replaceTxt() new Watcher(vm, RegExp.$1, replaceTxt); &#125; // 双向绑定 if(node.nodeType === 1) &#123; let nodeAttr = node.attributes; Array.from(nodeAttr).forEach(attr =&gt; &#123; let name = attr.name, exp = attr.value, arr = exp.split('.'); if(name.includes('v-model'))&#123; replaceModel() node.addEventListener('input', e=&gt;&#123; let newVal = e.target.value; // 更新实例中的值，执行set中的发布；并满足类似a.b.c这样的表达式 eval('vm.'+exp+'='+newVal); node.value = newVal; &#125;) &#125; function replaceModel() &#123; node.value = arr.reduce((val, key)=&gt;&#123; return val[key] &#125;, vm) &#125; // 更新实例时，对应的node也要更新 new Watcher(vm, exp, replaceModel); &#125;) &#125;&#125;","comments":true,"tags":[]},{"title":"promise实现","date":"2018-09-28T22:25:15.000Z","path":"2018/09/29/promise实现/","text":"实现一个简单的promise 首先实现这种形式 12345678910111213new Promise((resolve, reject)=&gt;&#123; console.log(111) resolve(222)&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const pedding = 'pedding';const fulfilled = 'fulfilled';const rejected = 'rejected';const isFunction = (val) =&gt; typeof val === 'function'class MyPromise &#123; constructor(handler) &#123; if(!isFunction(handler)) &#123; throw new Error('promise必须传入函数！') &#125; // 值传递 this._value; // 内部状态 this._status = pedding; try &#123; // 保证异步调用时this指向 handler(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (error) &#123; &#125; &#125; _resolve(val) &#123; this._value = val; // resolve之后更改状态 this._status = fulfilled; &#125; _reject(val) &#123; &#125; then(resolve, reject) &#123; const &#123; _value, _status &#125; = this switch(_status) &#123; case pedding: break; case fulfilled: resolve(_value); break; case rejected: reject(_value) break; &#125; &#125;&#125; 对异步的处理 上面那种形式如果碰见异步就会出现问题，如何实现异步的情况？类似订阅发布形式。 123456789101112131415new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(111) resolve(222) &#125;, 100)&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class MyPromise &#123; constructor(handler) &#123; if(!isFunction(handler)) &#123; throw new Error('promise必须传入函数！') &#125; // 值传递 this._value; // 内部状态 this._status = pedding; this._fulfilledList = []; this._rejectedList = []; try &#123; // 保证异步调用时this指向 handler(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (error) &#123; &#125; &#125; _resolve(val) &#123; // 避免resolve多次执行 if(this._status !== pedding) return // resolve之后更改状态，如果用解构赋值，这里就不执行？ this._status = fulfilled; this._value = val; this._fulfilledList.forEach((item)=&gt;&#123; item(val) &#125;) &#125; _reject(val) &#123; if(this._status !== pedding) return this._status = rejected; this._value = val; this._rejectedList.forEach((item)=&gt;&#123; item(val) &#125;) &#125; then(onFulfilled, onRejected) &#123; const &#123; _value, _status, _fulfilledList, _rejectedList &#125; = this switch(_status) &#123; case pedding: _fulfilledList.push(onFulfilled); _rejectedList.push(onRejected); break; case fulfilled: onFulfilled(_value); break; case rejected: onRejected(_value) break; &#125; &#125;&#125; then之间的值传递 链式调用中，上一个then的返回值，下一个then如何接收？这里要用到闭包。 1234567891011121314151617181920new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(111) resolve(222) &#125;, 100)&#125;).then((data)=&gt;&#123; console.log(data) return 333&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：111222333 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.......then(onFulfilled, onRejected) &#123; const &#123; _value, _status, _fulfilledList, _rejectedList &#125; = this return new MyPromise((nextFulfiled, nextRejected)=&gt;&#123; const _onFulfilled = (val) =&gt; &#123; let res = onFulfilled(val); nextFulfiled(res) &#125; const _onRejected = (val) =&gt; &#123; let res = onRejected(val); nextRejected(res) &#125; switch(_status) &#123; case pedding: _fulfilledList.push(_onFulfilled); _rejectedList.push(_onRejected); break; case fulfilled: onFulfilled(_value); break; case rejected: onRejected(_value) break; &#125; &#125;) &#125;new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(1111) resolve(2222) &#125;, 500)&#125;).then((data)=&gt;&#123; console.log(data) return 333&#125;).then((data)=&gt;&#123; console.log(data)&#125;)结果：11112222333 扩展： 12new 实现bind实现","comments":true,"tags":[]},{"title":"数据可视化","date":"2018-08-13T23:58:25.000Z","path":"2018/08/14/数据可视化/","text":"如何提高可视化技术 牛顿经典力学 函数、微积分 工具 信息图表 D3图形知识 ECharts和G2 地理空间 Leaflet OpenLayer Mapbox 三维空间 three.js最全的webgl库 spritejs好用的canvas动画库","comments":true,"tags":[]},{"title":"数据结构","date":"2018-08-12T22:59:54.000Z","path":"2018/08/13/数据结构/","text":"","comments":true,"tags":[]},{"title":"算法","date":"2018-08-12T22:59:40.000Z","path":"2018/08/13/排序算法/","text":"排序算法 稳定性：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。 冒泡排序从小到大排序，比较相邻元素，如果前一个比后一个大，则调换位置。如果有n个数据，那么就要进行n-1趟排序，每趟排序比较次数根据趟数决定。 12345678910111213141516171819202122232425262728293031323334353637383940/*数据结构 ---------- 数组最差时间复杂度 ---- O(n^2)最优时间复杂度 ----O(n)平均时间复杂度 ---- O(n^2)所需辅助空间 ------ O(1)稳定性 ------------ 稳定*/var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort1() &#123; let len = arr.length; for (let i = 0; i &lt; len-1; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // es5版 let temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; // es6版 //[arr[j], arr[j+1]] = [arr[j+1], arr[j]]; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort1(arr))for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - i-1; j++) 和上面那个执行的次数是一样的。因为i=len-1时，j=0;一个循环也不走，所以次数一样。第二个循环如果不减一的话，i==0 =&gt; Jmax ==len-1 =&gt;arr[j+1] == arr[len]出现undefined。以后的话也类似。导致多循环len次for (var i = arr.length - 1; i &gt; 0; i--) &#123; for (var j = 0; j &lt; i; j++) &#123;这个循环也行 n个数据最后一趟，也就是 n-1 趟的时候，不用循环，因为前面都已经比较过了。它的时间复杂度n^2-n，所有它的时间复杂度还是O(n^2)，只要保证第一趟把最大的放在顶端就行。 如果数组内层循环只需一次就排好序，然后就调出循环，那么他的时间复杂度 O(n)。 平均时间复杂度是一种数学期望值，需要对输入的分布情况进行假设，一般都是通过运行一定数量的实验数据后估算出来的。设每种情况的出现的概率为pi,则为sum(pi*f(n)) 冒泡排序改进 1鸡尾酒排序，算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。保证每一趟把最大的放在顶端，最小的放在底端就行。 1234567891011121314151617181920212223242526var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort2() &#123; let len = arr.length, left = 0, right = len-1; for (; left &lt; right; ) &#123; for (let i = left; i &lt; right; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; [arr[i], arr[i+1]] = [arr[i+1], arr[i]]; &#125; &#125; right--; for (let j = right; j &gt; left; j--) &#123; if (arr[j] &lt; arr[j-1]) &#123; [arr[j], arr[j-1]] = [arr[j-1], arr[j]]; &#125; &#125; left++; &#125; return arr;&#125;console.log(bubbleSort2(arr)) 冒泡排序改进 2每进行一趟比较记录最后交换的位置flag。由于flag之后的位置已经交换完成，所以下一趟只需扫描到flag位置即可。 123456789101112131415161718192021var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort3() &#123; let len = arr.length; for (let i = len-1; i &gt; 0; ) &#123; // 必须初始化，否则可能死循环 let flag = 0 for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; flag = j; &#125; &#125; i = flag; &#125; return arr;&#125;console.log(BubbleSort3(arr)) 冒泡排序改进 3如果每一趟能够决定最小的flag和最大的flag。 1234567891011121314151617181920212223242526272829303132var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort4() &#123; let len = arr.length, left = 0, right = len-1, right_pointer = 0, left_pointer = 0; for (; left &lt; right ; ) &#123; for (let i = left; i &lt; right; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; [arr[i], arr[i+1]] = [arr[i+1], arr[i]]; right_pointer = i; &#125; &#125; right = right_pointer; for (let j = right; j &gt; left; j--) &#123; if (arr[j] &lt; arr[j-1]) &#123; [arr[j], arr[j-1]] = [arr[j-1], arr[j]]; left_pointer = j; &#125; &#125; left = left_pointer; // 临界值判断 if (left === right-1 &amp;&amp; arr[left] &lt; arr[right]) break; &#125; return arr;&#125;console.log(BubbleSort4(arr)) 冒泡排序改进 4使用位运算^（异或）去交换值。 原理； 12345678相同的两个数异或得0，不同的两个数异或得1; 将两个数异或的结果与其中一个数再异或，可以得到另一个数； temp=a^b; //设temp为临时变量，存储异或值 b=temp^b; //相当于b=a =&gt; a ^ b ^ b = a a=temp^a; //相当于a=b =&gt; a ^ b ^ a = b但是，从汇编的指令和实际的测试来看，用异或执行的指令数目和时间长短并不是最优解。 1234567891011121314151617181920212223var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function BubbleSort5() &#123; let len = arr.length; for (let i = len-1; i &gt; 0; ) &#123; // 必须初始化，否则可能死循环 let flag = 0 for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; var temp = arr[j] ^ arr[j+1]; arr[j] = temp ^ arr[j+1]; arr[j+1] = temp ^ arr[j]; flag = j; &#125; &#125; i = flag; &#125; return arr;&#125;console.log(BubbleSort5(arr)) 冒泡排序改进 5使用列表去存储值 原理： 12 12 可以用下面的方法简单测一下计算时间：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379// 新建4个相同的数组，分别测试console.time('BubbleSort');console.timeEnd('BubbleSort');``` 大致结果如下，每次运行都不一样，结果还是蛮`尴尬`的，BubbleSort1第一名的几率比较大，也排除了新建空间问题，是不是数据量太少的原因。![algorithm](/assets/blogImg/algorithm/s1.png \"sort\")### 选择排序 选择排序：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后类似这样往下排序。``` bash// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- O(n^2)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定var arr = [6, 5, 3, 3, 3, 3, 1, 8, 7, 2, 4]function SelectionSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; let min = i; for (var j = i+1; j &lt; arr.length; j++) &#123; if(arr[min]&gt;arr[j]) &#123; min = j; &#125; &#125; [arr[min], arr[i]] = [arr[i], arr[min]] &#125; return arr;&#125;console.log(SelectionSort(arr))``` ### 选择排序 2每趟排序决定1个最大值和一个最小值``` bashfunction SelectionSort(arr) &#123; var len = arr.length for (let i = 0; i &lt; len; i++,len--) &#123; let min = i, max = len-1; for (var j = i+1; j &lt; len; j++) &#123; if(arr[min]&gt;arr[j]) &#123; min = j; &#125; if(arr[max]&lt;arr[j]) &#123; max = j &#125; &#125; // swap(min, i) // swap(max, len-1) // 如果前面没有if判断，连续2个ES6解构交换会出错，出现好多最大数。 if(min !== i) [arr[min], arr[i]] = [arr[i], arr[min]] if(max !== len-1) [arr[max], arr[len-1]] = [arr[len-1], arr[max]] // [arr[min], arr[i]] = [arr[i], arr[min]] // [arr[max], arr[len-1]] = [arr[len-1], arr[max]] &#125; return arr;&#125;function swap(m, n) &#123; // if(m!==n) &#123; var temp = arr[m]; arr[m] = arr[n]; arr[n] = temp; // &#125;&#125;``` ### 插入排序插入排序：默认把左边第一个元素已经排好序，取下一个元素，从后向前扫描反复把已排序元素逐步向后挪位，为最新元素提供插入空间。``` bash// 分类 ------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定function InsertionSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; const get = arr[i]; var j = i-1; // 控制j是最后一个小于get的索引 for (; j &gt;= 0 &amp;&amp; arr[j] &gt; get; j--) &#123; // if(arr[j] &gt; get) &#123; arr[j+1] = arr[j]; // &#125; &#125; arr[j+1] = get &#125; return arr;&#125;``` ### 插入排序 2二分插入排序： 因为左边的数列已经排好序，那么可以采用二分法来减少比较次数。#### 二分查找的时间复杂度。时间频度为T(n)，n为问题规模。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。 `尴尬```` bash// 最差时间复杂度// 假设数据规模是n，则T(n)为除以2再加上一次比较的过程为O(1) T(n) = T(n/2) + O(1)以此类推： T(n) = T(n/2^1) + O(1) = (T(n/2^2)+O(1)) + O(1) = (T(n/2^3)+O(1)+O(1)) + O(1) .....辅助函数f(n)=n/2^k , 比较次数是k;其中f(n)=n/2^k&lt;=1 =&gt; n&lt;=2^k =&gt;logn&lt;=k // 大O表示法中的对数表示T(n) = [logn]O(1) =&gt; T(n)/f(n)=O(1) =&gt; O(logn)因此二分查找的时间复杂度是logN。``` #### 二分插入排序``` bashfunction InsertionSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; const get = arr[i]; var right = i-1, left = 0; for (;left &lt;= right;) &#123; let mid = Math.ceil((left+right)/2) // 尽量往右边靠，所以相等情况left = mid+1 if (arr[mid] &gt; get) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; for (var j = i-1; j &gt;= left; j--) &#123; arr[j+1] = arr[j]; &#125; arr[j+1] = get &#125; return arr;&#125; ``` ### 快速排序算法描述：从序列中挑出一个元素，作为\"基准\"，把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边）。快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。``` bash// 分类 ------------ 内部比较排序// 数据结构 --------- 数组// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n) // 稳定性 ---------- 不稳定function quickSort(arr, left, right) &#123; if (left &gt;= right) &#123; return; &#125; var pivotIndex = partition(arr, left, right); quickSort(arr, left, pivotIndex-1); quickSort(arr, pivotIndex+1, right); return arr;&#125;// 将数组分区，分成以pivot为基准，左边是小于它的，右边是大于它的。function partition(arr, left, right) &#123; let pivot = arr[right], pointer = left; for(let i = left; i &lt; right; i++) &#123; if(arr[i] &lt; pivot) &#123; // 用es6特性会出现undefined和多出数字，所以说这个特性内部怎么实习的 // [arr[i], arr[pointer++]] = [arr[pointer++], arr[i]] swap(arr, pointer++, i) &#125; &#125; // [arr[pointer], arr[right]] = [arr[right], arr[pointer]] swap(arr, pointer, right) return pointer;&#125;function swap(arr, m, n) &#123; var temp = arr[m]; arr[m] = arr[n]; arr[n] = temp;&#125;``` ### 快速排序2关于阮的快排``` bashvar quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;;// v8中splice是时间复杂度为O(n)。// 每次递归都需要开了2个临时数组，空间复杂度和当前数组的时间复杂度有关。``` ### 希尔排序希尔排序: 又叫递减增量排序，是插入排序的一种更高效的改进版本。将全部数据分成几个区域来进行插入排序，然后取越来越小的步数分别进行插入排序，最后是普通的插入排序。``` bash// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)// 最优时间复杂度 ---- O(n)// 平均时间复杂度 ---- 根据步长序列的不同而不同。// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定function shellSort(arr) &#123; var h = 0, n = arr.length; // 比 h&lt;=n 少比较几次 while (h &lt;= n/3) &#123; // 生成初始增量 h = 3 * h + 1; &#125; // 第一趟增量最大 while (h&gt;=1) &#123; // 每次+1，比较还是距离增量的2个数 for(let i=h; i&lt;n; i++) &#123; let j = i-h, get = arr[i]; // get分别和i-h，i-2h...进行比较 for(;j&gt;=0 &amp;&amp; arr[j]&gt;get;)&#123; arr[j+h] = arr[j]; j=j-h; &#125; arr[j+h] = get; &#125; h = (h-1)/3 &#125; return arr;&#125;``` ### 归并排序归并排序：指的是将两个已经排序的序列合并成一个序列的排序操作。1945年由冯·诺伊曼由首次提出。``` bash// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(n)// 稳定性 ------------ 稳定// 递归实现的归并排序(自顶向下)function MergeSortRecursion (A, left, right) &#123; // 当待排序的序列长度为1时，递归开始回溯，进行merge操作 if (left == right) return; var mid = Math.floor((left + right) / 2); MergeSortRecursion(A, left, mid); MergeSortRecursion(A, mid + 1, right); Merge(A, left, mid, right); return A&#125;// 把2数组变成有序的一个数组function Merge(A, left, mid, right)&#123; var len = right - left + 1; var temp = new Array(len); // 辅助空间O(n) var index = 0; var i = left; // 前一数组的起始元素 var j = mid + 1; // 后一数组的起始元素 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; // 带等号保证归并排序的稳定性 &#125; while (i &lt;= mid) &#123; temp[index++] = A[i++]; &#125; while (j &lt;= right) &#123; temp[index++] = A[j++]; &#125; for (var k = 0; k &lt; len; k++) &#123; A[left++] = temp[k]; &#125;&#125;// 非递归(迭代)实现的归并排序(自底向上)function MergeSortIteration (A, len) &#123; var left, mid, right; // 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right] for (var i = 1; i &lt; len; i *= 2) // 子数组的大小i初始为1，每轮翻倍 // 左边数组初始是1，右边初始也是1，总长队为2，依次往后整个数组比较完毕后，初始是2.... &#123; left = 0; while (left + i &lt; len) // 后一个子数组存在(需要归并) &#123; mid = left + i - 1; right = mid + i &lt; len ? mid + i : len - 1;// 后一个子数组大小可能不够 Merge(A, left, mid, right); left = right + 1; // 前一个子数组索引向后移动 &#125; &#125; return A &#125; 堆排序堆排序是指利用堆这种数据结构所设计的一种选择排序算法，堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的）。将初始待排序关键字序列构建成大顶堆（小），将堆顶元素R[1]与最后一个元素R[n]交换，交换后，再次将无序区变为大顶堆（小），以此类推。 树满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上的二叉树。 完全二叉树：对于一颗具有n个结点的二叉树按层序编号，如果编号为i(1&lt;=i&amp;&amp;i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同的二叉树。 大多数情况下用数组表示数不是很有效率,除非是完全二叉树.但是普通的二叉树,特别是有很多空节点的.会有很多空洞,浪费存储空间.用数组表示树,删除节点是很费时费力的. 所以用数组表示树适合用于 完全二叉树查找,和插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定var arr = [9,9,8,7,8,8,8,6,5,4,3,2]function HeapSort (A, n) &#123; var heap_size = BuildHeap(A, n); // 建立一个最大堆 while (heap_size &gt; 1) &#123; // 堆（无序区）元素个数大于1，未完成排序 // 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素 // 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法 Swap(A, 0, --heap_size); Heapify(A, 0, heap_size); // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn) &#125; return A&#125;function BuildHeap(A, n) &#123; // 建堆，时间复杂度O(n) var heap_size = n; // Math.floor或Math.ceil并不影响 for (var i = Math.floor(heap_size / 2) - 1; i &gt;= 0; i--) // 从每一个非叶结点开始向下进行堆调整 Heapify(A, i, heap_size); return heap_size; &#125;function Heapify(A, i, size)&#123; // 从A[i]向下进行堆调整 var left_child = 2 * i + 1; // 左孩子索引 var right_child = 2 * i + 2; // 右孩子索引 var max = i; // 选出当前结点与其左右孩子三者之中的最大值 if (left_child &lt; size &amp;&amp; A[left_child] &gt; A[max]) max = left_child; if (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) max = right_child; if (max != i) &#123; Swap(A, i, max); // 把当前结点和它的最大(直接)子节点进行交换 Heapify(A, max, size); // 递归调用，继续从当前结点向下进行堆调整 &#125;&#125;function Swap(A, i, j)&#123; var temp = A[i]; A[i] = A[j]; A[j] = temp;&#125; 执行上下文堆栈优化：尾递归，减少调用链，不需要额外的栈进行数据保存和恢复。 练习有两个数组，元素个数可能相差很多，但也可能几乎相同，求它们交集的最优算法。 123456789101112131415161718191、2个for循环，时间复杂度为O(n2),空间复杂度O(1)；2、先将2个数组排好序，2个指针分别指向2个数组的，从到到尾扫描。时间复杂度为O(nlogn),空间复杂度O(1)。3、建立hash表，时间复杂度为O(1),空间复杂度O(min(N,M))。var arr1 = [2,31,4,3,2,1,6,7,33,34,32,31,39], arr2 = [3,4,8,6,7,9,10], obj = &#123;&#125;;// Map结构访问key不需要扫描所有的属性，访问的时间复杂度为O(1)，达到空间(内存)换时间(次数)的目的。for (let index = 0; index &lt; arr2.length; index++) &#123; const element = arr2[index]; obj[element]=1&#125; var arr1 = arr1.filter((ele)=&gt;&#123; return obj[ele]&#125;)console.log(arr1)","comments":true,"tags":[]},{"title":"工程化","date":"2018-07-28T23:07:33.000Z","path":"2018/07/29/工程化/","text":"所谓工程化就是方法论，将软件研发的各个链路规范化，系统化，流程化 单元测试 网页性能分析 代码托管 bug日志 模块加载器 脚手架CLI搭建 数据分析（可视化） 接口测试（压力测试）","comments":true,"tags":[]},{"title":"架构设计","date":"2018-07-28T23:04:57.000Z","path":"2018/07/29/架构设计/","text":"Underscore Jquery Lodash Underscore首先，underscore的基本语法如下 123456789var a = _.indexOf([1, 1, 2, 1, 2], 2);console.log('a: ',a)var b = _([1, 1, 2, 1, 2]).indexOf(2)console.log('b: ',b)a: 2b: 2 也就是说既支持实例化对象形式的调用，又支持工具方法的形式的调用。 假如这样设计 12345678910111213141516171819202122232425262728(function(root)&#123; // 这样做的目的_可以当做对象，方法，构造函数 var _ = function() &#123; // (this instanceof _)这个括号必须加 if(!(this instanceof _)) &#123; return new _(); &#125; &#125; _.indexOf = _.prototype.indexOf = function() &#123; console.log(1111) return '' &#125; ...... return root._ = _&#125;)(this)console.log(_.indexOf())console.log(_().indexOf())结果：11111111 那么将如何实现这种形式的语法？ _([1, 1, 2, 1, 2]).indexOf(2)，用ES6的默认值不能实现吗？ 123456789var _ = function(obj) &#123;if(!(this instanceof _)) &#123; return new _(obj)&#125;this.wrapped = obj&#125;？？？？？？？ 类似这种： 12345_.indexOf = _.prototype.indexOf = function(args=this.wraped) &#123; console.log(args) return &apos;&apos;&#125; 如果我把对象上的方法都写在一个对象上，然后扩展到原型上 12// 个人感觉这种思路也可以_.prototype = Object.assign(_.prototype, _) 把obj 用call 或 apply 的形式传到要调用的函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243core.js _.each = function(arr, cb) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; cb.call(arr, arr[i], i) &#125;;&#125; _.functions = function(obj) &#123; var result = []; for (var key in obj) &#123; // 忽略掉那些从原型链上继承到的属性。 if (obj.hasOwnProperty(key)) &#123; result.push(key) &#125; &#125;; return result;&#125;// 将对象上的方法添加到原型链上_.mixin = function(obj) &#123; _.each(_.functions(obj), function(value, index) &#123; var fun = obj[value] obj.prototype[value] = function() &#123; console.log('arguments: ',arguments) console.log('this.wrapped: ',this.wrapped) fun.apply(this,...) fun.call(this,...) &#125;; &#125;)&#125;_.mixin(_)root._ = _;当执行 _([1, 1, 2, 1, 2]).indexOf(2)结果：this.wrapped: (5) [1, 1, 2, 1, 2]arguments: Arguments [2, callee: ƒ, Symbol(Symbol.iterator): ƒ] 原型共享之Jquery12345// jQuery.fn和jQuery.prototype指向相同引用。jQuery.fn = jQuery.prototype = &#123;&#125;jQuery.fn.init.prototype = jQuery.fn 它们之间共享原型。那么无论是通过jQuery的实例对象，还是init的实例对象，只要在jQuery原型上的方法，它们都可以调 用。所有只需在jQuery的原型上扩展方法就可以，然后通过下面返回init实例。 12345678910111213(function (root, factory) &#123; root.$=factory()&#125;)(this,function()&#123; jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context ); &#125;, return jQuery;&#125; 就可以随意的访问jQuery原型的方法。 那为什么不直接返回jQuery的实例呢？如下： 12345678(function (root, factory) &#123; root.$=factory()&#125;)(this,function()&#123; return new jQuery()&#125; 因为会栈溢出死循环！ 这样的话，我们就能够 1$()通过实例调用方法，不需要通过 instanceof 来判断。 当然可以选用UMD规范同时兼容了浏览器、Node环境及AMD规范。 123456789101112131415161718192021// if the module has no dependencies, the above pattern can be simplified to(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], factory); &#125; else if (typeof module === 'object' &amp;&amp; module.exports) &#123; // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); &#125; else &#123; // Browser globals (root is window) root.returnExports = factory(); &#125;&#125;(typeof self !== 'undefined' ? self : this, function () &#123; // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;)); 剩下的就是扩展api 123456789101112131415161718192021222324252627282930313233343536(function (root, factory) &#123; root.$=factory()&#125;)(this,function()&#123; var jQuery = function() &#123; return new jQuery.fn.init() &#125; jQuery.fn = jQuery.prototype = &#123; init:function() &#123; &#125;, css: function() &#123; ..... &#125; ...... &#125; jQuery.fn.init.prototype = jQuery.fn // 扩展工具方法，任意对象、jQuery本身、实例对象 jQuery.extend = jQuery.fn.extend = function() &#123; ..... &#125; return jQuery;&#125;// 通常覆盖默认配置$.extend(xxx, xxxx); 函数式编程实现jq调用方法的形式123456789101112131415161718192021222324function batch(fn)&#123; return function(target, ...args)&#123; if(target.length &gt;= 0)&#123; return Array.from(target).map(item =&gt; fn.apply(this, [item, ...args])); &#125;else&#123; return fn.apply(this, [target, ...args]); &#125; &#125;&#125;function setColor(el, color)&#123; el.style.color = color;&#125;setColor = batch(setColor);let items1 = document.querySelectorAll('ul &gt; li:nth-child(2n + 1)');setColor(items1, 'red');// 类似这种对过程的抽象，最终实现下面这种形式的编码$('ul &gt; li:nth-child(2n + 1)').css(&#123;color: 'red'&#125;).text('abc'); // 没及时的写，结果返回去找资料写。","comments":true,"tags":[]},{"title":"mobx文档翻译","date":"2018-07-08T22:54:59.000Z","path":"2018/07/09/mobx文档翻译/","text":"","comments":true,"tags":[]},{"title":"网页分析","date":"2018-06-18T08:08:18.000Z","path":"2018/06/18/网页分析/","text":"CSR和SSR项目对比首先我们带有一个项目分别用SSR的方式和CSR的方式实现，这里选用vue项目。关于vue服务端渲染的知识可以参考官网和作者的demo。找了个项目，chrome开发工具中将网络调整为fast 3G的Performance图分别如下： 客户端渲染 服务端渲染 关于vue的SSR解释SSR 有两个入口文件，client.js 和 server.js， 都包含了应用代码，webpack 通过两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 当服务器接收到了来自客户端的请求之后，会创建一个渲染器 bundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件，并且执行它的代码， 然后发送一个生成好的 html 到浏览器，等到客户端加载了 client bundle 之后，会和服务端生成的DOM 进行 Hydration (判断这个 DOM 和自己即将生成的 DOM 是否相同，如果相同就将客户端的Vue实例挂载到这个 DOM 上， 否则会提示警告)。 有火焰图的那个窗口细心的小盆友会发现有3根线： 绿线代表首次绘制的时间。 蓝线代表 DOMContentLoaded 事件。 红线代表 load 事件 从分析图中我们可以看到：CSR的首次绘制时间大约是550ms, 而SSR的首次绘制时间大约是1070ms,这应该是单页面应用初始仅有一个父标签的原因。这个待完善。CSR肯定是存在阻塞行为的。至于这个TTFB(多长时间才能收到第一个响应的字节) 我们是在本地服务启动，相当于开发环境，也没什么意义。 RAIL模型 Response立即响应用户；在 100 毫秒以内确认用户输入。 Animation设置动画或滚动时，在 10 毫秒以内生成帧。 Idle最大程度增加主线程的空闲时间。 Load持续吸引用户；在 1000 毫秒以内呈现交互内容。 关键渲染路径 分析网站 识别网站的关键资源，画出它的关键渲染路径图。 算出关键渲染路径的三个指标。 关键资源个数 关键资源大小。 关键网络来回数目。 是否可优化？优化后的指标?","comments":true,"tags":[]},{"title":"编码测试","date":"2018-06-05T00:07:02.000Z","path":"2018/06/05/编码测试/","text":"乱码乱码乱码编码测试编码测试编码测试","comments":true,"tags":[]},{"title":"深复制和浅复制","date":"2018-04-15T01:00:31.000Z","path":"2018/04/15/深复制和浅复制/","text":"关于复制也是很常见的问题 关于我们经常写的=赋值，就不把它归为复制，它只是赋值 还有就是常见的数组的方法比如concat、slice都是浅复制 还有ES6里面的Object.assign或…(扩展运算符)实现方式也是浅复制 第二点中举个例子1234567891011// 说明它是浅复制var arr5 = [1, 2, 3, [100, 200, 300]]var arr6 = arr5.slice(0);arr5[3][0]=555console.log(&apos;arr5: &apos;,arr5)console.log(&apos;arr6: &apos;,arr6)结果：arr5: (4) [1, 2, 3, [555, 200, 300]]arr6: (4) [1, 2, 3, [555, 200, 300]] 知乎上有张关于浅复制shallow图还是不错的，就是基本数据变量占存储值，对象类型的存引用 关于第三点展开运算符babel解析的时候，可能是数组的形式也可能是对象的Object.assign1234567891011121314let obj = [1, 2, &#123;a: 1&#125;]let obj2 = [...obj]// babel解析后var obj = [1, 2, &#123; a: 1 &#125;];var obj2 = [].concat(obj);------------let obj3 = &#123;a:1,b:3,d:&#123;d:4&#125;&#125;let obj4 = &#123;c:1, ...obj3&#125;// babel解析后var obj3 = &#123; a: 1, b: 3 &#125;;var obj4 = _extends(&#123; c: 1 &#125;, obj3);var _extends = Object.assign || function (target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target; &#125;; 可以看出当展开对象的时候可以是Object.assign或是循环第二个参数和第二个后面的参数给第一个参数(对象)上扩展属性。上例中对于obj4中通过扩展运算符添加的属性d只是单纯的引用关系。下面手动实现一个浅复制123456789101112var obj = &#123; a: 1, arr:[2, 3]&#125;var shallowObj = shallowObj(obj)function shallowObj (obj) &#123; var res = &#123;&#125;; for (prop in obj) &#123; if(obj.hasOwnProperty(prop)) &#123; res[prop] = obj[prop] &#125; &#125; return res;&#125; 但是这个只能浅复制对象，其实数组类似只是循环方法不同罢了，还有其它数据类型，下面讨论。深复制实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 一个比较简单的深复制实现// 单层嵌套的深复制JSON.stringify()但是，1、它无法实现函数、正则、类的实例、稀疏数组(长度可能大于值得个数)、循环引用等特殊对象的深度克隆2、它会抛弃构造函数constructor，所有构造函数会指向Object3、对象的循环引用会报错// 函数function a() &#123; console.log(111)&#125;// 正则new RegExp(&apos;a&apos;)// 构造函数function animal(color) &#123; this.color = color&#125;var ani = new animal(&apos;red&apos;)var oldObj = &#123; a: a, b: new RegExp(&apos;a&apos;), c: ani, d: new Array(1)&#125;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newObj.a, oldObj.a); // undefined// 无法复制正则对象console.log(newObj.b, oldObj.b); // 构造函数指向错误console.log(newObj.c.constructor, oldObj.c.constructor);// 稀疏数组复制错误console.log(newObj.d, oldObj.d);// 循环引用复制错误const oldObj = &#123;&#125;;oldObj.a = oldObj;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.a, oldObj.a); 实现深复制数组1234567891011121314function deepcopy(arr)&#123; let _deepcopy = [] for (var i = 0, len=arr.length; i &lt; len; i++) &#123; // 不能让它总是执行下面这段话啊，即使是深复制了，一执行有浅复制了 _deepcopy[i] = arr[i] if(arr[i] instanceof Array) &#123; // 直接赋值引用 VS 循环一下返回个新数组,i是索引。 _deepcopy[i] = deepcopy(arr[i]) &#125; &#125;; return _deepcopy&#125; 但是这个只能深复制数组，原理就是对象类型就用新的对象。还有其它数据类型，下面讨论。类型比较全的深复制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const getRegExp = re =&gt; &#123; var flags = &apos;&apos;; if (re.global) flags += &apos;g&apos;; if (re.ignoreCase) flags += &apos;i&apos;; if (re.multiline) flags += &apos;m&apos;; return flags; &#125;;function deepcopy(obj) &#123; let typeString, newobj; if(typeof obj !== &quot;object&quot; &amp;&amp; typeof obj !== &apos;function&apos;) &#123; // 基本数据类型才返回 return obj; &#125; typeString = Object.prototype.toString.call(obj); switch(typeString) &#123; case &apos;[object Array]&apos;: newobj = []; break; case &apos;[object RegExp]&apos;: newobj = new RegExp(obj.source, getRegExp(obj)); break; case &apos;[object Date]&apos;: newobj = new Date(obj); break; default: newobj = &#123;&#125;; // 处理对象原型，这样也行 // proto = Object.getPrototypeOf(parent); // 利用Object.create切断原型链 // child = Object.create(proto); &#125; for (let i in obj) &#123; // 递归 newobj[i] = deepcopy(obj[i]); &#125; return newobj&#125;var arr = [1, &#123;a:1&#125;,2]var copyArr = deepcopy(arr);arr[1][&apos;a&apos;] = 2console.log(&apos;arr: &apos;,arr)console.log(&apos;copyArr: &apos;, copyArr)var reg = new RegExp(/\\w/,&apos;ig&apos;);var copyReg = deepcopy(reg)console.log(&apos;reg: &apos;,reg)console.log(&apos;copyReg: &apos;, copyReg)var d1 = new Date()var copyD1 = deepcopy(d1)console.log(&apos;d1: &apos;,d1)console.log(&apos;copyD1: &apos;, copyD1)var obj = &#123;a:&#123;a1:&#123;a2:1&#125;&#125;,b:1&#125;var copyObj = deepcopy(obj)obj[&apos;a&apos;][&apos;a1&apos;][&apos;a2&apos;]=2console.log(&apos;obj: &apos;,obj)console.log(&apos;copyObj: &apos;, copyObj) 其它数据类型参考loadsh 和 知乎一篇文章 123456789101112131415161718192021222324var argsTag = &apos;[object Arguments]&apos;, arrayTag = &apos;[object Array]&apos;, boolTag = &apos;[object Boolean]&apos;, dateTag = &apos;[object Date]&apos;, errorTag = &apos;[object Error]&apos;, funcTag = &apos;[object Function]&apos;, mapTag = &apos;[object Map]&apos;, numberTag = &apos;[object Number]&apos;, objectTag = &apos;[object Object]&apos;, regexpTag = &apos;[object RegExp]&apos;, setTag = &apos;[object Set]&apos;, stringTag = &apos;[object String]&apos;, weakMapTag = &apos;[object WeakMap]&apos;;var arrayBufferTag = &apos;[object ArrayBuffer]&apos;, float32Tag = &apos;[object Float32Array]&apos;, float64Tag = &apos;[object Float64Array]&apos;, int8Tag = &apos;[object Int8Array]&apos;, int16Tag = &apos;[object Int16Array]&apos;, int32Tag = &apos;[object Int32Array]&apos;, uint8Tag = &apos;[object Uint8Array]&apos;, uint8ClampedTag = &apos;[object Uint8ClampedArray]&apos;, uint16Tag = &apos;[object Uint16Array]&apos;, uint32Tag = &apos;[object Uint32Array]&apos;;","comments":true,"tags":[]},{"title":"常见面试题","date":"2018-04-15T00:20:18.000Z","path":"2018/04/15/常见面试题/","text":"","comments":true,"tags":[]},{"title":"分页","date":"2018-04-15T00:19:52.000Z","path":"2018/04/15/分页/","text":"反正就是想写个分页呢 1.先整个假数据 123let _data = &#123; &quot;images&quot;: [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]&#125; 2.把基本结构和样式写好 1234567891011121314&lt;style type=&quot;text/css&quot;&gt; body&#123; margin:0 auto;&#125; #container&#123; width:1000px; height:200px; overflow:hidden; margin:0 auto;&#125; #container span&#123; display:block; width:172px; height:172px; padding:3px; border:solid 1px #ccc; float:left; margin:10px; display:inline;&#125; #container span img&#123; width:172px; height:172px; border:none; float:left;&#125; #button&#123; width:1000px; height:40px; margin:0 auto; overflow:hidden;&#125; #button span.root&#123; display:block; width:180px; height:40px; overflow:hidden; margin:0 auto;&#125; #button span span&#123; display:block; width:28px; height:28px; overflow:hidden; border:solid 1px #ccc; float:left; margin-left:5px; display:inline; line-height:30px; font-size:13px; color:#555; text-align:center; cursor:pointer;&#125;&lt;/style&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;div id=&quot;button&quot;&gt;&lt;/div&gt; 3.创建分页类，并构思好架构 1234567891011121314151617181920// 分页类function PageContent() &#123; ..... this.bindEvent = function()&#123; ....用于绑定事件 &#125; this.initButton = function()&#123; .... 用于初始化分页按钮 &#125; this.getImg = function() &#123; ...用于获取图片,并对图片做样式包装 &#125; this.initData = function() &#123; ...用于初始化数据 &#125;&#125; 4.实现初始化数据 123456789// 也就是展示第一页的内容this.initData = function() &#123; // 加载图片并包装 this.getImg(_data, 0, this.pagesize) // 获取总页数 this.totalPages = Math.ceil(_data[&apos;images&apos;].length/this.pagesize) // 初始化分页按钮数 this.initButton()&#125; 5.实现获取图片 1234567this.getImg=function(data,_s,_o)&#123; var _html=&quot;&quot;; for(var i=_s;i&lt;_o;i++)&#123; _html+=&quot;&lt;span&gt;&lt;img alt=\\&quot;\\&quot; src=\\&quot;waterfall/&quot;+data[&quot;images&quot;][i]+&quot;.jpg&quot;+&quot;\\&quot;/&gt;&lt;/span&gt;&quot;; &#125; $(&quot;#container&quot;).html(_html);&#125; 6.初始化分页按钮 12345678910// 把一页展示的几个按钮显示出来,为了简单可以一页把所有的按钮都展示-_-!!!this.initButton=function()&#123; var _btn=&quot;&lt;span class=\\&quot;root\\&quot;&gt;&quot;; for(var i=this.s;i&lt;=this.o &amp;&amp; i&lt;this.total;i++)&#123; _btn+=&quot;&lt;span&gt;&quot;+i+&quot;&lt;/span&gt;&quot;; &#125; _btn+=&quot;&lt;/span&gt;&quot;; $(&quot;#button&quot;).html(_btn); this.bindEvent();&#125; 7.绑定事件 1234567891011this.bindEvent=function()&#123; var _self=this; $(&quot;.root span&quot;).click(function()&#123; // 为每个按钮添加点击事件，并且还要刷新按钮样式 _self.s=(parseInt($(this).html())-1)*_self.size; _self.o=_self.s+_self.size; // reloadData加载数据 _self.getImg(data,_self.s,_self.o); &#125;);&#125; 太草率了，以后附上github链接上面写法有问题，就是每次new对象的时候方法之类的重新创建，没做到原型共享12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 无聊花半小时写了个简单版，亲测有效const LoadData = &#123; &quot;images&quot;: [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]&#125;class PageContent &#123; constructor() &#123; this.pageSize = 5; this.totalBtns = 0; this.btnWrapper = document.getElementById(&apos;button&apos;); &#125; bindEvent() &#123; let btns = this.btnWrapper.querySelectorAll(&apos;button&apos;) for (var i = 0; i &lt; btns.length; i++) &#123; (function(i)&#123; btns[i].addEventListener(&apos;click&apos;,function () &#123; this.getImgs(LoadData, i*this.pageSize, (i+1)*this.pageSize) &#125;.bind(this)) &#125;.bind(this))(i) &#125;; &#125; getImgs(data, s, e) &#123; console.log(data, s, e) let wrapper = document.getElementById(&apos;container&apos;); let container = &apos;&apos;; for (var i = s; i &lt; e; i++) &#123; container+=` &lt;span&gt; &lt;img src=&quot;waterfall/$&#123;LoadData[&quot;images&quot;][i]&#125;.jpg&quot;/&gt; &lt;/span&gt; ` &#125;; wrapper.innerHTML = container; &#125; initButtons() &#123; this.totalBtns = Math.ceil(LoadData[&quot;images&quot;].length/this.pageSize); let container = &apos;&apos;; for (var i = 0; i &lt; this.totalBtns; i++) &#123; container+=` &lt;button&gt; $&#123;i+1&#125; &lt;/button&gt; ` &#125;; this.btnWrapper.innerHTML = container; this.bindEvent() &#125; initData () &#123; this.getImgs(LoadData, 0, this.pageSize) this.initButtons() &#125; &#125;var _pc=new PageContent(); _pc.initData();","comments":true,"tags":[]},{"title":"debounce和throttle","date":"2018-04-15T00:15:40.000Z","path":"2018/04/15/debounce和throttle/","text":"这个问题也经常会碰到，于是手动实现试试 debounce(防抖)间隔时间内只能执行一次 把该封装的封装，抽离的抽离123456789101112btn.addEventListener(&apos;click&apos;,debounce())function debounce() &#123; return function() &#123; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; todo() &#125;,500) &#125;&#125;function todo() &#123; console.log(11111)&#125; 再优化一下，回调，传参，绑定作用域123456789101112131415// 这个还是蛮标准的。btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; return function() &#123; let context = this; // btn let args = arguments; // 事件e clearTimeout(this.timer) this.timer = setTimeout(function()&#123; fn.apply(context, args) &#125;,delay) &#125;&#125;function todo(param) &#123; console.log(11111, param)&#125; 目前的情况是间隔时间后才触发，如果我想开始就触发，间隔时间后才能再次触发123456789101112131415161718192021btn.addEventListener(&apos;click&apos;,debounce(todo, 500))function debounce(fn, delay) &#123; let flag = true; return function() &#123; let context = this; let args = arguments; flag &amp;&amp; fn.apply(context, args) flag = false; clearTimeout(this.timer) this.timer = setTimeout(function()&#123; // 想再间隔时间后再执行，就加上它；感觉也行吧 // fn.apply(context, args) flag = true; &#125;,delay) &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 那如果我有时想立即触发，有时想最后一次点击delay后触发，加个参数呗1234btn.addEventListener(&apos;click&apos;,debounce(todo, 500, [true/false]))function debounce(fn, delay, immediate) &#123; ...&#125; throttle(节流) 在规定时间内，不断触发，就行水龙头的水一样 下面呢就实现间隔时间delay内不断触发，并且在最后一次触发的时候，delay秒后将再次自动触发1234567891011121314151617btn.addEventListener(&apos;click&apos;,throttle(todo, 500))function throttle(fn, delay) &#123; return function() &#123; let context = this; let args = arguments; if (!this.timer) &#123; // 没报错说明没语法错误，不执行说明逻辑没走掉这 this.timer = setTimeout(function()&#123; fn.apply(context, args) this.timer = null; &#125;.bind(this), delay) &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 但是呢，上面那个总是在delay后执行，不能立即执行；下面就用时间戳的形式实现立即执行,前提是初始点击的时候已经是delay后了12345678910111213141516btn.addEventListener(&apos;click&apos;,throttle(todo, 500)) function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; &#125; &#125; function todo(params) &#123; console.log(11111, params) &#125; 假如我想开始立即触发，最后那一次delay后也要执行一次呢12345678910111213141516171819202122btn.addEventListener(&apos;click&apos;,throttle(todo, 1000))function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let next = Date.now(); if (next-prev &gt; delay) &#123; fn.apply(context, args); prev = Date.now(); &#125; else &#123; // 一直清除定时器 clearTimeout(this.timer); this.timer = setTimeout(fn.bind(this, args),delay); &#125; &#125;&#125;function todo(params) &#123; console.log(11111, params)&#125; 适用场景 防抖放在购物车结算时，它只能点击一次； 节流放在购物车加减商品时，还有类似淘宝的搜索框，还有类似的resize,之类的不断触发AjAx的场景 有时防抖和节流会混合试用 看下lodash 关于防抖和节流的实现源码，反正是饶了一大圈，就不详细看了1234567891011121314151617181920212223242526272829303132333435363738394041424344function shouldInvoke(time) &#123; var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we&apos;re at the // trailing edge, the system time has gone backwards and we&apos;re treating // it as the trailing edge, or we&apos;ve hit the ```maxWait``` limit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));&#125;// 这个是判断是否解析时间的函数，应该是：1、初始点击要解析；2、大于间隔时间要解析。。。/** * A simple wrapper around the global [```setTimeout```](https://mdn.io/setTimeout). * * @private * @param &#123;Function&#125; func The function to delay. * @param &#123;number&#125; wait The number of milliseconds to delay invocation. * @returns &#123;number|Object&#125; Returns the timer id or timeout object. */ var setTimeout = ctxSetTimeout || function(func, wait) &#123; return root.setTimeout(func, wait); &#125;; // 对setTimeout进行封装，不知其意 function leadingEdge(time) &#123; // Reset any ```maxWait``` timer. lastInvokeTime = time; // Start the timer for the trailing edge. timerId = setTimeout(timerExpired, wait); // Invoke the leading edge. return leading ? invokeFunc(time) : result; &#125;// 中途调用了leadingEdge这个应该是加载方法，并且第一次调用时调用了invokeFunc(time)function invokeFunc(time) &#123; var args = lastArgs, thisArg = lastThis; lastArgs = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; &#125;// 而这个invokeFunc里面就调用了result = func.apply(thisArg, args);// func就是要执行的回调。","comments":true,"tags":[]},{"title":"��дvue��vuex","date":"2018-04-15T00:14:38.000Z","path":"2018/04/15/手写vue和vuex/","text":"�ο�����","comments":true,"tags":[]},{"title":"手写react和redux","date":"2018-04-15T00:14:38.000Z","path":"2018/04/15/手写react和redux/","text":"简单实现一个react，点赞组件。具体参考react小书，或my github 1.为了结构复用先构建类 123456class LikeButton &#123; render() &#123; .... &#125;&#125;// 最终的目的是new LikeButton()就可以在dom上创建实例 2.如何实现创建的实例上有绑定的事件 1234567891011121314class LikeButton &#123; constructor () &#123; .....this.state &#125; changeLikeText () &#123; ....操作state和dom &#125; render () &#123; ...字符串转换成dom,给dom绑定事件，最后实例化时通过dom方法渲染到页面 return this.el &#125;&#125; 3.添加setState方法，每次调用setState就调用render方法 12345setState (state) &#123; this.state = state this.el = this.render()&#125;// 这里面有坑 4.抽离公共组件 12345678910111213141516171819202122232425262728class Component &#123; setState (state) &#123; &#125; _renderDOM () &#123; &#125; &#125; class LikeButton extends Component &#123; constructor (props) &#123; super(props) &#125; onClick () &#123; &#125; render () &#123; return ` ... ` &#125; &#125; // 把组件的 DOM 元素插入页面，并且在 setState 的时候更新页面 mount(new LikeButton(), wrapper) 上面还涉及到柯里化但是看过很多博客都对柯里化做了解释总感觉有种牵强附会的感觉，强扭的瓜不甜。其实说白了，柯里化不过就是“用空间换时间”三个优点 参数复用 提前执行 延迟执行 具体代码详见github参考链接","comments":true,"tags":[]},{"title":"jQuery源码分析","date":"2018-04-15T00:14:00.000Z","path":"2018/04/15/jQuery源码分析/","text":"","comments":true,"tags":[]},{"title":"diary18-2-13","date":"2018-02-13T13:53:46.000Z","path":"2018/02/13/diary18-2-13/","text":"写日记这个习惯挺好","comments":true,"tags":[]},{"title":"vue动画","date":"2017-06-19T14:03:32.000Z","path":"2017/06/19/vue动画/","text":"","comments":true,"tags":[]},{"title":"Node.js","date":"2017-03-18T14:56:18.000Z","path":"2017/03/18/Node-js/","text":"第一步先把下面这个用5分钟看完-_-!! 12http://es6.ruanyifeng.com/ 第二步写demodemo1 实现登录注册demo2 读取歌词 1234567891011121314151617181920212223242526272829303132333435//读取歌词文件//使用cmd进入node脚本模式const fs=require(\"fs\");const path = require(\"path\");let _path=path.join(__dirname,'./xxx.lrc')fs.stat(_path,(err,stats)=&gt;&#123; if(err) throw err; //console.log(stats) fs.readFile(_path,(err,content)=&gt;&#123; if(err) throw err; //默认的就是utf-8,所以不用写。 //console.log(content.toString('utf-8')) let lines = content.toString('utf-8').split('\\n'); //console.log(lines); let rg=/\\[(\\d&#123;2&#125;)\\:(\\d&#123;2&#125;)\\.(\\d&#123;2&#125;)\\](.+)/; lines.forEach((line,index)=&gt;&#123; //console.log(rg.test(line)) let matchs =rg.exec(line); if(matchs)&#123; //console.log(matchs) let h = matchs[1]; let m = matchs[2]; let _s = matchs[3]; let w = matchs[4]; setTimeout(()=&gt;&#123; console.log(w); //定时器的参数是毫秒 &#125;,h*60*1000+m*1000+_s*10) &#125; &#125;) &#125;)&#125;);","comments":true,"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"xmapp","slug":"xmapp","permalink":"http://yoursite.com/tags/xmapp/"}]},{"title":"canvas","date":"2017-03-16T09:32:58.000Z","path":"2017/03/16/canvas/","text":"这篇主要是canvas最终要达到的效果是下面这个样子： demo1 弹弹球，碰撞就变色 这个解决最长时间的问题是： 1234ctx.beginPath();drawBall(ballX,ballY);ctx.closePath(); 缺了2行代码，导致运动完的路径一直都在。 demo2 时钟 demo3 画板 demo4 运动 这个的主要问题是： canvas的旋转是从上一次旋转开始计算的和css3不一样，除非加上save()和restore()方法； clearRect的时候还待translate(0,0)，这个问题。。反正我的浏览器待这样弄。 一个画板要画多个连续运动图像怎么办？ demo5 canvas拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;canvas id=\"can\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var can=document.getElementById(\"can\"); var ctx=can.getContext(\"2d\"); //移动时要覆盖以前的坐标，所以先配置 var points = [ &#123;x:100,y:100,r:50,startA:0,endA:2*Math.PI&#125;, &#123;x:200,y:200,r:50,startA:0,endA:2*Math.PI&#125; ] function drawArc()&#123; for (var i = 0; i &lt; points.length; i++) &#123; ctx.beginPath(); ctx.arc(points[i].x,points[i].y,points[i].r,points[i].startA,points[i].endA); ctx.fill(); &#125; &#125; drawArc(); //移动图形 can.onmousedown = function(e)&#123; var e = e || window.event; document.onmousemove=function(e)&#123; var e = e || window.event; ctx.clearRect(0,0,500,500); var x = e.layerX; var y = e.layerY; //重新绘制 for (var i = points.length - 1; i &gt;= 0; i--) &#123; var event = new addEvent(ctx,\"arc\",points[i].x+\",\"+points[i].y+\",\"+points[i].r+\",\"+points[i].startA+\",\"+points[i].endA,function()&#123; ctx.beginPath(); console.log(points[i].r+\"我是第53行\") var [callbackR,callbackX,callbackY] = [points[i].r,points[i].x,points[i].y] ctx.arc(x,y,callbackR,callbackX,callbackY); ctx.fill(); points[i].x = x; points[i].y = y; &#125;) event.isPointInPathCallback(x,y); &#125; event.isPointInPathCallback(x,y); &#125; document.onmouseup=function()&#123; document.onmousemove = null; document.onmouseup = null; &#125; &#125; /* //未点击之前先绘制，点击后再绘制；确保点击后是最新绘制的 ctx.beginPath(); ctx.arc(100,100,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(200,200,50,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.rect(400,200,50,50); ctx.fill(); //点击对应的图片，弹出对应的值 // can.onclick = function (e)&#123; // var e = e || window.event; // var x = e.layerX; // var y = e.layerY; // //和上面一个意思 // // var xx = e.offsetX; // // var yy = e.offsetY; // //如果把2*Math.PI当成字符串传进去是不行的。 // var event1 = new addEvent(ctx,\"arc\",\"100,100,50,0,\"+2*Math.PI,function()&#123; // alert(1); // &#125;) // event1.isPointInPathCallback(x,y); // var event2 = new addEvent(ctx,\"arc\",\"200,200,50,0,\"+2*Math.PI,function()&#123; // alert(2); // &#125;) // event2.isPointInPathCallback(x,y); // var event3 = new addEvent(ctx,\"rect\",\"400,200,50,50\",function()&#123; // alert(3); // &#125;) // event3.isPointInPathCallback(x,y); // &#125; */ //封装成一个util function addEvent (obj,type,data,callback)&#123; this.obj = obj; this.type = type; this.data = data; this.callback = callback; this.reDraw(); &#125; addEvent.prototype = &#123; reDraw:function()&#123; if(this.type == \"arc\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.arc(arr[0],arr[1],arr[2],arr[3],arr[4]); this.obj.fill(); &#125;else if(this.type == \"rect\")&#123; this.obj.beginPath(); var arr = this.data.split(\",\"); this.obj.rect(arr[0],arr[1],arr[2],arr[3]); this.obj.fill(); &#125; &#125;, isPointInPathCallback:function(x,y)&#123; if(this.obj.isPointInPath(x,y))&#123; this.callback(); &#125; &#125; &#125;;&lt;/script&gt; 存在的问题： 53行能打印出来，但是也报错Uncaught TypeError: Cannot read property ‘r’ of undefined。 点击图形起始点和图形的圆心是有距离的，后期拖拽时直接将拖拽的相对距离赋值给了圆心，导致误差。 还是有点懵。每次new 相同的event? demo6 canvas实现3d效果 很棒的canvas3次贝塞尔曲线算法地图 canvas库 参考链接：https://www.evget.com/article/2014/4/9/20799.html 报表统计 项目实现一个绘图工具 git地址：","comments":true,"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"","date":"2017-03-16T02:11:23.000Z","path":"2017/03/16/开源项目/","text":"","comments":true,"tags":[{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}]},{"title":"搭载git服务器","date":"2017-03-05T06:55:49.000Z","path":"2017/03/05/搭载git服务器/","text":"为什么要换系统呢，不换 node版本 或 插件版本 Ubuntu下搭载git服务器先给几个参考链接，我也是参考这里的。 链接一 链接二 链接三 链接四 首先你待有个Ubuntu系统 这里推荐用u盘安装。开始没用u盘安装，好久都没有安装成功。最后用u盘也就半个小时解决。 调出终端输入命令123sudo apt-get install gitsudo apt-get install openssh-server 可以通过下面的命令查看sshd相关的进程信息 12ps -ef|grep \"sshd\" 如果你能看到一些sshd相关的进程信息，则说明你已经有这个服务了。 然后，为自己配置身份信息，这样多个人提交代码的时候，就可以方便的查看是谁提交的。 123git config --global user.name \"yourname\" git config --global user.email \"your@email.com\" 再然后配置一个专门的git用户并设置密码，专门对代码进行管理。 123sudo useradd -m git(yours) sudo passwd git(change to yours) 然后，在新建的git用户主目录下创建一个文件夹作为git的仓库，并为这个仓库配备最基本的安防——权限控制 1234sudo mkdir /home/git/repositories # 最好使用repositories作为文件夹名称，这样可以简化后面的操作 sudo chown git:git /home/git/repositories sudo chmod 755 /home/git/repositories 输入一下命令基本就OK!!12345su git //切换到git用户,你可以发现路径前面变了mkdir helloworld //新建一个目录（仓库）cd helloworld git --bare init //初始化一个空的仓库 然后找一台机器测试一下 12git clone git@192.168.0.123:/home/git/repositories/helloworld 再加上下面这段命令，方便你可以push和pull 然后就成功了！ 再找第三台机器测试，还是成功的。 但是服务器里我什么也找不到，我开始以为失败了。 但是，还有 不足之处，比如别的文章提到的: 解决每个步骤都需要输入git用户的密码。 出于安全考虑，创建的git用户不允许登录shell。","comments":true,"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"Flux架构","date":"2017-03-04T14:19:53.000Z","path":"2017/03/04/Flux架构/","text":"最近公司做的项目据我观察就是flux架构，即使不是也是Flux存在多种实现之一，比如Redux之类的。 Flux架构先来个阮老师(好多人喜欢这么称呼)链接， 参考链接 Browse blog 基本概念 View：视图层； Action：动作层，视图层发出的消息(比如click)； Dispather: 派发器，用来接收action，执行回调函数； Store: 数据层，用来存放用用状态，一旦发生变动，就提醒View要更新页面； Flux特点 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 上面过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。 然后就是看阮老师的demo,我是看的差不多了。 想用调试工具调一下，先是用chrome react 插件,搞了好久，插件闪来闪去，没法弄。git上的源码又不知怎么变成crc文件。然后只能用react-hot-loader链接也可以试试react-transform 在webpack配置完react-hot-loader后又调不好程序了-_-!!!。不知道了，应该可以找到。 Redux2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 参考链接 整个过程是： 用户发出 Action，store.dispatch(action); Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State。 State 一旦有变化，Store 就会调用监听函数。 listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 然后，看demo。 还有异步操作：Action 发出以后，过一段时间再执行 Reducer，这就是异步。这个没细看，感觉像面向切面的编程(AOP)。 公司项目分析项目src的目录介绍 其实还是不大懂！！ 关于bind找了些资料总结一下：当需要传参，为了确保处理函数中的this时刻指向这个组件，就需要bind。bind会可以复制出一个函数，改变函数指针，给函数传参。 比如下面这个demo1234567891011121314151617181920212223242526272829var Hello=React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'', sex:'', age:'', tel:'', address:'' &#125; &#125;, changeValue:function(type,e)&#123; var that=this; var obj=&#123;&#125; obj[type]=e.target.value; that.setState(obj) &#125;, render:function()&#123; return ( &lt;div&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'name')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.name&#125;&lt;br/&gt; &lt;input onChange=&#123;this.changeValue.bind(this,'sex')&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.sex&#125;&lt;br/&gt; &lt;input onChange=&#123;this.ageChange&#125; type=\"text\" defaultValue='default value' /&gt;&#123;this.state.age&#125;&lt;br/&gt; &lt;/div&gt; ) &#125;&#125;) ReactDOM.render(&lt;Hello/&gt;,document.getElementById(\"app\")); 项目中初始化时bind 123456789101112131415161718192021class InvitationJoin extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; this.join = this.join.bind(this); &#125; join() &#123;&#125; render() &#123; return &lt;div className=&#123;style.box&#125;&gt; ....... &lt;div className=&#123;style.btnBox&#125;&gt; &lt;div className=&#123;button.normal&#125; onClick=&#123;this.join&#125;&gt;&#123;'加入'&#125;&lt;/div&gt; &lt;/div&gt; ........ &lt;/div&gt; &#125;&#125;export default InvitationJoin; 使用箭头函数从而避免bind,剑锋说效率低。 12暂时没找到，有时间再从项目中找。 webpack打包，不用考虑js的兼容。组件定义对象。123456xxxx(()=&gt;&#123;&#125;)&#123; return&#123; &#125;&#125; 实在没时间写了，改天再写！！！！！！","comments":true,"tags":[{"name":"前端架构","slug":"前端架构","permalink":"http://yoursite.com/tags/前端架构/"}]},{"title":"框架对比","date":"2017-03-04T10:59:30.000Z","path":"2017/03/04/框架对比/","text":"关于框架的对比网上资料很多，这里仅供参考 React的特点和优势 虚拟dom，减少不必要的更新，render Virtual DOM + diff + 必要的 DOM 更新。 jsx语法，结构清晰易于编写，必须是闭合标签。 单向数据流，只要服务端数据发生变动，前端数据也变动，开发者只关注实现业务就行了。 组件化开发，可组合、可重用、可维护、可测试。 vue没用过，听说vue是结合angular和react国产框架，是最简单的框架，这话不是我说的。还有人说，微信小程序内部是react native开发的，这话也不是我说的。 React和Vue对比 React和Vue的适用范围无疑是很相似的：同样是基于组件的轻量级框架，同样专注于用户界面的视图层。同样可以用在简单的项目中，也同样可以使用全家桶扩展为复杂的应用程序。 React是一个轻量级的框架，专注试图层，适用于简单个大型项目，并且可以从webApp像原生过度，reactNative。 如果喜欢使用模版用vue,因为react是借助jsx在js中创建DOM. 如果你喜欢简单，用vue,因为不需要转译，react重度依赖jsx和es6新特性，比如class。 竟可能小和快使用vue,渲染快，引入的文件小。 大型应用程序选择react,js模版可测试性和维护性很高。vue模版很难测试，维护，分解。 适用于Web端，和原生App的框架，用react。React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 如果你学过React.js，很快就能上手React Native。 更大的生态系统选择react。 如果你已经用其中一个用得很爽了，那就不用变了。 参考链接 Browse blog 附录：曾经问剑锋为什么选择react时，我做了点总结： react是偏向功能性的，轻量级的，单页面应用，组件开发，并且易于向原生开发过度(react native)。 他给我的印象就是，老是问我能用图画出来吗？然后还有以前的话，“尝试是错误的，想好再做”、“把快捷键都记住”、“要动脑，总结”，还有以前的话“把业务编号都记住”，连环踢T_T； Angular1 适用于SPA–路由机制;CRUD应用,如后台管理界面。 不适用,游戏、图形界面编辑器，这种频繁DOM操作也很复杂的应用。 Angular1的特性 MVC（模型 - 视图 - 控制器）或MVVM （模型 - 视图 - 视图模型）模式来组织源代码。 模块系统,依赖注入,可嵌入、注入和测试。 指令系统,可以创建可重用的自定义组件与指令的API。 HTML 模板,允许设计人员和开发人员同时工作。 数据双向绑定,当模型发生变化时，视图会自动更新，反之亦然。 以前公司的框架 以前公司的前台框架是使用jQuery UI部件库（Widget Factory）来创建插件，并且这也是最常见的一种方式，说来自己也研究好几年了,然并卵。 1234567891011121314$.widget( \"custom.progressbar\", &#123; // Default options. options: &#123; value: 0 &#125;, _create: function() &#123; var progress = this.options.value + \"%\"; this.element .addClass( \"progressbar\" ) .text( progress ); &#125;&#125;); 上面这段代码是从菜鸟学院粘贴过来的。 最后呢，曾经有人问我用angular1做项目，以后会不会出现什么问题？我说:”如果只是一个花瓶的话，用什么都没问题。”，最后再套用一下别人的话如果你已经用其中一个用得很爽了，那就不用变了。","comments":true,"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"}]},{"title":"React开发","date":"2017-03-04T04:20:08.000Z","path":"2017/03/04/React开发/","text":"最近公司用react开发项目，所以学习一下。 react组件react组件的生命周期关于react生命周期，不同的地方写得不一样但是，意思一样，我就挑一个写吧。 react设计组件的时候，把组件看成是有生命的物体，让它具有生命周期，共有三大周期。 创建期 存在期 销毁期 1、创建期创建期分为5个阶段： getDefaultProps :获取默认属性，还没创建出来，看不见内部的对象属性，只运行一次。 getInitialState :获取默认状态,数据已创建，可以访问实例化对象。 componentWillMount :组件将要被创建,组件的虚拟dom，将要渲染输出虚拟dom。 render :组件渲染输出虚拟dom,一定要通过return返回虚拟dom树。 componentDidMount :组件已经构建完成,组件已创建完成虚拟dom,可以操作真实的dom。 -_-! 以后就直接用画图工具画了，太丑陋，还待上传。 2、存在期存在期分为5个阶段： componentWillReceiveProps :组件将要接受新的属性。 shouldComponentUpdate :组件是否应该更新，必须返回true或false。 componentWillUpdate :组件将要更新。 render :组件更新，输出虚拟dom。 componentDidUpdate :组件已经更新完成。 3、销毁期销毁期就1个阶段： componentWillUnmount :组件即将被销毁。 下面是一个demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;React 实例&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var MessageBox = React.createClass(&#123; getInitialState:function()&#123; console.log('getInitialState'); return&#123; count:0, &#125; &#125;, getDefaultProps:function()&#123; console.log(\"getDefaultProps\"); &#125;, componentWillMount:function()&#123; console.log(\"componentWillMount\"); var self = this; this.timer = setInterval(function()&#123; self.setState(&#123; count:self.state.count + 1, &#125;) &#125;,1000); &#125;, componentDidMount:function()&#123; console.log(\"componentDidMount\"); &#125;, componentWillReceiveProps:function(nextProps)&#123; console.log(\"component will receive props\"); &#125;, shouldComponentUpdate:function(newProps,nextState)&#123; console.log(\"shouldComponentUpdate\"); if(nextState.count&gt;10)&#123; console.log(\"不要老是更新我！--优化作用\"); return false; &#125; return true; &#125;, componentWillUpdate:function(nextProps,nextState)&#123; console.log(\"component will update\"); &#125;, componentDidUpdate:function(prepProps,prepState)&#123; console.log(\"component did update\"); if(this.state.count&gt;3)&#123; clearInterval(this.timer); &#125; &#125;, componentWillUnmount:function()&#123; console.log(\"componet will unmount\"); alert(\"啊不要啊！！！\"); clearInterval(this.timer); &#125;, kill:function()&#123; ReactDOM.unmountComponentAtNode(document.getElementById('app')); &#125;, doUpdate:function()&#123; this.setState(&#123; count:this.state.count +1, &#125;); &#125;, render:function()&#123; console.log(\"渲染\"); return( &lt;div&gt; &lt;h1&gt;计数:&#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.kill&#125;&gt;卸载这个组件&lt;/button&gt; &lt;button onClick=&#123;this.doUpdate&#125;&gt;手动更新&lt;/button&gt; &lt;Submessage count=&#123;this.state.count&#125;/&gt; &lt;/div&gt; ) &#125; &#125;); var Submessage = React.createClass(&#123; componentWillReceiveProps:function(nextProp)&#123; console.log(\"子组件将要获取prop\"); &#125;, shouldComponentUpdate:function(nextProp,nextState)&#123; if(nextProp.count&gt;6) return false; return true; &#125;, render:function()&#123; return( &lt;h3&gt;当前计数是:&#123;this.props.count&#125;&lt;/h3&gt; ) &#125; &#125;); var messageBox = ReactDOM.render(&lt;MessageBox/&gt;,document.getElementById('app')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：","comments":true,"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"js理解","date":"2017-03-03T10:08:31.000Z","path":"2017/03/03/js理解/","text":"js中的面向对象面向对象的三大特性：封装、继承、多态。这里只说封装和继承。js面向对象的几种方式这个不同的人有不同的总结，仅供参考！ 1、工厂模式123456789101112131415function Person(name)&#123; // 原料 var obj=new Object(); // 加工 obj.name=name; obj.getName=function() &#123; console.log(this.name) &#125; //出厂 return obj;&#125;var person = Person(\"zhang\")person.getName(); 结果为1zhang 这种方式的缺点是：每一个实例都创建一个新的对象,浪费空间，并且创建实例时没有用关键字new； 2、构造函数模式123456789101112131415function Person(opt)&#123; this.config=&#123; name:\"zhang\" &#125; for(var i in opt)&#123; this.config[i]=opt[i] &#125; this.getName=function()&#123; console.log(this.config.name) &#125;&#125;var person = new Person(&#123;name:\"lisi\"&#125;)person.getName(); 结果为1lisi 这种方式的优势是：对象指向性强，new出的就是一个person示例； 3、混合模式123456789101112function Person(name)&#123; this.name = name;&#125;Person.prototype=&#123; getName:function()&#123; console.log(this.name) &#125;&#125;var person = new Person(\"lisi\")person.getName(); 结果为1lisi 这种方式的优势是：属性独立，并且可以根据原型链实现方法共享； js的继承首先介绍js中的原型链首先来一段代码 12345function funcA() &#123; this.show = function() &#123;&#125;&#125;console.log(funcA.prototype); 通过观察可以画出这样的图形 注：此图是盗用别人的图片，具体参考下面链接，此博客已被吾收录。 参考链接 Browse blog 总之，最后形成一张这样的图： 是不是感觉惊呆了！！！！！！如果让我画的话，比如一个b继承a的图，是这样：b是函数funcB()的实例，a是函数funA()的实例对象。 下面是js继承参考链接 Browse blog 1、使用原型链实现继承1234567891011121314151617function SuperClass()&#123; this.name = \"zhang\";&#125;SuperClass.prototype.say=function()&#123; console.log(this.name);&#125;function SubClass()&#123; this.name = \"haha\";&#125;SubClass.prototype.say=function()&#123; console.log(this.name);&#125;SubClass.prototype=new SuperClass();var sub = new SubClass();sub.say(); 结果是： 12haha 但是： 1234567891011121314151617function SuperClass()&#123; this.name = \"women\"; this.bra = [\"a\",\"b\"];&#125;function SubClass()&#123; this.subname = \"your sister\";&#125;SubClass.prototype = new SuperClass();var sub1 = new SubClass();sub1.name = \"man\";sub1.bra.push(\"c\");console.log(sub1.name);//manconsole.log(sub1.bra);//[\"a\",\"b\",\"c\"]var sub2 = new SubClass();console.log(sub1.name);//womanconsole.log(sub2.bra);//[\"a\",\"b\",\"c\"] 缺点显而易见：所有继承自SuperClass的实例都会受到影响，引用类型共享。 2、经典继承1234567891011121314function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this);&#125; var sub1 = new SubClass();console.log(sub1.sayWhat());//TypeError: undefined is not a function 但是： 1、如果在构造函数中有方法的定义，那么对于每一个实例都存在一份单独的Function引用，我们的目的其实是想共用这个方法。（其实不太懂）2、超类型原型中定义的方法，在子类型实例中是无法调用到。 3、组合式继承123456789101112131415function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function()&#123; console.log(\"hello\");&#125;function SubClass() &#123; this.subname = \"your sister\"; SuperClass.call(this); //第二次调用SuperClass&#125;SubClass.prototype = new SuperClass(); //第一次调用SuperClassvar sub1 = new SubClass();console.log(sub1.sayWhat());//hello 这个常用，寄生组合式继承就不写了，想了解的看原文。据说有寄生组合式继承的插件。 但是：这个模式调用了两次超类型的构造函数。 下面是我自己项目中的一段代码：MstBall继承了Missile 1234567891011121314151617181920212223/**组合式继承实现MasterBall这个类*/function MstBall(option)&#123; //经典继承 Missile.call(this,option);&#125;//原型继承MstBall.prototype = new Missile();//重写create方法MstBall.prototype._create = function() &#123; var mstBall = $(\"&lt;div class='missile \"+this.config.className+\"'&gt;\"); mstBall.css(&#123; width:this.config.width, height:this.config.height, transform:\"translate(\"+this.config.pos.x+\"px,\"+this.config.pos.y+\"px)\" &#125;); this.missile=mstBall; //console.log(this.missile) GameConfig.gameBox.append(this.missile); return this;&#125;; ES6中类和类的继承的写法123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 等同于parent.constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 等同于parent.toString() &#125;&#125; 参考链接 Browse blog参考链接 Browse blog ES6继承感觉像java中的的继承，规范了继承的操作。 最后，写点剑锋的东西，虽然最后被拉黑T_T 原型链作用域链demo1123456789//对name的访问, 哪种效率更高var name = '张三';function hello() &#123; console.log(name); console.log(window.name); console.log(this.name);&#125;hello(); 分析：1234567891011121314var name = '张三'; var start = new Date().getTime(); for(var i=0;i&lt;100000;i++)&#123; hello() &#125; var end = new Date().getTime(); alert(end-start); function hello()&#123; //console.log(name)//2234,2240,2372,2272---2279.5 //console.log(window.name);//2292,2439,2299,2437---2366.75 //console.log(this.name);//2302,2324,2272,2363--2315.25 &#125; 我就这么测了一下效率从高到低是name,this.name,window.name。。。和我分析的不一样啊！！不过测也不准，优势时间多有时时间低。 原型链特点 支持了面向对象开发模式 显示原型指针prototype, 任何函数都有(除了特殊Empty函数) 隐式原型指针__proto__, 任何对象都有(除了null, undefined, NaN) 特殊空函数只有__proto__ Object的原型对象的__proto__指向null 12345678Function instanceof Object //任何对象都是Object的实例Object instanceof Function //任何函数都是Function的实例Date.__proto__ === Function.prototypeFunction.__proto__ === Function.prototype","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"学习md语法","date":"2017-03-03T08:51:40.000Z","path":"2017/03/03/md语法/","text":"这是大标题这是小标题1$ 这里面放代码 这里放超链接: Writing 下面是插入图片 这里也是图片 1![不支持](/assets/blogImg/touxiang.png&#123;100x100&#125; \"测试图片并且定义宽高\") 1![不支持](/assets/blogImg/touxiang.png =100x100 \"测试图片并且定义宽高\") 1$ http://wowubuntu.com/markdown/basic.html 在博客园写博客想要好的样式，还必须用第三方工具，我记得是writerlive之类的；现在感觉太棒了！！下面这幅图是用截图工具处理的。。。。 这里是列表 这里是列表 1基本可以应付了。 步骤123hexo new title //默认问post布局，title改为你的文章名似乎还待加一句 $ hexo generate //生成静态文件hexo deploy 列表： 。。。。 。。。 Great !!!!","comments":true,"tags":[]},{"title":"用hexo制作博客","date":"2017-03-02T14:32:55.508Z","path":"2017/03/02/hexo博客/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]